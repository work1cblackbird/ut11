#Область ПрограммныйИнтерфейс

#Область ПроцедурыИФункцииОбщегоНазначения

// Рассчитывает дату окончания периода
//
// Параметры:
// ДатаНачала - Дата - дата начала, от которой будет рассчитана дата окончания периода
// Периодичность - Дата - значение перечисления "Периодичность"
// КоличествоПериодов - Число - количество повторов периода.
//
// Возвращаемое значение:
// 	Дата -
//
Функция РассчитатьДатуОкончанияПериода(ДатаНачала, Периодичность, КоличествоПериодов) Экспорт

	ОдинДень = 86400;

	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда 
		
		ДатаОкончания = ДатаНачала + ОдинДень * КоличествоПериодов;

	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		ДатаОкончания = ДатаНачала + ОдинДень * 7 * КоличествоПериодов;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца = День(ДатаНачала);
		НачМесяца = НачалоМесяца(ДатаНачала);
		Если ДеньМесяца <= 10 Тогда
			НомерДекады = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекады = 2;
		Иначе
			НомерДекады = 3;
		КонецЕсли;
			
		НомерДекады = НомерДекады + КоличествоПериодов;
		
		Если НомерДекады > 0 Тогда
			Месяцев = Цел((НомерДекады-1)/3);
		Иначе
			Месяцев = -1 - Цел((-НомерДекады)/3);
		КонецЕсли;
			
		НомерДекады = НомерДекады - 3*Месяцев;
		Дт = ДобавитьМесяц(НачМесяца, Месяцев) + (НомерДекады-1) * 10 * ОдинДень;

		Если КоличествоПериодов > 0 Тогда
			ДатаОкончания = Дт;
		
		Иначе 
			ДеньМесяца = День(Дт);

			Если ДеньМесяца <= 10 Тогда
				ДатаОкончания = КонецДня(НачалоМесяца(Дт) + ОдинДень * 9);
			ИначеЕсли ДеньМесяца <= 20 Тогда
				ДатаОкончания = КонецДня(НачалоМесяца(Дт) + ОдинДень * 19);
			Иначе
				ДатаОкончания = КонецМесяца(Дт);
			КонецЕсли;
		КонецЕсли;

	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 3 * КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 6 * КоличествоПериодов);

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		
		ДатаОкончания = ДобавитьМесяц(ДатаНачала, 12 * КоличествоПериодов);

	КонецЕсли;
			
	Возврат КонецДня(ДатаОкончания-ОдинДень);

КонецФункции // РассчитатьДатуОкончанияПериода()

// Рассчитывает ближайшую к указанной дату начала периода
//
// Параметры:
//	ДатаНачала - Дата - дата, к которой будет рассчитана ближайшая дата начала периода
// 	Периодичность - ПеречислениеСсылка.Периодичность - значение перечисления "Периодичность".
//
// Возвращаемое значение:
// 	Дата - Дата начала ближайшего периода.
//
Функция РассчитатьДатуНачалаБлижайшегоПериода(ДатаНачала, Периодичность) Экспорт
	
	ОдинДень = 86400;
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		
		БлижайшаяДата = ДатаНачала;
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		Если ДатаНачала = НачалоНедели(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецНедели(ДатаНачала) + ОдинДень;
		КонецЕсли;
		
	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца   = День(ДатаНачала);
		НачалоМесяца = НачалоМесяца(ДатаНачала);
		
		Если ДеньМесяца = 1 Или ДеньМесяца = 11 Или ДеньМесяца = 21 Тогда
			БлижайшаяДата = ДатаНачала;
		ИначеЕсли ДеньМесяца <= 10 Тогда // Первая декада
			БлижайшаяДата = НачалоМесяца + ОдинДень * 10;
		ИначеЕсли ДеньМесяца <= 20 Тогда // Вторая декада
			БлижайшаяДата = НачалоМесяца + ОдинДень * 20;
		Иначе // Третья декада
			БлижайшаяДата = КонецМесяца(НачалоМесяца) + ОдинДень;
		КонецЕсли;
		
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда
		
		Если ДатаНачала = НачалоМесяца(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецМесяца(ДатаНачала) + ОдинДень;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда
		
		Если ДатаНачала = НачалоКвартала(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецКвартала(ДатаНачала) + ОдинДень;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда
		
		НачалоГода      = НачалоГода(ДатаНачала);
		НачалоПолугодия = ДобавитьМесяц(НачалоГода,6);
		
		Если ДатаНачала = НачалоПолугодия Или ДатаНачала = НачалоГода Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = ?(ДатаНачала > НачалоПолугодия, КонецГода(ДатаНачала) + ОдинДень, НачалоПолугодия);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда
		
		Если ДатаНачала = НачалоГода(ДатаНачала) Тогда
			БлижайшаяДата = ДатаНачала;
		Иначе
			БлижайшаяДата = КонецГода(ДатаНачала) + ОдинДень;
		КонецЕсли;

	КонецЕсли;
	
	Возврат БлижайшаяДата;
	
КонецФункции // РассчитатьДатуНачалаБлижайшегоПериода()

// Сравнивает значения переданных структур по указанным свойствам
// Параметры:
// 	Структура1 - Структура -
// 	Структура2 - Структура -
//	Свойства - Массив, Структура, Строка - имена свойств, по которым нужно проводить сравнение  
// Возвращаемое значение:
// 	Булево - Истина, если структуры равны по значениям переданных свойств.
//
Функция СтруктурыРавны(Структура1, Структура2, Свойства = Неопределено) Экспорт
	
	ПоВсемСвойствам = Ложь;
	
	Если ТипЗнч(Свойства) = Тип("Строка") Тогда
		МассивСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	ИначеЕсли Свойства <> Неопределено Тогда 
		МассивСвойств = Свойства;
	Иначе
		ПоВсемСвойствам = Истина;
	КонецЕсли;
	
	Если ПоВсемСвойствам Тогда
		
		Для Каждого КлючЗначение Из Структура1 Цикл
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
			Если ТипЗнч(КлючЗначение.Значение) = Тип("ТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
#КонецЕсли
			Если ТипЗнч(КлючЗначение.Значение) = Тип("Массив")
				И Не МассивыРавны(КлючЗначение.Значение, Структура2[КлючЗначение.Ключ]) Тогда
				Возврат Ложь;
			ИначеЕсли (ТипЗнч(КлючЗначение.Значение) = Тип("Структура")
					ИЛИ ТипЗнч(КлючЗначение.Значение) = Тип("Соответствие"))
				И Не СтруктурыРавны(КлючЗначение.Значение, Структура2[КлючЗначение.Ключ]) Тогда
				Возврат Ложь;
			ИначеЕсли Не (ТипЗнч(КлючЗначение.Значение) = Тип("Массив")
					ИЛИ ТипЗнч(КлючЗначение.Значение) = Тип("Структура")
					ИЛИ ТипЗнч(КлючЗначение.Значение) = Тип("Соответствие"))
					И Не КлючЗначение.Значение = Структура2[КлючЗначение.Ключ] Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(МассивСвойств) = Тип("Массив") Тогда 
		Для Каждого СтрМас Из МассивСвойств Цикл
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
			Если ТипЗнч(Структура1[СтрМас]) = Тип("ТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
#КонецЕсли
			Если ТипЗнч(Структура1[СтрМас]) = Тип("Массив")
				И Не МассивыРавны(Структура1[СтрМас], Структура2[СтрМас]) Тогда
				Возврат Ложь;
			ИначеЕсли (ТипЗнч(Структура1[СтрМас]) = Тип("Структура")
					ИЛИ ТипЗнч(Структура1[СтрМас]) = Тип("Соответствие"))
				И Не СтруктурыРавны(Структура1[СтрМас], Структура2[СтрМас]) Тогда
				Возврат Ложь;
			ИначеЕсли Не (ТипЗнч(Структура1[СтрМас]) = Тип("Массив")
					ИЛИ ТипЗнч(Структура1[СтрМас]) = Тип("Структура")
					ИЛИ ТипЗнч(Структура1[СтрМас]) = Тип("Соответствие"))
					И Не Структура1[СтрМас] = Структура2[СтрМас] Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(МассивСвойств) = Тип("Структура") Тогда 
		Для Каждого КлючЗначение Из МассивСвойств Цикл
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
			Если ТипЗнч(Структура1[КлючЗначение.Ключ]) = Тип("ТаблицаЗначений") Тогда
				Продолжить;
			КонецЕсли;
#КонецЕсли
			Если ТипЗнч(Структура1[КлючЗначение.Ключ]) = Тип("Массив")
				И Не МассивыРавны(Структура1[КлючЗначение.Ключ], Структура2[КлючЗначение.Значение]) Тогда
				Возврат Ложь;
			ИначеЕсли (ТипЗнч(Структура1[КлючЗначение.Ключ]) = Тип("Структура")
					ИЛИ ТипЗнч(Структура1[КлючЗначение.Ключ]) = Тип("Соответствие"))
				И Не СтруктурыРавны(Структура1[КлючЗначение.Ключ], Структура2[КлючЗначение.Значение]) Тогда
				Возврат Ложь;
			ИначеЕсли Не (ТипЗнч(Структура1[КлючЗначение.Ключ]) = Тип("Массив")
					ИЛИ ТипЗнч(Структура1[КлючЗначение.Ключ]) = Тип("Структура")
					ИЛИ ТипЗнч(Структура1[КлючЗначение.Ключ]) = Тип("Соответствие"))
					И Не Структура1[КлючЗначение.Ключ] = Структура2[КлючЗначение.Значение] Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Сравнивает значения переданных массивов
//
// Параметры:
//	Массив1 - Массив - 
//	Массив2 - Массив - 
//	ПорядокИмеетЗначения - Булево - если Истина, то одинаковые значения должны иметь одинаковые индексы в массиве.
//
// Возвращаемое значение:
//	Булево - Истина, если массивы равны
//
Функция МассивыРавны(Массив1, Массив2, ПорядокИмеетЗначения = Истина) Экспорт
	
	Если Не Массив1.Количество() = Массив2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ПорядокИмеетЗначения Тогда
		
		Для Индекс = 0 По Массив1.Количество() - 1 Цикл
			Если Не Массив1[Индекс] = Массив2[Индекс] Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Для Каждого ТекущийЭлемент Из Массив1 Цикл
			Если Массив2.Найти(ТекущийЭлемент) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Возвращает структуру, содержащую ключи, имеющиеся в обеих исходных структурах.
//
// Параметры:
// 	Структура1 - Структура -
// 	Структура2 - Структура -
//
// Возвращаемое значение:
// 	Структура - 
//@skip-warning
Функция ПолучитьОбщиеКлючиСтруктур(Структура1, Структура2) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого КлючИЗначение Из Структура1 Цикл
		Если Структура2.Свойство(КлючИЗначение.Ключ) Тогда
			Результат.Вставить(КлючИЗначение.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Проверяет структуру на наличие одного ключа или всех сразу из переданного набора
//
// Параметры:
// 	Структура - Структура - Проверяемая структура
// 	Ключи - Строка - Перечисленные через запятую ключи
// 	ПроверятьВсе - Булево - Признак необходимости проверки наличия всех ключей из набора.
//
// Возвращаемое значение:
// 	Булево - Признак наличия одного или всех ключей набора в данной структуре.
//
Функция СтруктураСодержитКлючи(Структура, Ключи, ПроверятьВсе=Ложь) Экспорт
	
	ТребуемыеКлючи = Новый Структура(Ключи);
	Для Каждого КлючИЗначение Из ТребуемыеКлючи Цикл
		Если ПроверятьВсе И Не Структура.Свойство(КлючИЗначение.Ключ) Тогда
			Возврат Ложь;
		КонецЕсли;
		Если Не ПроверятьВсе И Структура.Свойство(КлючИЗначение.Ключ) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПроверятьВсе;
	
КонецФункции

// Строковое представление структуры
//
// Параметры:
//  Структура - Структура -
// 
// Возвращаемое значение:
//  Строка - представление переданной структуры в виде "<Ключ1>: <Значение1>; <Ключ2>: <Значение2>".
//
Функция ПредставлениеСтруктуры(Структура) Экспорт
	
	МассивСтрок = Новый Массив;
	Для Каждого КлючЗначение Из Структура Цикл
		МассивСтрок.Добавить(КлючЗначение.Ключ + ": " + Строка(КлючЗначение.Значение));
	КонецЦикла;
	
	Возврат СтрСоединить(МассивСтрок, "; ");
	
КонецФункции

// Дополняет структуру приемник полями структуры источника
//
// Параметры:
// 		СтруктураПриемник - Структура - Структура, в которую необходимо скопировать поля
// 		СтруктураИсточник - Структура - Структура, из которой необходимо скопировать поля
// 		КопироватьЗначения - Булево - Истина, если надо копировать значения.
//
Процедура ДополнитьСтруктуру(СтруктураПриемник, СтруктураИсточник, КопироватьЗначения=Ложь) Экспорт
	
	Для Каждого Элемент Из СтруктураИсточник Цикл
		СтруктураПриемник.Вставить(Элемент.Ключ, ?(КопироватьЗначения, Элемент.Значение, Неопределено));
	КонецЦикла;
	
КонецПроцедуры // ДополнитьСтруктуру()

// Возвращает период, увеличенный на количество периодов
//
// Параметры:
//	БазоваяДата - Дата - дата, относительно которой рассчитывается период
//	Периодичность - ПеречислениеСсылка.Периодичность - размер периода
//	КоличествоПериодов - Число - количество периодов, на которое нужно расширить базовый.
//                     если = 0, то возвращается период, в котором находится базовая дата,
//                     если < 0, то возвращаются период, соответствующий предыдущим периодам,
//                     если > 0, то возвращаются период, соответствующий следующим периодам.
// Возвращаемое значение:
// 	СтандартныйПериод - 
Функция РасширенныйПериод(БазоваяДата, Периодичность, КоличествоПериодов = 0) Экспорт

	ОдинДень = 86400;
	Период = Новый СтандартныйПериод;
	Период.Вариант = ВариантСтандартногоПериода.ПроизвольныйПериод;

	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда

		Период.ДатаНачала    = НачалоДня(БазоваяДата);
		Период.ДатаОкончания = КонецДня(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = Период.ДатаНачала + ОдинДень * КоличествоПериодов;
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = Период.ДатаОкончания + ОдинДень * КоличествоПериодов;
		КонецЕсли;

	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда

		Период.ДатаНачала    = НачалоНедели(БазоваяДата);
		Период.ДатаОкончания = КонецНедели(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = Период.ДатаНачала + ОдинДень * 7 * КоличествоПериодов;
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = Период.ДатаОкончания + ОдинДень * 7 * КоличествоПериодов;
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада")) Тогда
		
		ДеньМесяца = День(БазоваяДата);
		Если ДеньМесяца <= 10 Тогда
			НомерДекадыБазовый = 1;
		ИначеЕсли ДеньМесяца <= 20 Тогда
			НомерДекадыБазовый = 2;
		Иначе
			НомерДекадыБазовый = 3;
		КонецЕсли;
		
		Если КоличествоПериодов >= 0 Тогда
			
			НомерДекады = НомерДекадыБазовый + КоличествоПериодов + 1;
			СмещениеМесяцев = Цел((НомерДекады - 1) / 3);
			НомерДекады = НомерДекады - 3 * СмещениеМесяцев;
			
			ДатаНачала = НачалоМесяца(БазоваяДата);
			Если НомерДекадыБазовый = 2 Тогда
				ДатаНачала = ДатаНачала + 9 * ОдинДень;
			ИначеЕсли НомерДекадыБазовый = 3 Тогда
				ДатаНачала = ДатаНачала + 19 * ОдинДень;
			КонецЕсли;
			Период.ДатаНачала = ДатаНачала;
			
			ДатаОкончания = ДобавитьМесяц(НачалоМесяца(БазоваяДата), СмещениеМесяцев);
			Если НомерДекады = 2 Тогда
				ДатаОкончания = ДатаОкончания + 9 * ОдинДень;
			ИначеЕсли НомерДекады = 3 Тогда
				ДатаОкончания = ДатаОкончания + 19 * ОдинДень;
			КонецЕсли;
			Период.ДатаОкончания = ДатаОкончания - 1;
			
		Иначе
			
			НомерДекады = НомерДекадыБазовый + КоличествоПериодов;
			СмещениеМесяцев = -1 - Цел((-НомерДекады) / 3);
			НомерДекады = НомерДекады - 3 * СмещениеМесяцев;
			ДатаНачала = ДобавитьМесяц(НачалоМесяца(БазоваяДата), СмещениеМесяцев);
			Если НомерДекады = 2 Тогда
				ДатаНачала = ДатаНачала + 9 * ОдинДень;
			ИначеЕсли НомерДекады = 3 Тогда
				ДатаНачала = ДатаНачала + 19 * ОдинДень;
			КонецЕсли;
			Период.ДатаНачала = ДатаНачала;
			
			ДатаОкончания = НачалоМесяца(БазоваяДата);
			Если НомерДекадыБазовый = 2 Тогда
				ДатаОкончания = ДатаОкончания + 9 * ОдинДень;
			ИначеЕсли НомерДекадыБазовый = 3 Тогда
				ДатаОкончания = ДатаОкончания + 19 * ОдинДень;
			КонецЕсли;
			Период.ДатаОкончания = ДатаОкончания - 1;
			
		КонецЕсли;
		
	ИначеЕсли (Периодичность= ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")) Тогда

		Период.ДатаНачала    = НачалоМесяца(БазоваяДата);
		Период.ДатаОкончания = КонецМесяца(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала = ДобавитьМесяц(Период.ДатаНачала, КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал")) Тогда

		Период.ДатаНачала    = НачалоКвартала(БазоваяДата);
		Период.ДатаОкончания = КонецКвартала(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 3*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 3*КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие")) Тогда

		Если Месяц(БазоваяДата) < 7 Тогда
			Период.ДатаНачала    = НачалоГода(БазоваяДата);
			Период.ДатаОкончания = ДобавитьМесяц(КонецГода(БазоваяДата), - 6);
		Иначе
			Период.ДатаНачала    = ДобавитьМесяц(НачалоГода(БазоваяДата), 6);
			Период.ДатаОкончания = КонецГода(БазоваяДата);
		КонецЕсли;

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 6*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 6*КоличествоПериодов);
		КонецЕсли;

	ИначеЕсли (Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год")) Тогда

		Период.ДатаНачала    = НачалоГода(БазоваяДата);
		Период.ДатаОкончания = КонецГода(БазоваяДата);

		Если КоличествоПериодов < 0 Тогда
			Период.ДатаОкончания = Период.ДатаНачала - 1;
			Период.ДатаНачала    = ДобавитьМесяц(Период.ДатаНачала, 12*КоличествоПериодов);
		ИначеЕсли КоличествоПериодов > 0 Тогда
			Период.ДатаНачала    = Период.ДатаОкончания + 1;
			Период.ДатаОкончания = ДобавитьМесяц(Период.ДатаОкончания, 12*КоличествоПериодов);
		КонецЕсли;

	КонецЕсли;

	Возврат Период;

КонецФункции

// Проверяет строку с адресом электронной почты на корректность введенных данных
//
// Параметры:
//  ПроверяемыйАдрес - Строка - содержит строку с адресом электронной почты, которую необходимо проверить.
//  
// Возвращаемое значение:
//   Булево - Ложь, если проверка закончилась успешно, Истина в обратном случае.
//
Функция ПроверитьЗаполнениеПочтовогоАдреса(ПроверяемыйАдрес) Экспорт
	
	Отказ = Ложь;
	АдресДляПроверки = ПроверяемыйАдрес;
	
	Попытка
		Результат =  ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСПочтовымиАдресами(АдресДляПроверки);	 
	Исключение 		
		Отказ = Истина;
	КонецПопытки;
	
	Если НЕ Отказ Тогда
		Если Результат.Количество() = 0 Тогда
			Отказ =  Истина;
		Иначе	
			АдресДляПроверки = Результат[0].Адрес;
			Если СтрЧислоВхождений(АдресДляПроверки,"@") <> 1 Тогда 
				Отказ = Истина;
			Иначе
				ДоменныйАдрес = Прав(АдресДляПроверки, СтрДлина(АдресДляПроверки) - СтрНайти(АдресДляПроверки,"@"));
				Если СтрДлина(ДоменныйАдрес) > 0 Тогда
					Если СтрЧислоВхождений(ДоменныйАдрес,".") < 1 ИЛИ Лев(ДоменныйАдрес,1) = "." ИЛИ Прав(ДоменныйАдрес,1) = "." Тогда
						Отказ = Истина;
					КонецЕсли;
				Иначе
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;	
	КонецЕсли;	
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеПочтовогоАдреса() 

// Вычисляет значение идентификатора из строки соответствии с правилами именования идентификаторов.
// 
// Параметры:
// 	СтрНаименование - Строка - 
// 	
// Возвращаемое значение:
// 	Строка - Идентификатор, соответствующий правилам именования идентификаторов.
//
Функция ПолучитьИдентификатор(СтрНаименование) Экспорт
	
	Разделители	=  " .,+,-,/,*,?,=,<,>,(,)%!@#$%&*""№:;{}[]?()\|/`~'^_";
	
	Идентификатор = "";
	БылСпецСимвол = Ложь;
	
	Для НомСимвола = 1 По СтрДлина(СтрНаименование) Цикл
		
		Символ = Сред(СтрНаименование, НомСимвола, 1);
		
		Если СтрНайти(Разделители, Символ) <> 0 Тогда
			БылСпецСимвол = Истина;
		ИначеЕсли БылСпецСимвол Тогда
			БылСпецСимвол = Ложь;
			Идентификатор = Идентификатор + ВРег(Символ);
		Иначе
			Идентификатор = Идентификатор + Символ;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Идентификатор;
	
КонецФункции // ПолучитьИдентификатор()

// Заполняет все строки указанных колонок коллекции указанным значением
//
// Параметры:
// 		Коллекция - ДанныеФормыКоллекция - Коллекция для заполнения строк
// 		Значение - Произвольный - Значение для подстановки
// 		Колонки - Строка - Строка перечисленных через запятую имен колонок коллекции.
//
Процедура ЗаполнитьЗначенияСвойствКоллекции(Коллекция, Значение, Колонки) Экспорт
	
	СтруктураЗаполнения = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураЗаполнения Цикл
		СтруктураЗаполнения[Колонка.Ключ] = Значение;
	КонецЦикла;
	
	Для Счетчик = 0 По Коллекция.Количество() - 1 Цикл
		ЗаполнитьЗначенияСвойств(Коллекция[Счетчик], СтруктураЗаполнения);
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьЗначенияКолонокКоллекции()

// Используется для преобразования страниц
//
// Параметры:
//  СтрокаКПреобразованию - Строка - Строка, из которой необходимо удалить блок
//  СтрокаОграничивающая - Строка - ограничитель блока, который подлежит удалению.
//
Процедура УдалитьИзСтрокиПодстроку(СтрокаКПреобразованию, СтрокаОграничивающая) Экспорт
	
	Если СтрНайти(СтрокаКПреобразованию, СтрокаОграничивающая) = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ДлинаОграничивающейСтроки = СтрДлина(СтрокаОграничивающая);
	ИндексПервогоВхождения = СтрНайти(СтрокаКПреобразованию, СтрокаОграничивающая);
	ЛеваяЧасть =  ЛЕВ(СтрокаКПреобразованию, ИндексПервогоВхождения-1);
	ПраваяЧастьСтрокиКОбработке = Прав(СтрокаКПреобразованию, СтрДлина(СтрокаКПреобразованию) - ИндексПервогоВхождения - ДлинаОграничивающейСтроки);
	ИндексВторогоВхождения = СтрНайти(ПраваяЧастьСтрокиКОбработке, СтрокаОграничивающая);
	ПраваяЧасть = ПРАВ(ПраваяЧастьСтрокиКОбработке,СтрДлина(ПраваяЧастьСтрокиКОбработке) - ИндексВторогоВхождения -ДлинаОграничивающейСтроки + 1);
	
	СтрокаКПреобразованию = ЛеваяЧасть +  ПраваяЧасть;
	
КонецПроцедуры

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//		ИсхСумма - Число -распределяемая сумма
//		МассивКоэф - Массив Из Число - коэффициенты распределения
//		Точность - Число - точность округления при распределении. Необязателен.
//
//	Возвращаемое значение:
//		Массив из Число - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено.
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2) Экспорт

	Если МассивКоэф.Количество() = 0 Или ИсхСумма = 0 Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;

	Для Счетчик = 0 По МассивКоэф.Количество() - 1 Цикл

		МодульЧисла = ?(МассивКоэф[Счетчик] > 0, МассивКоэф[Счетчик], - МассивКоэф[Счетчик]);

		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач = МодульЧисла;
			ИндексМакс = Счетчик;
		КонецЕсли;

		СуммаКоэф = СуммаКоэф + МассивКоэф[Счетчик];

	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для Счетчик = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[Счетчик] = Окр(ИсхСумма * МассивКоэф[Счетчик] / СуммаКоэф, Точность, 1);
		РаспрСумма = РаспрСумма + МассивСумм[Счетчик];
	КонецЦикла;

	// Погрешности округления отнесем на коэффициент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Проверяет, что авторизован внешний пользователь
//
// Возвращаемое значение:
//   Булево   - Истина, если авторизован внешний пользователь. Ложь, в обратном случае.
//
Функция АвторизованВнешнийПользователь() Экспорт

	Возврат ТипЗнч(ПользователиКлиентСервер.АвторизованныйПользователь()) =  Тип("СправочникСсылка.ВнешниеПользователи");

КонецФункции

// Функция формирует список значений, содержащий значения времени, рассчитанные
// с указанным интервалом.
//
// Параметры:
//	ТекущееЗначение - Дата - исходное значение времени
//	Интервал - Число - интервал, с которым необходимо заполнить список, по умолчанию час.
//
// Возвращаемое значение:
// 	СписокЗначений -
Функция СписокВремени(Знач ТекущееЗначение = '00010101000000', Интервал = 3600) Экспорт
	
	НачалоРабочегоДня      = '00010101000000';
	ОкончаниеРабочегоДня   = '00010101235959';

	СписокВремен = Новый СписокЗначений;
	НачалоРабочегоДня = НачалоЧаса(НачалоДня(ТекущееЗначение)
		+ Час(НачалоРабочегоДня) * 3600
		+ Минута(НачалоРабочегоДня)*60);
	ОкончаниеРабочегоДня = КонецЧаса(НачалоДня(ТекущееЗначение)
		+ Час(ОкончаниеРабочегоДня) * 3600
		+ Минута(ОкончаниеРабочегоДня)*60);

	ВремяСписка = НачалоРабочегоДня;
	Пока НачалоЧаса(ВремяСписка) <= НачалоЧаса(ОкончаниеРабочегоДня) Цикл
		Если НЕ ЗначениеЗаполнено(ВремяСписка) Тогда
			ПредставлениеВремени = "00:00";
		Иначе
			ПредставлениеВремени = Формат(ВремяСписка, НСтр("ru='ДФ=''ЧЧ:мм'''"));
		КонецЕсли;

		СписокВремен.Добавить(ВремяСписка, ПредставлениеВремени);

		ВремяСписка = ВремяСписка + Интервал;
	КонецЦикла;
	
	Возврат СписокВремен;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - Строка - форма слова в ед числе      ("шкаф")
//  Слово2 - Строка - форма слова для числит 2-4  ("шкафа")
//  Слово3 - Строка - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - Число - целое число.
//
// Возвращаемое значение:
//  Строка - одна из строк в зависимости от параметра ЦелоеЧисло.
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным.
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт
	
	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться.
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Определяет, является ли контрагент юридическим лицом
//
// Параметры:
//	ЮридическоеФизическоеЛицо - ПеречислениеСсылка.ЮридическоеФизическоеЛицо - вид контрагента.
//
// Возвращаемое значение:
//  Булево - Истина, если это юридическое лицо, Ложь в обратном случае.
//
Функция ЭтоЮрЛицо(ЮридическоеФизическоеЛицо) Экспорт
	
	Если ТипЗнч(ЮридическоеФизическоеЛицо) = Тип("ПеречислениеСсылка.ЮридическоеФизическоеЛицо") Тогда
		Возврат ЮридическоеФизическоеЛицо = ПредопределенноеЗначение("Перечисление.ЮридическоеФизическоеЛицо.ЮридическоеЛицо");
	Иначе
		Возврат ЮридическоеФизическоеЛицо = ПредопределенноеЗначение("Перечисление.ЮрФизЛицо.ЮрЛицо")
			Или ЮридическоеФизическоеЛицо = ПредопределенноеЗначение("Перечисление.ЮрФизЛицо.ЮрЛицоНеРезидент");
	КонецЕсли;

КонецФункции

// Возвращает слово в разных склонениях (в соответствии с числом)
// Основное назначение - использование для склонения надписей единиц измерения в формах
// для различных числовых полей.
//
// Параметры:
//	Число - Число - число, определяет склонение
//	ЕдЧислоИменительный - Строка - единственное число именительный падеж. Например, "день" или "неделя".
//	ЕдЧислоРодительный - Строка - единственное число родительный падеж. Например, "дня" или "недели".
//	МнЧислоРодительный - Строка - множественное число родительный падеж. Например, "дней" или "недель".
//	Пол - Строка - м - мужской род (ж - женский род, с - средний род); 
//
// Возвращаемое значение:
//  Строка - слово в правильном склонении.
//
Функция СклонениеСлова(ЧислоДляСклонения, ЕдЧислоИменительный, ЕдЧислоРодительный, МнЧислоРодительный, Пол) Экспорт
	
	СловоПрописью = "";
	ПараметрыПредметаИсчисления = ЕдЧислоИменительный + ", " + ЕдЧислоРодительный + ", " + МнЧислоРодительный + ", " + Пол;
	
	СловоПрописью = ЧислоПрописью(ЧислоДляСклонения, , ПараметрыПредметаИсчисления);
	
	Если СтрНайти(СловоПрописью, МнЧислоРодительный) Тогда
		СловоПрописью = МнЧислоРодительный;
	ИначеЕсли СтрНайти(СловоПрописью, ЕдЧислоРодительный) Тогда
		СловоПрописью = ЕдЧислоРодительный;
	ИначеЕсли СтрНайти(СловоПрописью, ЕдЧислоИменительный) Тогда
		СловоПрописью = ЕдЧислоИменительный;
	КонецЕсли;
	
	Возврат СловоПрописью;
	
КонецФункции

// Возвращает строковое представление периода.
//
// Параметры:
//  ПериодРегистрации - Дата   - Дата внутри месяца или квартала, представление которых нужно получить
//  КалендарныйПериод - Строка - "Месяц" или "Квартал".
//
// Возвращаемое значение:
//  Строка - Представление месяца или квартала, внутри которых находится значение ПериодРегистрации.
//
Функция ПолучитьПредставлениеПериодаРегистрации(ПериодРегистрации, КалендарныйПериод = "Месяц") Экспорт

	Если ВРег(КалендарныйПериод) = "МЕСЯЦ" Тогда
		Возврат Формат(ПериодРегистрации, НСтр("ru='ДФ=''MMMM yyyy'''"))
	ИначеЕсли ВРег(КалендарныйПериод) = "КВАРТАЛ" Тогда
		Возврат ПредставлениеПериода(НачалоКвартала(ПериодРегистрации), КонецКвартала(ПериодРегистрации));
	КонецЕсли;

КонецФункции

// Дополняет таблицу значений Таблица значениями из массива Массив.
//
// Параметры:
//  ТаблицаПриемник     - ТаблицаЗначений - таблица, которую необходимо заполнить значениями из массива;
//  Массив              - Массив - массив значений для заполнения таблицы;
//  ИмяПоля             - Строка - имя поля таблицы значений, в которое необходимо загрузить значения из массива.
//  ЗначенияПоУмолчанию - Структура - имена полей и их значения, которыми будет заполнена каждая добавляемая строка.
// 
Процедура ДополнитьТаблицуИзМассива(ТаблицаПриемник, Массив, ИмяПоля, ЗначенияПоУмолчанию = Неопределено) Экспорт

	Для каждого Значение Из Массив Цикл
		НоваяСтрока = ТаблицаПриемник.Добавить();
		НоваяСтрока[ИмяПоля] = Значение;
		Если ЗначенияПоУмолчанию <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначенияПоУмолчанию, , ?(ЗначенияПоУмолчанию.Свойство(ИмяПоля), ИмяПоля, ""));
		КонецЕсли; 
	КонецЦикла;
	
КонецПроцедуры

// Дополняет таблицу значений-приемник данными из таблицы значений-источник.
//
// Параметры:
//  ТаблицаИсточник	 - ТаблицаЗначений	 - таблица, из которой будут браться строки для заполнения;
//  ТаблицаПриемник	 - ТаблицаЗначений	 - таблица, в которую будут добавлены строки из таблицы-источника.
//  ЗначенияПоУмолчанию - Структура      - ключ - название колонки таблицы-приемника, значение - значение по умолчанию
//  ПриоритетЗначенийПоУмолчанию - Булево - признак того, что переданные умолчания будут приоритетнее данных из таблицы-источника.
//
// Возвращаемое значение:
//  Массив Из СтрокаТаблицыЗначений - содержит добавленные строки.
//
//@skip-warning
Функция ДополнитьТаблицу(Знач ТаблицаИсточник, ТаблицаПриемник, ЗначенияПоУмолчанию = Неопределено, ПриоритетЗначенийПоУмолчанию = Ложь) Экспорт
	
	ДобавленныеСтроки = Новый Массив;
	Для Каждого СтрокаТаблицыИсточник Из ТаблицаИсточник Цикл
		НоваяСтрока = ТаблицаПриемник.Добавить();
		Если ЗначенияПоУмолчанию <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначенияПоУмолчанию);
			
			Если ПриоритетЗначенийПоУмолчанию Тогда
				ЗаполнитьЗначенияСвойств(СтрокаТаблицыИсточник, ЗначенияПоУмолчанию);
			КонецЕсли;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицыИсточник);
		ДобавленныеСтроки.Добавить(НоваяСтрока);
	КонецЦикла;
	
	Возврат ДобавленныеСтроки;
	
КонецФункции

// Дополняет таблицу значений-приемник данными из таблицы значений-источник.
//
// Параметры:
//  ТаблицаЗначений	 - ТаблицаЗначений	 - таблица, в которой буду изменять данные
//  КолонкаИсточник	 - Строка	 - колонка, из которой будут извлекаться значения
//  КолонкаПриемник	 - Строка	 - колонка, в которую будут устанавливаться значения.
// 
Процедура СкопироватьЗначенияИзКолонкиВКолонку(ТаблицаЗначений, КолонкаИсточник, КолонкаПриемник) Экспорт
	
	Для Каждого СтрокаТаблицыЗначений Из ТаблицаЗначений Цикл
		СтрокаТаблицыЗначений[КолонкаПриемник] = СтрокаТаблицыЗначений[КолонкаИсточник];
	КонецЦикла;
	
КонецПроцедуры

// Заполняет значения свойств приемника по значениям свойств источника, если эти свойства в приемнике не заполнены.
//
// Параметры:
//  Приемник - Структура, Соответствие, ФиксированнаяСтруктура, ФиксированноеСоответствие, Произвольный  - коллекция структуры данных, значения свойств, которых необходимо заполнить.
//  Источник		 - Структура, Соответствие, ФиксированнаяСтруктура, ФиксированноеСоответствие - коллекция структуры данных,
// 												являющаяся источником значений свойств, которые необходимо заполнить в приемнике.
//  СписокСвойств	 - Строка,Массив,Неопределено - имена свойств через запятую или массив имен свойств, которые нужно заполнить.
//													Если передано Неопределено - заполняются все совпадающие в приемнике и источнике свойства.
//  ИсключаяСвойства - Строка,Массив,Неопределено - имена свойств через запятую или массив имен свойств, которые нужно исключить из заполнения.
//													Если передано Неопределено - заполняются все свойства.
//
Процедура ЗаполнитьЗначенияПустыхСвойств(Приемник, Источник, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	Если ИсключаяСвойства = Неопределено Тогда
		ИсключаяСвойстваМассив = Новый Массив;
	ИначеЕсли ТипЗнч(ИсключаяСвойства) = Тип("Строка") Тогда	
		ИсключаяСвойстваМассив = СтрРазделить(ИсключаяСвойства, ",");
	Иначе
		ИсключаяСвойстваМассив = ИсключаяСвойства;
	КонецЕсли;
		
	Если СписокСвойств = Неопределено Тогда
		
		ПриемникОбъект = Не (ТипЗнч(Приемник) = Тип("Структура")
							Или ТипЗнч(Приемник) = Тип("Соответствие")
							Или ТипЗнч(Приемник) = Тип("ФиксированнаяСтруктура")
							Или ТипЗнч(Приемник) = Тип("ФиксированноеСоответствие"));
		
		Для каждого КлючЗначение Из Источник Цикл
			Если ИсключаяСвойстваМассив.Найти(КлючЗначение.Ключ) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ЕстьСвойство = ?(ПриемникОбъект,
							ЕстьРеквизитОбъекта(Приемник, КлючЗначение.Ключ),
							Приемник.Свойство(КлючЗначение.Ключ));
			
			Если ЕстьСвойство
				И ((ТипЗнч(Приемник[КлючЗначение.Ключ]) = Тип("Булево")
						И Не Приемник[КлючЗначение.Ключ])
					Или Не ЗначениеЗаполнено(Приемник[КлючЗначение.Ключ])) Тогда
				Приемник[КлючЗначение.Ключ] = КлючЗначение.Значение;
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		Если ТипЗнч(СписокСвойств) = Тип("Строка") Тогда	
			СписокСвойствМассив = СтрРазделить(СписокСвойств, ",");
		Иначе
			СписокСвойствМассив = СписокСвойств;
		КонецЕсли;
		
		Для каждого СтрМас Из СписокСвойствМассив Цикл
			Если ИсключаяСвойстваМассив.Найти(СтрМас) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Если (ТипЗнч(Приемник[СтрМас]) = Тип("Булево")
						И Не Приемник[СтрМас])
					Или Не ЗначениеЗаполнено(Приемник[СтрМас]) Тогда
				Приемник[СтрМас] = Источник[СтрМас];
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Очищает перечисленные свойства объекта.
//
// Параметры:
//	Объект	 - Произвольный		 - объект информационный базы, для которого необходимо очистить значения свойств.
//	Свойства - Строка, Массив	 - имена свойств, перечисленные через запятую или массив с именами.
//
Процедура ОчиститьЗначенияСвойств(Объект,Свойства) Экспорт
	
	Если ТипЗнч(Свойства) = Тип("Строка") Тогда
		МассивСтрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Свойства);
	Иначе
		МассивСтрок = Свойства;
	КонецЕсли;
	
	Для Каждого Свойство Из МассивСтрок Цикл
		Объект[Свойство] = Неопределено;
	КонецЦикла;
	
КонецПроцедуры

// Переводит время из заданных единиц времени в секунды
//
// Параметры:
//  Время - Число - время.
//  ЕдиницаИзмеренияВремени	- ПеречислениеСсылка.ЕдиницыИзмеренияВремени - единица измерения времени.
// 
// Возвращаемое значение:
//   - Число - время в секундах
//
Функция ВремяВСекундах(Время, ЕдиницаИзмеренияВремени) Экспорт
	
	Если Время = 0 Тогда
		
		Возврат 0;
		
	КонецЕсли;
	
	Если ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Сутки") 
		ИЛИ ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.День") Тогда
		
		ВремяВСекундах = Время * 86400; // 60 * 60 * 24
		
	ИначеЕсли ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Минута") Тогда
		
		ВремяВСекундах = Время * 60;
		
	ИначеЕсли ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Час") Тогда
		
		ВремяВСекундах = Время * 3600; //60 * 60;
		
	ИначеЕсли ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Секунда") Тогда
		
		ВремяВСекундах = Время;
		
	Иначе
		
		ВремяВСекундах = 0;
		
	КонецЕсли;

	Возврат ВремяВСекундах;
	
КонецФункции

// Добавляет к дате время.
// 
// Параметры:
// 	Начало - Дата - дата, к которой нужно добавить время
// 	Время - Число - время.
// 	ЕдиницаИзмеренияВремени - ПеречислениеСсылка.ЕдиницыИзмеренияВремени - единица измерения времени.
// 	
// Возвращаемое значение:
// 	Дата - 
Функция ДобавитьКДатеВремя(Начало, Время, ЕдиницаИзмеренияВремени) Экспорт

	Если ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Секунда")
		ИЛИ ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Минута")
		ИЛИ ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Час")
		ИЛИ ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.День")
	 	ИЛИ ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Сутки") Тогда
			
		НоваяДата = Начало + ВремяВСекундах(Время, ЕдиницаИзмеренияВремени);
		
	ИначеЕсли ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Месяц") Тогда
		
		НоваяДата = ДобавитьМесяц(Начало, Время);
		
	ИначеЕсли ЕдиницаИзмеренияВремени = ПредопределенноеЗначение("Перечисление.ЕдиницыИзмеренияВремени.Год") Тогда
		
		НоваяДата = ДобавитьМесяц(Начало, Время*12);

	Иначе
		
		НоваяДата = '00010101';
		
	КонецЕсли;
	
	Возврат НоваяДата;
	
КонецФункции

// Создает объект ОписаниеТипов, содержащий тип Строка.
//
// Параметры:
//  ДлинаСтроки - Число - длина строки.
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Строка.
//
Функция ОписаниеТипаСтрока(ДлинаСтроки) Экспорт
	
	Возврат Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(ДлинаСтроки));
	
КонецФункции

// Создает объект ОписаниеТипов, содержащий тип Число.
//
// Параметры:
//  Разрядность - Число - общее количество разрядов числа (количество разрядов
//                        целой части плюс количество разрядов дробной части).
//  РазрядностьДробнойЧасти - Число - число разрядов дробной части.
//  ЗнакЧисла - ДопустимыйЗнак - допустимый знак числа.
//
// Возвращаемое значение:
//  ОписаниеТипов - описание типа Число.
//
Функция ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти = 0, Знач ЗнакЧисла = Неопределено) Экспорт
	
	Если ЗнакЧисла = Неопределено Тогда 
		ЗнакЧисла = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла));
	
КонецФункции

// Округляет число до ближайшего большего значения.
// 
// Параметры:
//  Число       - Число - Любое вещественное число, которое требуется округлить вверх.
//  Разрядность - Число - Количество цифр, до которого округляется число. Значение по умолчанию 0.
// 
// Возвращаемое значение:
// 	Число
//  
Функция ОкрВверх(Число, Разрядность = 0) Экспорт
	
	Если ТипЗнч(Разрядность) <> Тип("Число") Или Разрядность <> Цел(Разрядность) Тогда
		ВызватьИсключение НСтр("ru = 'Разрядность должна быть целым числом!'");
	КонецЕсли;
	
	Сдвиг = Pow(10, Разрядность);
	
	ЧислоСоСдвигом  = Число * Сдвиг;
	ЦелаяЧастьЧисла = Цел(ЧислоСоСдвигом);
	
	Если ЧислоСоСдвигом - ЦелаяЧастьЧисла > 0  Тогда
		ЦелаяЧастьЧисла = ЦелаяЧастьЧисла + 1;
	КонецЕсли;
	
	Возврат ЦелаяЧастьЧисла / Сдвиг;
	
КонецФункции

// Округляет число до ближайшего меньшего значения.
// 
// Параметры:
//  Число       - Число - Любое вещественное число, которое требуется округлить вниз.
//  Разрядность - Число - Количество цифр, до которого округляется число. Значение по умолчанию 0.
// 
// Возвращаемое значение:
// 	Число
//  
Функция ОкрВниз(Число, Разрядность = 0) Экспорт
	
	Если ТипЗнч(Разрядность) <> Тип("Число") Или Разрядность <> Цел(Разрядность) Тогда
		ВызватьИсключение НСтр("ru = 'Разрядность должна быть целым числом!'");
	КонецЕсли;
	
	Сдвиг = Pow(10, Разрядность);
	
	ЧислоСоСдвигом  = Число * Сдвиг;
	ЦелаяЧастьЧисла = Цел(ЧислоСоСдвигом);
	
	Если ЧислоСоСдвигом - ЦелаяЧастьЧисла < 0  Тогда
		ЦелаяЧастьЧисла = ЦелаяЧастьЧисла - 1;
	КонецЕсли;
	
	Возврат ЦелаяЧастьЧисла / Сдвиг;
	
КонецФункции

#КонецОбласти

#Область МетодыРаботыСРеквизитамиОбъектов

// Проверяет наличие у произвольного объекта реквизита с указанным именем.
//
// Возвращаемое значение:
// 	Булево -
Функция ЕстьРеквизитОбъекта(Объект, ИмяРеквизита) Экспорт
	
	КлючУникальности   = Новый УникальныйИдентификатор;
	СтруктураРеквизита = Новый Структура(ИмяРеквизита, КлючУникальности);

	ЗаполнитьЗначенияСвойств(СтруктураРеквизита, Объект);
	
	Возврат СтруктураРеквизита[ИмяРеквизита] <> КлючУникальности;
	
КонецФункции

// Возвращает таблицу формы, которой подчинен элемент.
// Если элемент не подчинен таблице формы, то возвращает Неопределено.
//
// Параметры:
//	Элемент - ПолеФормы - Элемент формы
//	
// Возвращаемое значение:
// 	ТаблицаФормы, Неопределено - Таблица формы
//
Функция ТаблицаФормыЭлемента(Элемент) Экспорт
	
	Если ТипЗнч(Элемент.Родитель) = Тип("ТаблицаФормы") Тогда
		Возврат Элемент.Родитель;
	ИначеЕсли ТипЗнч(Элемент.Родитель) = Тип("ГруппаФормы")
		И Элемент.Родитель.Вид = ВидГруппыФормы.ГруппаКолонок Тогда
		Возврат ТаблицаФормыЭлемента(Элемент.Родитель)
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Возвращает значение реквизита формы или объекта по пути, заданному в виде строки.
//
// Параметры:
//	Объект - ДокументОбъект, СправочникОбъект, ФормаКлиентскогоПриложения - Объект или форма, из которой необходимо получить данные
//	ПутьКДанным - Строка - Путь к данным, например "Объект.Контрагент"
//	ИдентификаторСтроки - Строка - Уникальный идентификатор строки для случая получения данных из таблицы таблицы.
//	ЗначениеОтсутствия - Произвольный - Если путь к данным пустой или содержит обращение к реквизиту пустого значения, то возвращается данное значение
//	
// Возвращаемое значение:
// 	Произвольный - Значение реквизита
// 
Функция ДанныеПоПути(Объект, Знач ПутьКДанным, Знач ИдентификаторСтроки = Неопределено, ЗначениеОтсутствия = Неопределено) Экспорт
	
	Если ПутьКДанным = "" Тогда
		Возврат ЗначениеОтсутствия;
	ИначеЕсли ТипЗнч(ПутьКДанным) <> Тип("Строка") Тогда
		Возврат ПутьКДанным;
	КонецЕсли;
	
	ЧастиПутиКДанным = СтрРазделить(ПутьКДанным, ".", Ложь);
	Данные = ДанныеПоЧастямПути(Объект, ЧастиПутиКДанным, ИдентификаторСтроки, ЗначениеОтсутствия);
	
	Возврат Данные;
	
КонецФункции

// Возвращает объект и имя свойства для присвоения данных по пути, заданному в виде строки.
//
// Параметры:
//	Объект - ДокументОбъект, СправочникОбъект, ФормаКлиентскогоПриложения - Объект или форма, из которой необходимо получить данные
//	ПутьКДанным - Строка - Путь к данным, например "Объект.Контрагент"
//	ИдентификаторСтроки - Строка - Уникальный идентификатор строки для случая получения данных из таблицы таблицы.
//
// Возвращаемое значение:
// 	Структура - Структура с ключами:
//      * Данные - Произвольный - Объект для присвоения данных
//      * Имя - Строка - Имя свойства для присвоения
//
Функция ДанныеДляПрисвоения(Объект, ПутьКДанным, ИдентификаторСтроки = Неопределено) Экспорт
	
	Если ПутьКДанным = "" ИЛИ ТипЗнч(ПутьКДанным) <> Тип("Строка") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЧастиПутиКДанным = СтрРазделить(ПутьКДанным, ".", Ложь);
	ИмяРеквизита = ЧастиПутиКДанным[ЧастиПутиКДанным.Количество()-1];
	ЧастиПутиКДанным.Удалить(ЧастиПутиКДанным.Количество()-1);
	Данные = ДанныеПоЧастямПути(Объект, ЧастиПутиКДанным, ИдентификаторСтроки);
	
	Возврат Новый Структура("Данные, Имя", Данные, ИмяРеквизита);
	
КонецФункции

#КонецОбласти

#Область ВспомогательныеПроцедурыРаботыСФормами

// Устанавливает значение свойства элемента формы, если находит элемент на форме
//
// Параметры:
//  ЭлементыФормы - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИмяЭлемента   - Строка - имя искомого элемента.
//  ИмяСвойства   - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение      - Произвольный - значение, которое будет установлено
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомого элемента.
//
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Элемент = ЭлементыФормы.Найти(ИмяЭлемента);
	Если Элемент = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если НРег(ИмяСвойства) = НРег("ТолькоПросмотр")
	И ТипЗнч(Элемент) = Тип("КнопкаФормы") Тогда
		ИмяСвойстваЭлемента = "Доступность";
		ЗначениеСвойства    = НЕ Значение;
	Иначе
		ИмяСвойстваЭлемента = ИмяСвойства;
		ЗначениеСвойства    = Значение;
	КонецЕсли;
	
	Если НРег(ИмяСвойства) = НРег("РасширеннаяПодсказка") Тогда
		Элемент.РасширеннаяПодсказка.Заголовок = Значение;
	Иначе
		Если Элемент[ИмяСвойстваЭлемента] <> ЗначениеСвойства Тогда
			Элемент[ИмяСвойстваЭлемента] = ЗначениеСвойства;
		КонецЕсли;
	КонецЕсли;
	
	ТипыЭлементовФормыСПодчиненнымиЭлементами = Новый ОписаниеТипов("ФормаКлиентскогоПриложения, ГруппаФормы, ТаблицаФормы");
	
	Если УстанавливатьДляПодчиненных И ТипыЭлементовФормыСПодчиненнымиЭлементами.СодержитТип(ТипЗнч(Элемент)) Тогда
		ПодчиненныеЭлементы = Элемент.ПодчиненныеЭлементы; // Массив из ПолеФормы - 
		Для Каждого ПодчиненныйЭлемент Из ПодчиненныеЭлементы Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ПодчиненныйЭлемент.Имя, ИмяСвойства, Значение, Истина);
		КонецЦикла;
 	КонецЕсли;
 	
КонецПроцедуры // УстановитьСвойствоЭлементаФорма()

// Устанавливает значение свойства элементов формы, если находит элемент на форме
//
// Параметры:
//  ЭлементыФормы  - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИменаЭлементов - Массив, Строка, Структура - имена искомых элементов.
//  ИмяСвойства    - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение       - Произвольный - значение, которое будет установлено
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомых элементов.
//
Процедура УстановитьСвойствоЭлементовФормы(ЭлементыФормы, ИменаЭлементов, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Если ТипЗнч(ИменаЭлементов) = Тип("Массив") Тогда
		
		Для Каждого ИмяЭлемента Из ИменаЭлементов Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных);
		КонецЦикла
		
	Иначе
		
		Если ТипЗнч(ИменаЭлементов) = Тип("Строка") Тогда
			СтруктураИменЭлементов = Новый Структура(ИменаЭлементов);
		Иначе
			СтруктураИменЭлементов = ИменаЭлементов;
		КонецЕсли;
		
		Для Каждого ИмяЭлемента Из СтруктураИменЭлементов Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента.Ключ, ИмяСвойства, Значение, УстанавливатьДляПодчиненных);
		КонецЦикла
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьСвойствоЭлементовФормы()

// Процедура заполняет массив непроверяемых реквизитов значениями, не используемыми при выбранной хозяйственной операции
// документа.
//
// Параметры:
//	МассивВсехРеквизитов - Массив - Массив всех реквизитов документа
//	МассивРеквизитовОперации - Массив - Массив реквизитов документа, которые относятся к хозяйственной операции документа
//	МассивНепроверяемыхРеквизитов - Массив - Массив реквизитов объекта, не требующих проверки.
//
Процедура ЗаполнитьМассивНепроверяемыхРеквизитов(МассивВсехРеквизитов, МассивРеквизитовОперации, МассивНепроверяемыхРеквизитов) Экспорт
	
	Для Каждого ЭлементМассива Из МассивВсехРеквизитов Цикл
		
		// Если реквизит не используется для хозяйственной операции, исключаем данный реквизит из проверки.
		Если МассивРеквизитовОперации.Найти(ЭлементМассива) = Неопределено Тогда
			МассивНепроверяемыхРеквизитов.Добавить(ЭлементМассива);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьМассивНепроверяемыхРеквизитов()

// Возвращает представление документа с учетом заданных в ИБ параметров префиксации
//
// Параметры:
// 		Наименование - Строка - Строковое представление наименования типа документа
// 		Номер - Строка - Номер документа
// 		Дата - Дата - Дата документа.
//
// Возвращаемое значение:
// 		Строка - Представление документа с переопределенным наименованием, исключенными нулями из номера и локализованной датой.
//
Функция ПредставлениеДокумента(Наименование, Номер, Дата) Экспорт
	
	Возврат СтрШаблон(
		НСтр("ru='%1 № %2 от %3'"),
		Наименование,
		ПрефиксацияОбъектовКлиентСервер.НомерНаПечать(Номер, Ложь, Истина),
		Формат(Дата, "ДЛФ=D"));
	
КонецФункции

// Устанавливается свойство ОтображениеПредупрежденияПриРедактировании элемента формы.
//
Процедура ОтображениеПредупрежденияПриРедактировании(Элемент, Отображать) Экспорт
	
	Если Отображать Тогда
		Элемент.ОтображениеПредупрежденияПриРедактировании = ОтображениеПредупрежденияПриРедактировании.Отображать;
	Иначе
		Элемент.ОтображениеПредупрежденияПриРедактировании = ОтображениеПредупрежденияПриРедактировании.НеОтображать;
	КонецЕсли;
	
КонецПроцедуры

// Возвращает параметры механизма, сохраненные в реквизите формы КэшДанныхМеханизмов.
// 
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - Форма
// 	ИмяМеханизма - Строка - Имя механизма, кэширующего данные
//
// Возвращаемое значение:
// 	Произвольный - 
Функция ПолучитьДанныеМеханизмаИзКэшаФормы(Форма, ИмяМеханизма) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма, "КэшДанныхМеханизмов") 
		И Форма.КэшДанныхМеханизмов.Свойство(ИмяМеханизма) Тогда
		Возврат Форма.КэшДанныхМеханизмов[ИмяМеханизма];
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Обновляет форматированную строку работы с документами на основании в форме документа
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - в форме должены быть реквизиты:
// 		* ТекстДокументыНаОсновании - ФорматированнаяСтрока - реквизит должен быть размещен в элеменете с именем ТекстДокументыНаОсновании 
// 		* ТекстыПоляДокументыНаОсновании - СписокЗначений Из ФорматированнаяСтрока - сформированные механизмами конфигурации форматированные строки документов, вводимых на основании 
// 
Процедура ОбновитьТекстДокументыНаОсновании(Форма) Экспорт
	
	Отступ =  Новый ФорматированнаяСтрока("  ");
	ТекстыДокументыНаОсновании  = Новый Массив;
	
	Счетчик = 1;
	
	Для Каждого СтрМас Из Форма.ТекстыПоляДокументыНаОсновании Цикл
		
		Если Не ПустаяСтрока(Строка(СтрМас.Значение)) Тогда
			Если Счетчик > 1 Тогда
				ТекстыДокументыНаОсновании.Добавить(Отступ);
			КонецЕсли;				
			ТекстыДокументыНаОсновании.Добавить(СтрМас.Значение);
			Счетчик = Счетчик + 1;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ТекстыДокументыНаОсновании.Количество() > 0 Тогда
		Форма.Элементы.ТекстДокументыНаОсновании.Видимость = Истина;
		Форма.ТекстДокументыНаОсновании = Новый ФорматированнаяСтрока(ТекстыДокументыНаОсновании);
	Иначе
		Форма.Элементы.ТекстДокументыНаОсновании.Видимость = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Процедура устанавливает видимость элементов формы по массиву имен.
//
// Параметры:
//	Элементы - ВсеЭлементыФормы - Коллекция элементов формы
//	МассивВсехРеквизитов - Массив - Массив имен реквизитов, для которых устанавливается видимость
//	МассивВидимыхРеквизитов - Массив - Массив имен реквизитов, которые должны быть видны на форме.
//
Процедура УстановитьВидимостьЭлементовПоМассиву(Элементы, Знач МассивВсехРеквизитов, Знач МассивВидимыхРеквизитов) Экспорт
	
	Если ТипЗнч(МассивВидимыхРеквизитов) <> Тип("Массив") Тогда
		МассивВидимыхРеквизитов = Новый Массив;
	КонецЕсли;
	
	Для Каждого ЭлементМассива Из МассивВсехРеквизитов Цикл
		
		ИмяРеквизита = СтрЗаменить(ЭлементМассива, ".", "");
		
		// Если реквизита нет в массиве видимых реквизитов, снимаем видимость элемента формы.
		ВидимостьРеквизита = (МассивВидимыхРеквизитов.Найти(ЭлементМассива) <> Неопределено);
		Если Элементы.Найти(ИмяРеквизита) <> Неопределено
		 И Элементы[ИмяРеквизита].Видимость <> ВидимостьРеквизита Тогда
			Элементы[ИмяРеквизита].Видимость = ВидимостьРеквизита;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует параметры для подбора элементов на основании параметров указанных для элемента формы.
// Используется для подбора в формах выбора с такими же параметрами выбора, как и при выборе.
//
// Параметры:
//  ЭлементФормы - ПолеФормы - Элемент формы в котором указаны параметры подбора.
//  Форма - ФормаКлиентскогоПриложения - Форма на которой расположен элемент. Используется для получения параметров.
// 
// Возвращаемое значение:
//  Структура - параметры подбора:
//  	* ЗакрыватьПриВыборе - Булево -
//  	* МножественныйВыбор - Булево -
//
Функция ПараметрыПодбора(ЭлементФормы, Форма) Экспорт

	ПараметрыПодбора = Новый Структура;
	ПараметрыПодбора.Вставить("ЗакрыватьПриВыборе", Ложь);
	ПараметрыПодбора.Вставить("МножественныйВыбор", Истина);
	
	ДополнитьПараметрыПодбораПараметрамиВыбора(
		ЭлементФормы.ПараметрыВыбора, ПараметрыПодбора);
		
	СвязиПараметровВыбора = Новый Структура;
	ДополнитьПараметрыПодбораСвязьюПараметровВыбора(
		ЭлементФормы.СвязиПараметровВыбора, Форма, СвязиПараметровВыбора);
	
	Для Каждого ПараметрВыбора Из СвязиПараметровВыбора Цикл
		Если ПараметрВыбора.Ключ = "Отбор" И ПараметрыПодбора.Свойство(ПараметрВыбора.Ключ) Тогда
			Для Каждого ЭлементОтбора Из ПараметрВыбора.Значение Цикл
				ПараметрыПодбора.Отбор.Вставить(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
			КонецЦикла;
		Иначе
			ПараметрыПодбора.Вставить(ПараметрВыбора.Ключ, ПараметрВыбора.Значение);
		КонецЕсли;
	КонецЦикла;
		
	Возврат ПараметрыПодбора;

КонецФункции

// Формирует параметры для выбора элемента на основании параметров указанных для элемента формы.
//
// Параметры:
//  ЭлементФормы - ПолеФормы - Элемент формы в котором указаны параметры подбора.
//  Форма - ФормаКлиентскогоПриложения - Форма на которой расположен элемент. Используется для получения параметров.
// 
// Возвращаемое значение:
//  Структура - параметры подбора:
//  	* ЗакрыватьПриВыборе - Булево -
//  	* МножественныйВыбор - Булево -
//
Функция ПараметрыВыбора(ЭлементФормы, Форма) Экспорт

	ПараметрыВыбора = Новый Структура;
	ПараметрыВыбора.Вставить("ЗакрыватьПриВыборе", Истина);
	ПараметрыВыбора.Вставить("МножественныйВыбор", Ложь);
	
	ДополнитьПараметрыПодбораПараметрамиВыбора(
		ЭлементФормы.ПараметрыВыбора, ПараметрыВыбора);
		
	СвязиПараметровВыбора = Новый Структура;
	ДополнитьПараметрыПодбораСвязьюПараметровВыбора(
		ЭлементФормы.СвязиПараметровВыбора, Форма, СвязиПараметровВыбора);
	
	Для Каждого ПараметрВыбора Из СвязиПараметровВыбора Цикл
		Если ПараметрВыбора.Ключ = "Отбор" И ПараметрыВыбора.Свойство(ПараметрВыбора.Ключ) Тогда
			Для Каждого ЭлементОтбора Из ПараметрВыбора.Значение Цикл
				ПараметрыВыбора.Отбор.Вставить(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
			КонецЦикла;
		Иначе
			ПараметрыВыбора.Вставить(ПараметрВыбора.Ключ, ПараметрВыбора.Значение);
		КонецЕсли;
	КонецЦикла;
		
	Возврат ПараметрыВыбора;

КонецФункции

// Дополняет параметры подбора.
// 
// Параметры:
//  ПараметрыВыбора - ФиксированныйМассив из ПараметрВыбора - Параметры выбора.
//  ПараметрыПодбора - Структура - Параметры подбора, которые нужно дополнить.
Процедура ДополнитьПараметрыПодбораПараметрамиВыбора(ПараметрыВыбора, ПараметрыПодбора) Экспорт

	ВложенныеПараметры = Новый Соответствие;
	
	Для каждого ЭлементКоллекции Из ПараметрыВыбора Цикл
		ИмяПараметра = СтрРазделить(ЭлементКоллекции.Имя, ".");
		Если ИмяПараметра.Количество() > 1 Тогда
			ВложенныйПараметр = ВложенныеПараметры.Получить(ИмяПараметра[0]);
			Если ВложенныйПараметр = Неопределено Тогда
				ВложенныйПараметр = Новый Структура;
			КонецЕсли; 
			ВложенныйПараметр.Вставить(ИмяПараметра[1], ЭлементКоллекции.Значение);
			ВложенныеПараметры.Вставить(ИмяПараметра[0], ВложенныйПараметр);
		Иначе
			ПараметрыПодбора.Вставить(ИмяПараметра[0], ЭлементКоллекции.Значение);
		КонецЕсли; 
	КонецЦикла; 
	
	Для каждого ВложенныйПараметр Из ВложенныеПараметры Цикл
		ПараметрыПодбора.Вставить(ВложенныйПараметр.Ключ, ВложенныйПараметр.Значение);
	КонецЦикла; 
	
КонецПроцедуры

// Дополняет параметры подбора.
// 
// Параметры:
//  СвязиПараметровВыбора - ФиксированныйМассив из СвязьПараметраВыбора - Связи параметров выбора.
//  Форма - ФормаКлиентскогоПриложения - Форма.
//  ПараметрыПодбора - Структура - Параметры подбора, которые нужно дополнить.
//
Процедура ДополнитьПараметрыПодбораСвязьюПараметровВыбора(СвязиПараметровВыбора, Форма, ПараметрыПодбора) Экспорт

	ВложенныеПараметры = Новый Соответствие;
	
	Для каждого ЭлементКоллекции Из СвязиПараметровВыбора Цикл
		ЗначениеПараметра = ЗначениеПараметраСвязи(ЭлементКоллекции, Форма);
		ИмяПараметра = СтрРазделить(ЭлементКоллекции.Имя, ".");
		Если ИмяПараметра.Количество() > 1 Тогда
			ВложенныйПараметр = ВложенныеПараметры.Получить(ИмяПараметра[0]);
			Если ВложенныйПараметр = Неопределено Тогда
				ВложенныйПараметр = Новый Структура;
			КонецЕсли; 
			ВложенныйПараметр.Вставить(ИмяПараметра[1], ЗначениеПараметра);
			ВложенныеПараметры.Вставить(ИмяПараметра[0], ВложенныйПараметр);
		Иначе
			ПараметрыПодбора.Вставить(ИмяПараметра[0], ЗначениеПараметра);
		КонецЕсли; 
	КонецЦикла; 
	
	Для каждого ВложенныйПараметр Из ВложенныеПараметры Цикл
		ПараметрыПодбора.Вставить(ВложенныйПараметр.Ключ, ВложенныйПараметр.Значение);
	КонецЦикла; 
	
КонецПроцедуры

// Вычисляет значение параметра связи.
// 
// Параметры:
//  СвязьПараметраВыбора - СвязьПараметраВыбора - Связь параметра выбора.
//  Форма - ФормаКлиентскогоПриложения - Форма.
// 
// Возвращаемое значение:
//  Произвольный -
Функция ЗначениеПараметраСвязи(СвязьПараметраВыбора, Форма) Экспорт
	
	ЗначениеПараметра = СтрРазделить(СвязьПараметраВыбора.ПутьКДанным, ".");
	Если ЗначениеПараметра.Количество() = 1 Тогда
		ЗначениеПараметра = Форма[ЗначениеПараметра[0]];
	ИначеЕсли ЗначениеПараметра.Количество() = 2 Тогда
		ЗначениеПараметра = Форма[ЗначениеПараметра[0]][ЗначениеПараметра[1]];
	ИначеЕсли ЗначениеПараметра.Количество() = 3 Тогда
		ЗначениеПараметра = Форма[ЗначениеПараметра[0]][ЗначениеПараметра[1]][ЗначениеПараметра[2]];
	ИначеЕсли ЗначениеПараметра.Количество() = 4 Тогда
		ЗначениеПараметра = Форма[ЗначениеПараметра[0]][ЗначениеПараметра[1]][ЗначениеПараметра[2]][ЗначениеПараметра[3]];
	ИначеЕсли ЗначениеПараметра.Количество() = 5 Тогда
		ЗначениеПараметра = Форма[ЗначениеПараметра[0]][ЗначениеПараметра[1]][ЗначениеПараметра[2]][ЗначениеПараметра[3]][ЗначениеПараметра[4]];
	Иначе
		ЗначениеПараметра = Неопределено;
	КонецЕсли;
	
	Возврат ЗначениеПараметра;
	
КонецФункции

#КонецОбласти

#Область ФункцииДляПоддержкиФормированияПечатныхФорм

// Возвращает заголовок документа в том виде, в котором его формирует платформа для представления ссылки на документ.
//
// Параметры:
//  Шапка - Структура -  Ключи структуры:
//          * Номер - Строка, Число - номер документа
//          * Дата  - дата - дата документа
//          * НомерИсправляемогоДокумента - Строка, Число - номер исправляемого документа
//          * ДатаИсправляемогоДокумента - Дата - дата исправляемого документа 
//  НазваниеДокумента - Строка - название документа (например, синоним объекта метаданных).
//  УдалитьТолькоЛидирующиеНулиИзНомераОбъекта - Булево - Флаг удаления лидирующих нулей
//  
// Возвращаемое значение:
//  Строка - заголовок документа
//
Функция СформироватьЗаголовокДокумента(Шапка, знач НазваниеДокумента = "", УдалитьТолькоЛидирующиеНулиИзНомераОбъекта = Ложь) Экспорт
	
	ДанныеДокумента = Новый Структура("Номер, Дата, Представление, НомерИсправляемогоДокумента, ДатаИсправляемогоДокумента");
	ЗаполнитьЗначенияСвойств(ДанныеДокумента, Шапка);
	ИсправительныйДокумент = ЗначениеЗаполнено(ДанныеДокумента.НомерИсправляемогоДокумента) 
								И ЗначениеЗаполнено(ДанныеДокумента.ДатаИсправляемогоДокумента);
	
	// Если название документа не передано, получим название по представлению документа
	Если ПустаяСтрока(НазваниеДокумента) И ЗначениеЗаполнено(ДанныеДокумента.Представление) Тогда
		НазваниеДокумента = ПредставлениеОбъектаИзПредставленияСсылки(ДанныеДокумента);
	КонецЕсли;

	Если УдалитьТолькоЛидирующиеНулиИзНомераОбъекта Тогда
		НомерНаПечать = ПрефиксацияОбъектовКлиентСервер.УдалитьЛидирующиеНулиИзНомераОбъекта(ДанныеДокумента.Номер);
		Если ИсправительныйДокумент Тогда
			НомерИсправляемогоДокументаНаПечать = ПрефиксацияОбъектовКлиентСервер.УдалитьЛидирующиеНулиИзНомераОбъекта(
				ДанныеДокумента.НомерИсправляемогоДокумента);
		КонецЕсли;
	Иначе 
		// Кроме лидирующих нулей будут удалены также префикс организации и префикс информационной базы.
		НомерНаПечать = ПрефиксацияОбъектовКлиентСервер.НомерНаПечать(ДанныеДокумента.Номер);
		Если ИсправительныйДокумент Тогда
			НомерИсправляемогоДокументаНаПечать = ПрефиксацияОбъектовКлиентСервер.НомерНаПечать(
				ДанныеДокумента.НомерИсправляемогоДокумента);
		КонецЕсли;
	КонецЕсли;
	
	Если ИсправительныйДокумент Тогда
		ЗаголовокДокумента = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 № %2 от %3 (исправление № %4 от %5)'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			НазваниеДокумента,
			НомерИсправляемогоДокументаНаПечать,
			Формат(ДанныеДокумента.ДатаИсправляемогоДокумента, "ДЛФ=DD"),
			НомерНаПечать,
			Формат(ДанныеДокумента.Дата, "ДЛФ=DD"));
	Иначе
		ЗаголовокДокумента = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1 № %2 от %3'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			НазваниеДокумента, НомерНаПечать, Формат(ДанныеДокумента.Дата, "ДЛФ=DD"));
	КонецЕсли;
	
	Возврат ЗаголовокДокумента;
	
КонецФункции

// Функция - Пример: представление объекта "Заказ клиента 00001 от 22.01.2014 0:00:00", функция вернет "Заказ клиента".
//
// Параметры:
//  ДанныеДокумента - Структура 
//		* Представление - Строка - представление ссылки
//		* Номер - Строка - номер документа
// Возвращаемое значение:
//   Строка - представление объекта.
//
Функция ПредставлениеОбъектаИзПредставленияСсылки(Знач ДанныеДокумента) Экспорт 
	
	ПоложениеНомера = СтрНайти(ДанныеДокумента.Представление, ДанныеДокумента.Номер);
	
	Если ПоложениеНомера > 0 Тогда
        НазваниеДокумента = СокрЛП(Лев(ДанныеДокумента.Представление, ПоложениеНомера - 1));
	Иначе
		НазваниеДокумента = "";
	КонецЕсли;
	
	Возврат НазваниеДокумента;

КонецФункции

// Добавляет новый параметр в параметры выбора переданного элемента формы с сохранением ранее добавленных.
//
// Параметры:
//  Элемент - ПолеФормы - элемент формы, имеющий свойство "ПараметрыВыбора"
//  ИмяПараметра - Строка - имя параметра, как оно задается в свойстве "ПараВыбора - Имя" без указания слова "Отбор."
//  ЗначениеПараметра - Произвольный - значения параметра выбора. Для единичного отбора передается само значения, для
//                                     множественного - массив значений.
//
Процедура ДобавитьПараметрВыбора(Элемент, ИмяПараметра, ЗначениеПараметра) Экспорт
	Если ТипЗнч(ЗначениеПараметра) = Тип("Массив") Тогда
		ЗначениеПараметраВыбора = Новый ФиксированныйМассив(ЗначениеПараметра);
	ИначеЕсли ТипЗнч(ЗначениеПараметра) = Тип("ФиксированныйМассив") Тогда
		ЗначениеПараметраВыбора = ЗначениеПараметра;
	Иначе
		ЗначениеПараметраВыбора = ЗначениеПараметра;
	КонецЕсли;
	
	Если СтрНайти(ИмяПараметра, "Отбор.") Тогда
		ИмяПараметраВыбора = ИмяПараметра;
	Иначе
		ИмяПараметраВыбора = "Отбор." + ИмяПараметра;
	КонецЕсли;
	
	Если ТипЗнч(Элемент) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		ПараметрыВыбора = Элемент.ПараметрыРедактирования.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных("ПараметрыВыбора"));
		ПараметрыВыбора.Использование = Истина;
		
		ЗначениеПараметра = ПараметрыВыбора.Значение; // Массив -
		ДобавляемыйПараметрВыбора = ЗначениеПараметра.Добавить();
		ДобавляемыйПараметрВыбора.Имя = ИмяПараметраВыбора;
		ДобавляемыйПараметрВыбора.Значение = ЗначениеПараметраВыбора;
	Иначе 
		ИсходныеПараметрыВыбора = Элемент.ПараметрыВыбора;
		
		ДобавляемыйПараметрВыбора = Новый ПараметрВыбора(ИмяПараметраВыбора, ЗначениеПараметраВыбора);
		
		МассивПараметровВыбора = Новый Массив(ИсходныеПараметрыВыбора);
		МассивПараметровВыбора.Добавить(ДобавляемыйПараметрВыбора);
		НовыеПараметрыВыбора = Новый ФиксированныйМассив(МассивПараметровВыбора);
		
		Элемент.ПараметрыВыбора = НовыеПараметрыВыбора;
	КонецЕсли;
КонецПроцедуры

// Событие возникает при получении представления входящего документа.
// 
// Параметры:
//  Данные - Структура - содержит реквизиты документа, которые используются для формирования представления:
//  	* Номер - Строка - номер документа в информационной базе
//  	* Дата - Дата - дата документа в информационной базе
//  	* НаименованиеВходящегоДокумента - Строка - наименование документа контрагента
//  	* НомерВходящегоДокумента - Строка - номер документа контрагента
//  	* ДатаВходящегоДокумента - Дата - дата документа контрагента
//  Представление - Строка - новое представление документа, если СтандартнаяОбработка = Ложь
//  СтандартнаяОбработка - Булево - если вернулась Ложь, то изменено представление документа.
//  ИмяИлиИдентификаторДокумента - Строка -
//  			- СправочникСсылка.ИдентификаторыОбъектовМетаданных -
//  			- СправочникСсылка.ИдентификаторыОбъектовРасширений - Имя или идентификатор документа в метаданных.
//
Процедура ОбработкаПолученияПредставленияВходящегоДокумента(Данные, Представление, СтандартнаяОбработка, ИмяИлиИдентификаторДокумента) Экспорт
	
	НаименованиеВходящегоДокумента = ?(ЗначениеЗаполнено(Данные.НаименованиеВходящегоДокумента),
								Данные.НаименованиеВходящегоДокумента, "---");
	НомерВходящегоДокумента = ?(ЗначениеЗаполнено(Данные.НомерВходящегоДокумента),
								Данные.НомерВходящегоДокумента, "---");
	ДатаВходящегоДокумента = ?(ЗначениеЗаполнено(Данные.ДатаВходящегоДокумента),
								Формат(Данные.ДатаВходящегоДокумента, "ДЛФ=D;"), "---");
	#Если Клиент Тогда
		СпособПредставленияДокумента = ОбщегоНазначенияУТКлиентПовтИсп.ЗначениеКонстанты(
										"ПредставлениеВходящихДокументов");
	#Иначе
		СпособПредставленияДокумента = ОбщегоНазначенияУТПовтИсп.ЗначениеКонстанты(
										"ПредставлениеВходящихДокументов");
	#КонецЕсли
	Если СпособПредставленияДокумента = ПредопределенноеЗначение("Перечисление.СпособыПредставленияВходящихДокументов.Полное") Тогда
		СтандартнаяОбработка = Ложь;
		Шаблон = НСтр("ru = '%1 %2 от %3'");
		СтандартноеПредставление = СтандартноеПредставлениеДокумента(
									ИмяИлиИдентификаторДокумента, Данные.Номер, Данные.Дата, Представление);
		ВходящееПредставление = СтрШаблон(
							Шаблон, НаименованиеВходящегоДокумента, НомерВходящегоДокумента, ДатаВходящегоДокумента);
		Шаблон = НСтр("ru = '%1 (вх. %2)'");
		Представление = СтрШаблон(Шаблон, СтандартноеПредставление, ВходящееПредставление);
	ИначеЕсли СпособПредставленияДокумента = ПредопределенноеЗначение("Перечисление.СпособыПредставленияВходящихДокументов.Внешнее") Тогда
		СтандартнаяОбработка = Ложь;
		Если ЗначениеЗаполнено(Данные.НаименованиеВходящегоДокумента)
			И ЗначениеЗаполнено(Данные.НомерВходящегоДокумента)
			И ЗначениеЗаполнено(Данные.ДатаВходящегоДокумента) Тогда
			Шаблон = НСтр("ru = 'вх. %1 %2 от %3'");
			Представление = СтрШаблон(
							Шаблон, НаименованиеВходящегоДокумента, НомерВходящегоДокумента, ДатаВходящегоДокумента);
		ИначеЕсли ЗначениеЗаполнено(Данные.НаименованиеВходящегоДокумента) Тогда
			Шаблон = НСтр("ru = 'вх. %1 %2 от %3, вн. %4 от %5'");
			Представление = СтрШаблон(Шаблон, НаименованиеВходящегоДокумента, НомерВходящегоДокумента,
							ДатаВходящегоДокумента, Данные.Номер, Данные.Дата);
		Иначе
			СтандартноеПредставление = СтандартноеПредставлениеДокумента(
										ИмяИлиИдентификаторДокумента, Данные.Номер, Данные.Дата, Представление);
			Шаблон = НСтр("ru = 'вх. %1 %2 от %3, вн. %4'");
			Представление = СтрШаблон(Шаблон, НаименованиеВходящегоДокумента, НомерВходящегоДокумента,
							ДатаВходящегоДокумента, СтандартноеПредставление);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Формирует стандартное представление документа на текущем языке пользователя.
//
// Параметры:
//  ИмяИлиИдентификаторДокумента - Строка
//                               - СправочникСсылка.ИдентификаторыОбъектовМетаданных
//                               - СправочникСсылка.ИдентификаторыОбъектовРасширений 
//  Номер - Строка - Номер документа.
//  Дата - Дата - Дата документа
//  Представление - Строка - (необязательный) Сформированное представление ранее, если не заполнено, то формируется представление
// Возвращаемое значение:
//   Строка - представление документа на текущем языке пользователя.
//
Функция СтандартноеПредставлениеДокумента(ИмяИлиИдентификаторДокумента, Номер, Дата, Представление = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(Представление) Тогда
		Возврат Представление;
	Иначе
		Шаблон = НСтр("ru = '%1 %2 от %3'");
		Возврат СтрШаблон(Шаблон, СинонимДокумента(ИмяИлиИдентификаторДокумента), Номер, Дата);
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область ВыборПериодаИзСписка

// Возвращает начало периода по его виду.
// Параметры:
// 	ВидПериода - ПеречислениеСсылка.ДоступныеПериодыОтчета -
// 	ДатаПериода - Дата - 
// Возвращаемое значение:
// 	Дата - 
Функция НачалоПериодаОтчета(ВидПериода, ДатаПериода) Экспорт
	
	НачалоПериода = ДатаПериода;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		НачалоПериода = НачалоГода(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		Если Месяц(ДатаПериода) > 6 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), 7, 1);
		Иначе
			НачалоПериода = Дата(Год(ДатаПериода), 1, 1);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		НачалоПериода = НачалоКвартала(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		НачалоПериода = НачалоМесяца(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		Если День(ДатаПериода) <= 10 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 1);
		ИначеЕсли День(ДатаПериода) > 10 И День(ДатаПериода) <= 20 Тогда
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 11);
		Иначе
			НачалоПериода = Дата(Год(ДатаПериода), Месяц(ДатаПериода), 21);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		НачалоПериода = НачалоНедели(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		НачалоПериода = НачалоДня(ДатаПериода);
		
	КонецЕсли;
		
	Возврат НачалоПериода;
	
КонецФункции
 
// Возвращает конец периода по его виду.
//
// Параметры:
// 	ВидПериода - ПеречислениеСсылка.ДоступныеПериодыОтчета -
// 	ДатаПериода - Дата - 
// Возвращаемое значение:
// 	Дата - 
Функция КонецПериодаОтчета(ВидПериода, ДатаПериода) Экспорт
	
	КонецПериода = ДатаПериода;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		КонецПериода = КонецГода(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		Если Месяц(ДатаПериода) > 6 Тогда
			КонецПериода = КонецГода(ДатаПериода);
		Иначе
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), 6, 30));
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		КонецПериода = КонецКвартала(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		КонецПериода = КонецМесяца(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		Если День(ДатаПериода) <= 10 Тогда
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), Месяц(ДатаПериода), 10));
		ИначеЕсли День(ДатаПериода) > 10 И День(ДатаПериода) <= 20 Тогда
			КонецПериода = КонецДня(Дата(Год(ДатаПериода), Месяц(ДатаПериода), 20));
		Иначе
			КонецПериода = КонецМесяца(ДатаПериода);
		КонецЕсли;
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		КонецПериода = КонецНедели(ДатаПериода);
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		КонецПериода = КонецДня(ДатаПериода);
		
	КонецЕсли;
		
	Возврат КонецПериода;
	
КонецФункции

// Возвращает список доступных значений периода по его виду.
//
// Параметры:
// 	НачалоПериода - Дата -
// 	ВидПериода - ПеречислениеСсылка.ДоступныеПериодыОтчета
// Возвращаемое значение:
// 	СписокЗначений - СписокЗначений -
Функция ДоступныеЗначенияПериодаПоВидуПериода(Знач НачалоПериода, Знач ВидПериода) Экспорт
	
	СписокПериодов = Новый СписокЗначений;
	Если НачалоПериода = '00010101' Тогда
		Возврат Новый СписокЗначений;
	Иначе
		ЗначениеНачалоПериода = НачалоПериода;
	КонецЕсли;
	
	Если ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Год") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 7, 1, 1), НСтр("ru = 'Предыдущие годы'"));
		Для Сч = ТекущийГод - 3 По ТекущийГод + 3 Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 7, 1, 1), НСтр("ru = 'Последующие годы'"));
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Полугодие") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 2, 1, 1), Формат(ТекущийГод - 2, "ЧГ=0") + "...");
		Для Сч = ТекущийГод - 1 По ТекущийГод + 1 Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), НСтр("ru = 'I полугодие'")  + " " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 7, 1), НСтр("ru = 'II полугодие'") + " " + Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 2, 1, 1), Формат(ТекущийГод + 2, "ЧГ=0") + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Квартал") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 2, 1, 1), Формат(ТекущийГод - 2, "ЧГ=0") + "...");
		Для Сч = ТекущийГод - 1 По ТекущийГод Цикл
			СписокПериодов.Добавить(Дата(Сч, 1, 1), НСтр("ru = 'I квартал'")   + " " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 4, 1), НСтр("ru = 'II квартал'")  + " " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 7, 1), НСтр("ru = 'III квартал'") + " " + Формат(Сч, "ЧГ=0"));
			СписокПериодов.Добавить(Дата(Сч, 10, 1),НСтр("ru = 'IV квартал'")  + " " + Формат(Сч, "ЧГ=0"));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 1, 1, 1), Формат(ТекущийГод + 1, "ЧГ=0") + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Месяц") Тогда
		ТекущийГод = Год(ЗначениеНачалоПериода);
		СписокПериодов.Добавить(Дата(ТекущийГод - 1, 1, 1), Формат(ТекущийГод - 1, "ЧГ=0") + "...");
		Для Сч = 1 По 12 Цикл
			СписокПериодов.Добавить(Дата(ТекущийГод, Сч, 1), Формат(Дата(ТекущийГод, Сч, 1), НСтр("ru='ДФ=''MMMM yyyy'''")));
		КонецЦикла;
		СписокПериодов.Добавить(Дата(ТекущийГод + 1, 1, 1), Формат(ТекущийГод + 1, "ЧГ=0") + "...");

	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Декада") Тогда
		ТекущийГод   = Год(ЗначениеНачалоПериода);
		ТекущийМесяц = Месяц(ЗначениеНачалоПериода);
		
		СчМесяц = ?(ТекущийМесяц - 4 < 1, 12 + ТекущийМесяц - 4, ТекущийМесяц - 4);
		СчГод   = ?(ТекущийМесяц - 4 < 1, ТекущийГод - 1       , ТекущийГод);
		Сч = 6;
		
		Период = Дата(?(СчМесяц <> 1, СчГод, СчГод - 1), ?(СчМесяц > 1, СчМесяц - 1, 12), 1);
		СписокПериодов.Добавить(Период, Формат(Период, НСтр("ru='ДФ=''MMMM yyyy'''")) + "...");
		Пока Сч >0 Цикл
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 1),  НСтр("ru = 'I дек.'")   + " " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), НСтр("ru='ДФ=''MMMM yyyy'''"))));
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 11), НСтр("ru = 'II дек.'")  + " " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), НСтр("ru='ДФ=''MMMM yyyy'''"))));
			СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 21), НСтр("ru = 'III дек.'") + " " + Нрег(Формат(Дата(СчГод, СчМесяц, 1), НСтр("ru='ДФ=''MMMM yyyy'''"))));
			СчМесяц = СчМесяц + 1;
			Если СчМесяц > 12 Тогда
				СчГод = СчГод + 1;
				СчМесяц = 1;
			КонецЕсли;
			Сч = Сч - 1;
		КонецЦикла;
		СписокПериодов.Добавить(Дата(СчГод, СчМесяц, 1), Формат(Дата(СчГод, СчМесяц, 1), НСтр("ru='ДФ=''MMMM yyyy'''")) + "...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.Неделя") Тогда
		НачалоНедели = НачалоНедели(ЗначениеНачалоПериода) - 21 * 86400;
		
		СписокПериодов.Добавить(НачалоНедели - 7 * 86400, НСтр("ru = 'Пред. недели'") + " ...");
		Для Сч = 0 По 6 Цикл
			НачНедели = НачалоНедели + 7 * Сч * 86400;  
			КонНедели = КонецНедели(НачНедели);
			СписокПериодов.Добавить(НачНедели, Формат(НачНедели, НСтр("ru='ДФ=''dd.MM'''")) + " - " + Формат(КонНедели, НСтр("ru='ДФ=''dd.MM'''")));
		КонецЦикла;
		СписокПериодов.Добавить(НачалоНедели + 7 * 86400, НСтр("ru = 'След. недели'") + " ...");
		
	ИначеЕсли ВидПериода = ПредопределенноеЗначение("Перечисление.ДоступныеПериодыОтчета.День") Тогда
		КонецНедели   = КонецНедели(ЗначениеНачалоПериода);
		ДатаДняНедели = НачалоНедели(ЗначениеНачалоПериода);
		
		СписокПериодов.Добавить(ДатаДняНедели - 86400, НСтр("ru = 'Предыдущая неделя'"));
		
		Пока ДатаДняНедели < КонецНедели Цикл
			СписокПериодов.Добавить(ДатаДняНедели, Формат(ДатаДняНедели, НСтр("ru='ДФ=''dd MMMM yyyy (ddd)'''")));
			ДатаДняНедели = ДатаДняНедели + 86400;
		КонецЦикла;
		
		СписокПериодов.Добавить(КонецНедели + 1, НСтр("ru = 'Следующая неделя'"));
	КонецЕсли;
	
	Возврат СписокПериодов;
	
КонецФункции

#КонецОбласти

#Область РаботаСДинамическимиСписками

// Определяет отбор динамического списка в зависимости от наличия режима совместимости.
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить отбор.
//
// Возвращаемое значение:
//   Отбор - требуемый отбор
//
Функция ПолучитьОтборДинамическогоСписка(Список) Экспорт
	
	Возврат Список.КомпоновщикНастроек.ФиксированныеНастройки.Отбор;
	
КонецФункции

// Определяет поля группировки динамического списка в зависимости от наличия режима совместимости.
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить группировку.
//
// Возвращаемое значение:
//   ПоляГруппировкиКомпоновкиДанных - требуемые поля группировки.
//
Функция ПолучитьПоляГруппировкиДинамическогоСписка(Список) Экспорт
	Перем Группировка, ПоляГруппировки;
	
	Для Каждого Элемент Из Список.КомпоновщикНастроек.Настройки.Структура Цикл
		Если ТипЗнч(Элемент) = Тип("ГруппировкаКомпоновкиДанных") Тогда
			Группировка = Элемент;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Группировка = Неопределено Тогда
		Группировка = Список.КомпоновщикНастроек.Настройки.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
		Группировка.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	КонецЕсли;
	
	ПоляГруппировки = Группировка.ПоляГруппировки;
		
	Возврат ПоляГруппировки;
	
КонецФункции

// Определяет условное оформление динамического списка в зависимости от наличия режима совместимости.
//
// Параметры:
//  Список - ДинамическийСписок - список, для которого надо определить условное оформление.
//
// Возвращаемое значение:
//   УсловноеОформление - требуемое условное оформление.
//
Функция ПолучитьУсловноеОформлениеДинамическогоСписка(Список) Экспорт
	
	Возврат Список.КомпоновщикНастроек.ФиксированныеНастройки.УсловноеОформление;
	
КонецФункции

#КонецОбласти

#Область РаботаСЖурналамиДокументов 

// Устанавливает видимость элементов формы, выводимых для рабочего места.
//
// Параметры:
//  Форма	 - ФормаКлиентскогоПриложения	 - форма с таблицей ХозяйственныеОперацииИДокументы
//	ИменаЭлементовСУправляемойВидимостью - Строка - имена элементов формы, перечисленные через запятую
//	КлючРабочегоМеста - Строка - идентифицирует рабочее место.
//
Процедура УстановитьВидимостьЭлементовРабочегоМеста(Форма, ИменаЭлементовСУправляемойВидимостью, КлючРабочегоМеста) Экспорт 
	
	НевидимыеЭлементы = Новый Структура(ИменаЭлементовСУправляемойВидимостью);
	
	Для Каждого Стр Из Форма.ХозяйственныеОперацииИДокументы Цикл
		Если Стр.Отбор
		 И Стр.КлючНазначенияИспользования = КлючРабочегоМеста Тогда
		 
			ВидимыеЭлементы = Новый Структура(Стр.ИменаЭлементовРабочегоМеста);
			Для Каждого КлючИЗначение Из ВидимыеЭлементы Цикл
				НевидимыеЭлементы.Удалить(КлючИЗначение.Ключ);
				ЭлементФормы = Форма.Элементы[КлючИЗначение.Ключ]; // ПолеФормы - 
				ЭлементФормы.Видимость = Истина;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого КлючИЗначение Из НевидимыеЭлементы Цикл
		ЭлементФормы = Форма.Элементы[КлючИЗначение.Ключ]; // ПолеФормы -
		ЭлементФормы.Видимость = Ложь;
	КонецЦикла;
			
КонецПроцедуры

#КонецОбласти

#Область ПреобразованиеТиповДанных

// Помещает переданные данные в массив.
//
// Параметры:
//	Элемент - Произвольный
//	ИгнорироватьПустоеЗначение - Булево - если Истина, то пустой Элемент не будет добавлен в результат.
//
// Возвращаемое значение:
//	Массив Из Произвольный -
//
Функция Массив(Элемент, ИгнорироватьПустоеЗначение = Истина) Экспорт
	
	Если ТипЗнч(Элемент) = Тип("Массив") Тогда
		Массив = Элемент;
	ИначеЕсли ТипЗнч(Элемент) = Тип("СписокЗначений") Тогда
		Массив = Элемент.ВыгрузитьЗначения();
	ИначеЕсли ТипЗнч(Элемент) = Тип("ФиксированныйМассив") Тогда
		Массив = Новый Массив(Элемент);
	Иначе
		Массив = Новый Массив;
		Если НЕ ИгнорироватьПустоеЗначение ИЛИ ЗначениеЗаполнено(Элемент) Тогда
			Массив.Добавить(Элемент);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Преобразовывает переданную коллекцию в массив.
//
// Параметры:
//	ИсходныеДанные - Структура, Соответствие - Исходная коллекция
//	ПреобразовыватьКлюч - Булево - определяет что именно надо преобразовывать, ключ или значение.
//
// Возвращаемое значение:
//	Массив - ключи или значения переданной коллекции.
//
//@skip-warning
Функция ПреобразоватьСоответствиеИлиСтруктуруВМассив(ИсходныеДанные, ПреобразовыватьКлюч = Истина) Экспорт
	
	Результат = Новый Массив;
	
	Для Каждого КлючИЗначение Из ИсходныеДанные Цикл
		Результат.Добавить(?(ПреобразовыватьКлюч, КлючИЗначение.Ключ, КлючИЗначение.Значение));
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
	
// Преобразовывает переданный массив в структуру или соответствие, ключами которой будут являться элементы массива.
//
// Параметры:
//	ИсходныеДанные - Массив - 
//	ПреобразовыватьВСтруктуру - Булево - определяет во что именно надо преобразовывать.
//
// Возвращаемое значение:
//	Структура, Соответствие - 
//
//@skip-warning
Функция ПреобразоватьМассивВСтруктуруИлиСоответствие(ИсходныеДанные, ПреобразовыватьВСтруктуру) Экспорт
	
	Если ПреобразовыватьВСтруктуру Тогда
		Результат = Новый Структура;
	Иначе
		Результат = Новый Соответствие;
	КонецЕсли;
	
	Для Каждого ТекущийЭлемент Из ИсходныеДанные Цикл
		Результат.Вставить(ТекущийЭлемент, ТекущийЭлемент);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
	
// Возвращает строку длиной не более определенного количества символов.
// Если строка больше - она обрезается и в конец добавляется многоточие.
//
// Параметры:
//  ИсходнаяСтрока		 - Строка 
//  МаксимальнаяДлина	 - Число 
//
// Возвращаемое значение:
//  Строка 
//
Функция ПредставлениеСтрокиСДлинойНеБолее(ИсходнаяСтрока, МаксимальнаяДлина) Экспорт
	
	Если СтрДлина(ИсходнаяСтрока) <= МаксимальнаяДлина Тогда
		Возврат ИсходнаяСтрока;
	Иначе
		Возврат Лев(ИсходнаяСтрока, СтрДлина(ИсходнаяСтрока) - 3) + "...";
	КонецЕсли;
	
КонецФункции

// Проверяет, является ли строка целым неотрицательным числом	
// Параметры:
//  ПроверяемаяСтрока - Строка - проверяемый строка.
//
// Возвращаемое значение:
//  Булево - Истина, если строка содержит только цифры.
//
Функция ЭтаСтрокаЯвляетсяЦелымНеотрицательнымЧислом(ПроверяемаяСтрока) Экспорт
	
	СтрокаЯвляетсяЧислом = Истина;
	ПроверяемаяСтрока = СокрЛП(ПроверяемаяСтрока);
	Длина = СтрДлина(ПроверяемаяСтрока);
	
	Для НомерСимвола = 1 По Длина Цикл
		Симв = Сред(ПроверяемаяСтрока, НомерСимвола, 1);
		Если Найти("0123456789", Симв) = 0 И КодСимвола(Симв)<>160 Тогда
			СтрокаЯвляетсяЧислом = Ложь;		
		КонецЕсли;		
	КонецЦикла;
		
	Возврат СтрокаЯвляетсяЧислом;
	
КонецФункции

// Добавляет в массив значение в том случае, если этого значения еще нет в массиве.
//
// Параметры:
//	Массив - Массив
//	Значение - Произвольный
//
// Возвращаемое значение:
//	Булево - было ли произведено добавление элемента.
//
Функция ДобавитьНовоеЗначениеВМассив(Массив, Значение) Экспорт
	
	Если Массив.Найти(Значение) = Неопределено Тогда 
		Массив.Добавить(Значение);
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Создает соответствие, ключами которого является части переданной строки.
//
// Параметры:
//	СтрокаКлючей - Строка - произвольная строка
//	Разделитель  - Строка - разделитель частей строки.
//
// Возвращаемое значение:
//	Соответствие - части переданной строки, Значения - Истина.
//
//@skip-warning
Функция ПреобразоватьСтрокуКлючейВСоответствие(СтрокаКлючей, Разделитель = ",") Экспорт
	
	Результат = Новый Соответствие;
	Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрокаКлючей, Разделитель, Истина, Истина);
	
	Для Каждого Элемент Из Массив Цикл
		Результат.Вставить(Элемент, Истина);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Создает структуру, ключами которого являются ключи соответствия.
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура - 
//
//@skip-warning
Функция ПреобразоватьСоответствиеВСтруктуру(Соответствие) Экспорт
	
	Результат = Новый Структура;
	
	Если НЕ ТипЗнч(Соответствие) = Тип("Соответствие") Тогда
		Возврат Результат
	КонецЕсли; 
	
	Для Каждого Элемент Из Соответствие Цикл
		Результат.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Создает соответствие, ключами которого являются ключи структуры.
//
// Параметры:
//	Структура - Структура
//
// Возвращаемое значение:
//	Соответствие - 
//
//@skip-warning
Функция ПреобразоватьСтруктуруВСоответствие(Структура) Экспорт
	
	Результат = Новый Соответствие;
	
	Если НЕ ТипЗнч(Структура) = Тип("Структура") Тогда
		Возврат Результат
	КонецЕсли; 

	Для Каждого Элемент Из Структура Цикл
		Результат.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Создает массив, значениями которого являются элементы, присутствующие только в одном из массивов.
//
// Параметры:
//	Массив1 - Массив
//	Массив2 - Массив
//
// Возвращаемое значение:
//	Массив - (элементы Массив1, отсутствующие в Массив2) + (элементы Массив2, отсутствующие в Массив1).
//
//@skip-warning
Функция РазличияМассивов(Массив1, Массив2) Экспорт
	
	Различия = Новый Массив;
	
	Для Каждого ТекущийЭлемент Из Массив1 Цикл
		Если Массив2.Найти(ТекущийЭлемент) = Неопределено Тогда
			ДобавитьНовоеЗначениеВМассив(Различия, ТекущийЭлемент);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ТекущийЭлемент Из Массив2 Цикл
		Если Массив1.Найти(ТекущийЭлемент) = Неопределено Тогда
			ДобавитьНовоеЗначениеВМассив(Различия, ТекущийЭлемент);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Различия;
	
КонецФункции

// Создает массив, значениями которого являются элементы, присутствующие в каждом из массивов.
//
// Параметры:
//	Массив1 - Массив
//	Массив2 - Массив
//
// Возвращаемое значение:
//	Массив - (элементы Массив1, присутствующие в Массив2).
//
//@skip-warning
Функция ПересечениеМассивов(Массив1, Массив2) Экспорт
	
	Пересечение = Новый Массив;
	
	Для Каждого ТекущийЭлемент Из Массив1 Цикл
		Если Массив2.Найти(ТекущийЭлемент) <> Неопределено Тогда
			ДобавитьНовоеЗначениеВМассив(Пересечение, ТекущийЭлемент);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Пересечение;
	
КонецФункции

// Проверяет, что в переданной структуре нет элементов с заполненными значениями.
//
// Параметры:
//	Данные - Структура
//
// Возвращаемое значение:
//	Булево - Истина, если в структуре нет ни одного заполненного значения.
//
Функция ЗначенияСтруктурыНеЗаполнены(Данные) Экспорт
	
	ПустыеЗначения = Истина;
	
	Для Каждого КлючИЗначение Из Данные Цикл
		
		Если (ТипЗнч(КлючИЗначение.Значение) = Тип("Булево") И КлючИЗначение.Значение)
		 ИЛИ (ТипЗнч(КлючИЗначение.Значение) <> Тип("Булево") И ЗначениеЗаполнено(КлючИЗначение.Значение)) Тогда
			ПустыеЗначения = Ложь;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПустыеЗначения;
	
КонецФункции

// Сортирует элементы массива.
//
// Параметры:
//	Массив - Массив - массив для сортировки.
//
Процедура СортироватьМассив(Массив) Экспорт
	
	Список = Новый СписокЗначений;
	
	Список.ЗагрузитьЗначения(Массив);
	Список.СортироватьПоЗначению();
	
	Массив = Список.ВыгрузитьЗначения();
	
КонецПроцедуры

// Процедура проверяет дубли значений в массиве
//
// Параметры:
//  Массив				  - Массив			 - проверяемый массив
//  Отказ				  - Булево			 - отказ продолжения операции.
//  ПредставлениеМассива  - Строка			 - представление вида данных для пользователей.
//  ПредставлениеЗначений - Строка			 - определяет необходимость вывода номера строки в сообщении об ошибке.
//  ИсключатьПустые       - Булево			 - определяет необходимость исключения пустых значений из массива перед проверкой дублей.
//
Процедура ПроверитьНаличиеДублейЗначенийМассива(Массив, Отказ, ПредставлениеМассива = "", ПредставлениеЗначений = "", ИсключатьПустые = Ложь) Экспорт
	
	КопияМассива = Новый Массив;
	Для Каждого Значение Из Массив Цикл
		Если НЕ ИсключатьПустые ИЛИ ЗначениеЗаполнено(Значение) Тогда
			КопияМассива.Добавить(Значение);
		КонецЕсли;
	КонецЦикла;
	
	ОбщегоНазначенияУТКлиентСервер.СортироватьМассив(КопияМассива);
	
	ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеМассива%"" повторяется значение ""%ПовторяемоеЗначение%"" в поле %ПредставлениеЗначений%.'");
	ШаблонСообщения = СтрЗаменить(ШаблонСообщения, "%ПредставлениеМассива%", ПредставлениеМассива);
	ШаблонСообщения = СтрЗаменить(ШаблонСообщения, "%ПредставлениеЗначений%", ПредставлениеЗначений);
	
	ПредыдущееЗначение = Неопределено;
	
	Для Каждого Значение Из КопияМассива Цикл
		
		Если ПредыдущееЗначение <> Значение Тогда
			ПредыдущееЗначение = Значение;
			Продолжить;
		КонецЕсли;
		
		ТекстСообщения = СтрЗаменить(ШаблонСообщения, "%ПовторяемоеЗначение%", СокрЛП(Строка(Значение)));
		#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		#Иначе
			ОбщегоНазначенияКлиент.СообщитьПользователю(ТекстСообщения);
		#КонецЕсли
		
		Отказ = Истина;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет из первого массива значения, содержащиеся во втором массиве.
//
// Параметры:
// 	ИсходныйМассив - Массив -
// 	ВычитаемыйМассив - Массив -
// 
// Возвращаемое значение:
// 	Массив -
//@skip-warning
Функция УдалитьЗначенияИзМассива(ИсходныйМассив, ВычитаемыйМассив) Экспорт
	
	Результат = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(ИсходныйМассив);
	
	Для Каждого ТекущийЭлемент Из ВычитаемыйМассив Цикл
		ОбщегоНазначенияКлиентСервер.УдалитьЗначениеИзМассива(Результат, ТекущийЭлемент)
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область РаботаСМобильнымКлиентом

// Перемещает все заголовки полей формы наверх и устанавливает им жирный шрифт, а поля формы выравнивает по левому краю
// 
// Параметры:
// 	Элементы - ЭлементыФормы - 
// 	Исключения - Неопределено, Массив из ЭлементыФормы - 
Процедура АдаптацияЭлементовФормыДляМобильногоЭкрана(Элементы, Исключения = Неопределено) Экспорт
	
	ЖирныйШрифт = Новый Шрифт(, , Истина);
	
	Для Каждого Элемент Из Элементы Цикл
		Если ТипЗнч(Элемент) = Тип("ПолеФормы") И (Исключения = Неопределено ИЛИ Исключения.Найти(Элемент) = Неопределено) Тогда
			
			Элемент.ПоложениеЗаголовка      = ПоложениеЗаголовкаЭлементаФормы.Верх;
			Элемент.ШрифтЗаголовка          = ЖирныйШрифт;
			Элемент.ГоризонтальноеПоложение = ГоризонтальноеПоложениеЭлемента.Лево;
			
		ИначеЕсли ТипЗнч(Элемент) = Тип("ГруппаФормы") Тогда 
			АдаптацияЭлементовФормыДляМобильногоЭкрана(Элемент.ПодчиненныеЭлементы);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область НастройкаРеквизитов

// Служит универсальной процедурой для изменения свойств элементов формы на основании полученных параметров.
// Параметры вычисляются при изменении реквизитов объекта.
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения- Форма, в которой нужно настроить зависимые элементы.
//  ПараметрыРеквизитовОбъекта - Массив из см. ДобавитьПараметрыРеквизитаОбъекта - Содержит список свойств и их значения.
//
Процедура НастроитьЗависимыеЭлементыФормы(Форма, ПараметрыРеквизитовОбъекта) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.РежимОтладки() Тогда
		ОбщегоНазначенияУТВызовСервера.ПроверитьПараметрыРеквизитовОбъекта(ПараметрыРеквизитовОбъекта);
	КонецЕсли;
	
	Для каждого ПараметрыРеквизита Из ПараметрыРеквизитовОбъекта Цикл
		
		Если НЕ ЗначениеЗаполнено(ПараметрыРеквизита.ИмяЭлемента) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненного"
			ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненногоБезОчистки" Тогда
			Форма.Элементы[ПараметрыРеквизита.ИмяЭлемента].ТолькоПросмотр = ПараметрыРеквизита.Значение;
			Форма.Элементы[ПараметрыРеквизита.ИмяЭлемента].АвтоОтметкаНезаполненного = НЕ ПараметрыРеквизита.Значение;
		ИначеЕсли ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОчистки" Тогда
			Форма.Элементы[ПараметрыРеквизита.ИмяЭлемента].ТолькоПросмотр = ПараметрыРеквизита.Значение;
		ИначеЕсли ПараметрыРеквизита.Свойство = "ВидимостьЭлемента" Тогда
			Форма.Элементы[ПараметрыРеквизита.ИмяЭлемента].Видимость = ПараметрыРеквизита.Значение;
		Иначе
			Форма.Элементы[ПараметрыРеквизита.ИмяЭлемента][ПараметрыРеквизита.Свойство] = ПараметрыРеквизита.Значение;
		КонецЕсли;
		Если ПараметрыРеквизита.Свойство = "АвтоОтметкаНезаполненного"
				И ПараметрыРеквизита.Значение = Ложь
			ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненного"
				И ПараметрыРеквизита.Значение = Истина
			ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненногоБезОчистки"
				И ПараметрыРеквизита.Значение = Истина Тогда
			Форма.Элементы[ПараметрыРеквизита.ИмяЭлемента].ОтметкаНезаполненного = Ложь;
		КонецЕсли;
	
	КонецЦикла;
	
КонецПроцедуры

// Используется для заполнения параметров свойств элементов формы.
// Далее эти параметры используются в процедурах:
//     - НастроитьЭлементыФормыНаСервере(), 
//     - ОбщегоНазначенияУТ.ОтключитьПроверкуЗаполненияРеквизитовОбъекта().
//
// Параметры:
//  ИмяРеквизита				 - Строка - Имя реквизита для которого устанавливается свойство (может быть пустым).
//  ИмяЭлемента					 - Строка - Имя элемента формы с которым связан реквизит.
//  Свойство					 - Строка - Свойство элемента формы. Разрешено любое свойство предусмотренное платформой для элементов формы.
//                                          Дополнительно можно использовать служебные свойства:
//                                              "ТолькоПросмотрБезОтметкиНезаполненного" - позволяет установить только просмотр у элемента и отключить проверку заполнения.
//                                              "ТолькоПросмотрБезОчистки" - позволяет сделать поле недоступным, не очищая его.
//                                              "ВидимостьЭлемента" - позволяет управлять только видимостью элемента, а проверка заполнения не отключается.
//  Значение					 - Произвольный - Любое значение свойства.
//  ПараметрыРеквизитовОбъекта	 - Массив из см.НовыйПараметрРеквизитаОбъекта - Параметры в которые нужно добавить.
//
//  Пример:
//  	ОбщегоНазначенияУТКлиентСервер.ДобавитьПараметрыРеквизитаОбъекта(
//  		"ОС.СуммаСписанияУУ", "ОССуммаСписанияУУ", "Видимость", СуммаВидима, ПараметрыРеквизитовОбъекта).
//
Процедура ДобавитьПараметрыРеквизитаОбъекта(ИмяРеквизита, ИмяЭлемента, Свойство, Значение, ПараметрыРеквизитовОбъекта) Экспорт
	
	НовыйПараметр = НовыйПараметрРеквизитаОбъекта();
	НовыйПараметр.ИмяРеквизита = ИмяРеквизита;
	НовыйПараметр.ИмяЭлемента = ИмяЭлемента;
	НовыйПараметр.Свойство = Свойство;
	НовыйПараметр.Значение = Значение;
	
	ПараметрыРеквизитовОбъекта.Добавить(НовыйПараметр);
	
КонецПроцедуры

// Очищает неиспользуемые реквизиты.
// 
// Параметры:
//  Объект - Произвольный - Объект, реквизиты которого нужно очистить.
//  ПараметрыРеквизитовОбъекта - Массив из см. НовыйПараметрРеквизитаОбъекта - Параметры реквизитов объекта.
//  ИменаТабличныхЧастей - Строка - Имена табличных частей.
Процедура ОчиститьНеиспользуемыеРеквизиты(Объект, ПараметрыРеквизитовОбъекта, ИменаТабличныхЧастей = "") Экспорт

	НеиспользуемыеРеквизитыТабличныхЧастей = Новый Соответствие;
	
	ТабличныеЧастиОбъекта = Новый Структура(ИменаТабличныхЧастей);
	
	Для каждого ПараметрыРеквизита Из ПараметрыРеквизитовОбъекта Цикл
		
		Если НЕ ЗначениеЗаполнено(ПараметрыРеквизита.ИмяРеквизита) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПараметрыРеквизита.Свойство = "Видимость" И ПараметрыРеквизита.Значение = Ложь
			ИЛИ (ПараметрыРеквизита.Свойство = "ТолькоПросмотр" ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненного")
					И ПараметрыРеквизита.Значение = Истина Тогда
					
			ПутьКРеквизиту = СтрРазделить(ПараметрыРеквизита.ИмяРеквизита, ".");
			Если ПутьКРеквизиту.ВГраница() <> 0 Тогда
				РеквизитыТЧ = НеиспользуемыеРеквизитыТабличныхЧастей.Получить(ПутьКРеквизиту[0]);
				Если РеквизитыТЧ = Неопределено Тогда
					РеквизитыТЧ = Новый Массив;
				КонецЕсли;
				РеквизитыТЧ.Добавить(ПутьКРеквизиту[1]);
				НеиспользуемыеРеквизитыТабличныхЧастей.Вставить(ПутьКРеквизиту[0], РеквизитыТЧ);
			ИначеЕсли ТипЗнч(Объект[ПараметрыРеквизита.ИмяРеквизита]) = Тип("ДанныеФормыКоллекция") 
				ИЛИ ТабличныеЧастиОбъекта.Свойство(ПараметрыРеквизита.ИмяРеквизита) Тогда
				Объект[ПараметрыРеквизита.ИмяРеквизита].Очистить();
			Иначе
				Объект[ПараметрыРеквизита.ИмяРеквизита] = Неопределено;
			КонецЕсли; 
		
		КонецЕсли;
		
	КонецЦикла;
	
	// Очистка реквизитов ТЧ
	Для каждого КлючИЗначение Из НеиспользуемыеРеквизитыТабличныхЧастей Цикл
		Для каждого ДанныеСтроки Из Объект[КлючИЗначение.Ключ] Цикл
			Для каждого ИмяРеквизита Из КлючИЗначение.Значение Цикл
				ДанныеСтроки[ИмяРеквизита] = Неопределено;
			КонецЦикла; 
		КонецЦикла; 
	КонецЦикла; 
	
КонецПроцедуры

// Создает новое описание параметров реквизита объекта.
// 
// Возвращаемое значение:
// 	Структура - со свойствами:
//      * Значение - Число, Булево -
//      * Свойство - Строка -
//      * ИмяЭлемента - Строка -
//      * ИмяРеквизита - Строка - 
Функция НовыйПараметрРеквизитаОбъекта() Экспорт

	НовыйПараметр = Новый Структура;
	НовыйПараметр.Вставить("ИмяРеквизита");
	НовыйПараметр.Вставить("ИмяЭлемента");
	НовыйПараметр.Вставить("Свойство");
	НовыйПараметр.Вставить("Значение");
	
	Возврат НовыйПараметр;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область ЗначенияДоИзменения

// Сохраняет значения до изменения в реквизит формы
//
// Параметры:
//  Форма		 - ФормаКлиентскогоПриложения - обрабатываемая форма
//  ИмяРеквизита - Строка - имя изменяемого реквизита
//
Процедура СохранитьЗначенияДоИзменения(Форма, ИмяРеквизита = Неопределено) Экспорт
	
	Если Форма.ЗначенияДоИзменения = Неопределено Тогда
		
		Форма.ЗначенияДоИзменения = Форма.ЗначенияПоУмолчанию;
		
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(Форма.ЗначенияДоИзменения, Форма.НаборКонстант, ИмяРеквизита);
	
КонецПроцедуры

// Восстанавливает значения до изменения в реквизит формы
//
// Параметры:
//  Форма		 - ФормаКлиентскогоПриложения - обрабатываемая форма
//  ИмяРеквизита - Строка - имя изменяемого реквизита
//
Процедура ВосстановитьЗначенияДоИзменения(Форма, ИмяРеквизита) Экспорт
	
	ЗаполнитьЗначенияСвойств(Форма.НаборКонстант, Форма.ЗначенияДоИзменения, ИмяРеквизита);
	
КонецПроцедуры

// Функция - Получить значение до изменения
//
// Параметры:
//  Форма		 - ФормаКлиентскогоПриложения - обрабатываемая форма
//  ИмяРеквизита - Строка - имя изменяемого реквизита
// 
// Возвращаемое значение:
//  Произвольный - значение реквизита
//
Функция ПолучитьЗначениеДоИзменения(Форма, ИмяРеквизита) Экспорт
	
	Возврат Форма.ЗначенияДоИзменения[ИмяРеквизита];
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ДанныеПоЧастямПути(Объект, ЧастиПутиКДанным, ИдентификаторСтроки, ЗначениеОтсутствия = Неопределено)
	
	ЭтоФорма = ТипЗнч(Объект) = Тип("ФормаКлиентскогоПриложения");
	
	Если НЕ ЭтоФорма И ЧастиПутиКДанным[0] = "Объект" Тогда // "Объект.Реквизит", "Объект.ТабличнаяЧасть", "Объект.ТабличнаяЧасть.Реквизит"
		ЧастиПутиКДанным.Удалить(0);
	ИначеЕсли ЭтоФорма И ЧастиПутиКДанным[0] = "Форма" Тогда // "Форма.РеквизитФормы", "Форма.ТаблицаФормы", "Форма.ТаблицаФормы.Колонка"
		ЧастиПутиКДанным.Удалить(0);
	КонецЕсли;
	
	Данные = Объект;
	Если ЧастиПутиКДанным.Количество() > 0 
		И ЧастиПутиКДанным[0] = "Объект" Тогда // Объект - это форма, "Объект.Реквизит", "Объект.ТабличнаяЧасть", "Объект.ТабличнаяЧасть.Реквизит"
		Данные = Данные[ЧастиПутиКДанным[0]];
		ЧастиПутиКДанным.Удалить(0);
	КонецЕсли;
	// Теперь Данные - это ДокументОбъект или СправочникОбъект или основной реквизит формы "Объект" или ФормаКлиентскогоПриложения
	// Путь к данным 	"Реквизит", "ТабличнаяЧасть", "ТабличнаяЧасть.Реквизит", "Реквизит1.Реквизит2"
	// 					"РеквизитФормы", "ТаблицаФормы", "ТаблицаФормы.Колонка", "РеквизитФормы.Реквизит"
	Если ЧастиПутиКДанным.Количество() > 0 Тогда
		Данные = Данные[ЧастиПутиКДанным[0]]; // Таблица или реквизит объекта/формы
		ТипЗначения = ТипЗнч(Данные);
		
		Если НЕ ЭтоФорма Тогда
			ТипЗначенияСтрокой = ВРег(СтрЗаменить(Строка(ТипЗначения)," ",""));
			ТипЭталонДокумента = Тип("ДокументТабличнаяЧасть.КорректировкаРегистров.ТаблицаРегистров");
			ТипЭталонСправочника = Тип("СправочникТабличнаяЧасть.Организации.КонтактнаяИнформация");
			ТипЭталонДокументаСтрокой = ВРег(СтрЗаменить(Строка(ТипЭталонДокумента)," ",""));
			ТипЭталонСправочникаСтрокой = ВРег(СтрЗаменить(Строка(ТипЭталонСправочника)," ",""));
			ПозицияРазделителя = СтрНайти(ТипЭталонДокументаСтрокой,":")-1;
			ЭтоТабличнаяЧасть = Лев(ТипЗначенияСтрокой, ПозицияРазделителя) = Лев(ТипЭталонДокументаСтрокой, ПозицияРазделителя)
				ИЛИ Лев(ТипЗначенияСтрокой, ПозицияРазделителя) = Лев(ТипЭталонСправочникаСтрокой, ПозицияРазделителя);
		Иначе
			ЭтоТабличнаяЧасть = ТипЗначения = Тип("ДанныеФормыКоллекция");
		КонецЕсли;
		
		Если ЭтоТабличнаяЧасть Тогда // Данные - это таблица
			Если ИдентификаторСтроки <> Неопределено Тогда // Из таблицы можем получить строку или значение в строке
				Если ТипЗначения = Тип("ДанныеФормыКоллекция") Тогда
					// По пути находится таблица формы.
					// Если задан идентификатор, то вернем строку
					Данные = Данные.НайтиПоИдентификатору(ИдентификаторСтроки);
				Иначе
					// Ожидаем в идентификаторе номер строки
					Данные = Данные[ИдентификаторСтроки-1];
				КонецЕсли;
				// Данные - это строка, если нужно значение получим его из строки
				Если ЧастиПутиКДанным.Количество() = 2 Тогда
					Данные = Данные[ЧастиПутиКДанным[1]];
				КонецЕсли;
			ИначеЕсли ЧастиПутиКДанным.Количество() = 2 Тогда //Если идентификатор не задан вернем значения реквизита в массиве
				МассивДанных = Новый Массив;
				Для Каждого СтрокаТаблицы Из Данные Цикл
					МассивДанных.Добавить(СтрокаТаблицы[ЧастиПутиКДанным[1]]);
				КонецЦикла;
				Данные = МассивДанных;
			КонецЕсли;
		ИначеЕсли ЧастиПутиКДанным.Количество() = 2 Тогда 
			Если ТипЗначения = Тип("ДанныеФормыСтруктура") 
				Или ТипЗначения = Тип("Структура") Тогда
				Данные = Данные[ЧастиПутиКДанным[1]]
			ИначеЕсли ЗначениеЗаполнено(Данные) Тогда
				Данные = ОбщегоНазначенияУТВызовСервера.ЗначениеРеквизитаОбъектаВПривилегированномРежиме(Данные, ЧастиПутиКДанным[1]);
			Иначе
				Возврат ЗначениеОтсутствия;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

Функция СинонимДокумента(ИмяИлиИдентификаторДокумента)
	
	#Если Клиент Тогда
		Возврат ОбщегоНазначенияУТКлиентПовтИсп.СинонимДокумента(ИмяИлиИдентификаторДокумента);
	#Иначе
		Возврат ОбщегоНазначенияУТВызовСервера.СинонимДокумента(ИмяИлиИдентификаторДокумента);
	#КонецЕсли
	
КонецФункции

#КонецОбласти
