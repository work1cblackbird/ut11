
#Область ПрограммныйИнтерфейс

#Область МетодыРаботыАвтозаполненияРеквизитовДокумента

// Устарела. Следует использовать функцию ОбщегоНазначения.ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено)
// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность - Число - разрядность числа
//  РазрядностьДробнойЧасти - Число - Разрядность дробной части.
//  Неотрицательный - Булево - если Истина, то числа только положительные, если Ложь, то любые.
//
// Возвращаемое значение:
//  ОписаниеТипов - для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти, Неотрицательный = Ложь) Экспорт
	
	Если Неотрицательный Тогда
		Знак = ДопустимыйЗнак.Неотрицательный;
	Иначе
		Знак = ДопустимыйЗнак.Любой;
	КонецЕсли;
	
	Возврат ОбщегоНазначения.ОписаниеТипаЧисло(Разрядность, РазрядностьДробнойЧасти, Знак);

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - ЧастиДаты - Системное перечисление ЧастиДаты.
// 
//  Возвращаемое значение:
//    ОписаниеТипов - 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Возврат Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты));

КонецФункции // ПолучитьОписаниеТиповДаты()

// Дополняет одну таблицу значений строками другой таблицы значений
//
// Параметры:
//	Приемник - ТаблицаЗначений - произвольная коллекция, в которую добавляются строки
//	Источник - ТаблицаЗначений - произвольная коллекция, из которой берутся добавляемые строки
//	СоответствиеПолей - Соответствие - используется чтобы заполнить поля с разными названиями, 
//										ключ содержит имя поля приемника, значение содержит имя поля источника.
//	ЗначенияПоУмолчанию - Структура - значения, которые будут помещены во все добавленные строки,
//										ключ содержит имя поля приемника.
//
Процедура ДобавитьСтрокиВТаблицу(Приемник, Источник, СоответствиеПолей = Неопределено, ЗначенияПоУмолчанию = Неопределено) Экспорт

	Для каждого СтрокаИсточника Из Источник Цикл
		НоваяСтрока = Приемник.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаИсточника);
		Если СоответствиеПолей <> Неопределено Тогда
			Для каждого КлючИЗначение Из СоответствиеПолей Цикл
				НоваяСтрока[КлючИЗначение.Ключ] = СтрокаИсточника[КлючИЗначение.Значение];
			КонецЦикла; 
		КонецЕсли; 
		Если ЗначенияПоУмолчанию <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ЗначенияПоУмолчанию);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Заполняет колонку таблицы значений последовательными номерами
//
// Параметры:
//	Таблица - ТаблицаЗначений - Таблица значений, строки которой нужно пронумеровать
//	ИмяКолонкиНомераСтроки - Строка - Имя колонки таблицы значений, в которой будут указаны номера строк
//
Процедура ПронумероватьТаблицуЗначений(Таблица, ИмяКолонкиНомераСтроки) Экспорт

	Если Таблица.Колонки.Найти(ИмяКолонкиНомераСтроки) = Неопределено Тогда
		Таблица.Колонки.Добавить(ИмяКолонкиНомераСтроки, ПолучитьОписаниеТиповЧисла(15, 0));
	КонецЕсли;

	КоличествоСтрок = Таблица.Количество() - 1;
	Для НомерСтроки = 0 По КоличествоСтрок Цикл
		Таблица[НомерСтроки][ИмяКолонкиНомераСтроки] = НомерСтроки;
	КонецЦикла;

КонецПроцедуры

// Выгружает таблицу значений из ДанныеФормыКоллекция и ТабличнаяЧасть
//
// Параметры:
// 		ТаблицаИсточник - ДанныеФормыКоллекция, ТабличнаяЧасть - Таблица источник выгрузки
// 		Строки - Массив -
//             - Структура - Массив строк для выгрузки или структура отбора
// 		Колонки - Строка - Перечисленные через запятую имена колонок для выгрузки
// 		КолонкиПоЗначению - Структура Из КлючИЗначение - Структура колонок для добавление в результирующую таблицу:
// 										* Ключ - Строка - Имя новой колонки
// 										* Значение - Строка - Значение для подстановки во все строки новой колонки.
// 		НовыеИменаКолонок - Структура Из КлючИЗначение - Структура с данными о переименовании колонок в результирующей таблице:
// 										* Ключ - Строка - Текущее имя колонки
// 										* Значение - Строка - Новое имя колонки.
//
// Возвращаемое значение:
// 		ТаблицаЗначений - Таблица результат выгрузки из таблицы источника с добавленными и переименованными колонками.
//
Функция ВыгрузитьТаблицуЗначений(ТаблицаИсточник, Строки = Неопределено, Колонки = "НомерСтроки",
			Знач КолонкиПоЗначению = Неопределено, Знач НовыеИменаКолонок = Неопределено) Экспорт
	
	// Определение значений по умолчанию
	Если КолонкиПоЗначению = Неопределено Тогда
		КолонкиПоЗначению = Новый Структура;
	КонецЕсли;
	Если НовыеИменаКолонок = Неопределено Тогда
		НовыеИменаКолонок = Новый Структура;
	КонецЕсли;
	
	// Определить список выгружаемых колонок
	СтруктураДругихИменКолонок = Новый Структура;
	Для Каждого НовоеИмя Из НовыеИменаКолонок Цикл
		СтруктураДругихИменКолонок.Вставить(НовоеИмя.Значение, НовоеИмя.Ключ);
	КонецЦикла;
	ИменаКолонок = "";
	ИмяКолонки = "";
	СтруктураКолонок = Новый Структура(Колонки);
	Для Каждого Колонка Из СтруктураКолонок Цикл
		Если Не СтруктураДругихИменКолонок.Свойство(Колонка.Ключ, ИмяКолонки) Тогда
			ИмяКолонки = Колонка.Ключ;
		КонецЕсли;
		Если Не КолонкиПоЗначению.Свойство(ИмяКолонки) Тогда
			ИменаКолонок = ИменаКолонок + ", " + ИмяКолонки;
		КонецЕсли;
	КонецЦикла;
	
	// Выгрузить из таблицы источника
	Если ТипЗнч(ТаблицаИсточник) = Тип("ТаблицаЗначений") Тогда
		ТаблицаРезультата = ТаблицаИсточник.Скопировать(Строки, Сред(ИменаКолонок, 3));
	Иначе
		ТаблицаРезультата = ТаблицаИсточник.Выгрузить(Строки, Сред(ИменаКолонок, 3));
	КонецЕсли;
	
	// Добавить новые колонки в таблицу результата
	Если КолонкиПоЗначению <> Неопределено Тогда
		Для Каждого Колонка Из КолонкиПоЗначению Цикл
			МассивТипов = Новый Массив;
			МассивТипов.Добавить(ТипЗнч(Колонка.Значение));
			ТаблицаРезультата.Колонки.Добавить(Колонка.Ключ, Новый ОписаниеТипов(МассивТипов));
			ТаблицаРезультата.ЗаполнитьЗначения(Колонка.Значение, Колонка.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	// Переименовать колонки в таблице результата
	Если НовыеИменаКолонок <> Неопределено Тогда
		Для Каждого Колонка Из НовыеИменаКолонок Цикл
			ТаблицаРезультата.Колонки[Колонка.Ключ].Имя = Колонка.Значение;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ТаблицаРезультата;
	
КонецФункции // ВыгрузитьТаблицуЗначений()

// Заполняет идентификатор строк в таблице значений
//
// Параметры:
//  Таблица - ТаблицаЗначений - Таблица значений, строки которой нужно пронумеровать
//  ИмяКолонки - Строка	- Колонка таблицы значений, в которой будут заполнены идентификаторы.
//  ТипИдентификатора - Строка - Тип идентификатора ("Число", "УникальныйИдентификатор")
//
Процедура ДобавитьИдентификаторСтрокВТаблицу(Таблица, ИмяКолонки = "Идентификатор", ТипИдентификатора = "Число") Экспорт

	Если ТипИдентификатора = "Число" Тогда

		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 0, ДопустимыйЗнак.Неотрицательный)));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = НомерСтроки + 1;
		КонецЦикла;
		
	ИначеЕсли ТипИдентификатора = "УникальныйИдентификатор" Тогда
		
		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, Новый ОписаниеТипов("УникальныйИдентификатор"));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = Новый УникальныйИдентификатор;
		КонецЦикла;
		
	ИначеЕсли ТипИдентификатора = "Строка" Тогда
		
		Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Таблица.Колонки.Добавить(ИмяКолонки, ОбщегоНазначения.ОписаниеТипаСтрока(36));
		КонецЕсли;
		
		Для НомерСтроки = 0 По Таблица.Количество() - 1 Цикл
			Таблица[НомерСтроки][ИмяКолонки] = Строка(Новый УникальныйИдентификатор);
		КонецЦикла;
		
	КонецЕсли;

КонецПроцедуры

// Процедура делает запись в журнал регистрации и сообщает пользователю, если это сообщение об ошибке 
// Параметры:
//   ПараметрыЖурнала - Структура - параметры записи в журнал регистрации:
//       		* ГруппаСобытий - Строка - префикс для имени события журнала регистрации
//       		* Метаданные - ОбъектМетаданных - метаданные для записи в журнал регистрации
//       		* Данные - Произвольный - данные для записи в журнал регистрации
//   УровеньЖурнала - УровеньЖурналаРегистрации - Уровень журнала регистрации
//   ИмяСобытия - Строка  - имя события (в журнал событие записывается в формате ГруппаСобытий.ИмяСобытия)
//   Комментарий - Строка - комментарий о событии
//   ИнформацияОбОшибке - ИнформацияОбОшибке -
//	                    - Строка - Информация об ошибке, которую так же необходимо задокументировать в комментарии журнала регистрации.
//
Процедура ЗаписатьВЖурналСообщитьПользователю(ПараметрыЖурнала, УровеньЖурнала, ИмяСобытия, Знач Комментарий = "", ИнформацияОбОшибке = Неопределено) Экспорт
	
	Если ТипЗнч(ИнформацияОбОшибке) = Тип("ИнформацияОбОшибке") Тогда
		Если Комментарий = "" Тогда
			ТестСообщенияПользователю = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Иначе
			ТестСообщенияПользователю = Комментарий + Символы.ПС + КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
			Комментарий = Комментарий + Символы.ПС + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		КонецЕсли;
	Иначе
		Если ТипЗнч(ИнформацияОбОшибке) = Тип("Строка") 
			И Не ПустаяСтрока(ИнформацияОбОшибке) Тогда
			Если Комментарий = "" Тогда
				Комментарий = ИнформацияОбОшибке;
			Иначе
				Комментарий = Комментарий + Символы.ПС + ИнформацияОбОшибке;
			КонецЕсли;
		КонецЕсли;
		ТестСообщенияПользователю = Комментарий;
	КонецЕсли;
	
	// Журнал регистрации 
	УстановитьПривилегированныйРежим(Истина);
	ЗаписьЖурналаРегистрации(
	    СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1'", ОбщегоНазначения.КодОсновногоЯзыка()),
			ПараметрыЖурнала.ГруппаСобытий + ?(ИмяСобытия = "", "", "." + ИмяСобытия)),
		УровеньЖурнала, 
		ПараметрыЖурнала.Метаданные, 
		ПараметрыЖурнала.Данные, 
		Комментарий);
	УстановитьПривилегированныйРежим(Ложь);
	
	Если УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка 
		Или УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение Тогда
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(СокрЛП(ТестСообщенияПользователю),ПараметрыЖурнала.Данные);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает ключ данных для подстановки в сообщение пользователю
// Ключ данных нужен при групповой обработке объектов - если он установлен, то при нажатии пользователем на сообщение
// будет открываться форма объекта.
//
//	Параметры:
//		Объект - ДокументОбъект - 
//             - СправочникОбъект - 
//             - ПланВидовХарактеристикОбъект - Объект, для которого нужно получить ключ данных.
//	
//	Возвращаемое значение:
//		СправочникСсылка, ДокументСсылка, ПланВидовХарактеристикСсылка -
//
Функция КлючДанныхДляСообщенияПользователю(Объект) Экспорт
	
	КлючДанных = Неопределено;
	XMLТипЗнч = XMLТипЗнч(Объект); 
	
	Если XMLТипЗнч <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч.ИмяТипа;
		Если СтрНайти(ТипЗначенияСтрокой, "Object.") > 0 Тогда
			КлючДанных = Объект.Ссылка;
		КонецЕсли;
	КонецЕсли;
	
	Возврат КлючДанных;
	
КонецФункции

// Вызывается из подписки ЗаполнитьРеквизитыОбъекта
// Проверяет заполненность реквизитов формы, связанных с функциональными опциями
// ИспользоватьНесколькоОрганизаций, ИспользоватьНесколькоСкладов, ИспользоватьНесколькоВалют.
//
//	Параметры:
//		Объект - ДокументОбъект -
//			   - СправочникОбъект - Заполняемый объект
//		ДанныеЗаполнения - Произвольный - Данные заполнения 
//		СтандартнаяОбработка - Булево - Признак стандартной обработки события
//	
//	Возвращаемое значение
//		Ссылка - ссылка на объект информационной базы.
//
Процедура ОбработкаЗаполнения(Объект, ДанныеЗаполнения, СтандартнаяОбработка) Экспорт
	
	// Пропускаем обработку, чтобы гарантировать получение формы при передаче параметра "АвтоТест".
	Если ДанныеЗаполнения = "АвтоТест" Тогда
		Возврат;
	КонецЕсли;
	
	БазоваяВерсия = ПолучитьФункциональнуюОпцию("БазоваяВерсия");
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизаций")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Организация")
		И Не ЗначениеЗаполнено(Объект.Организация) Тогда
		Объект.Организация = ЗначениеНастроекПовтИсп.ПолучитьОрганизациюПоУмолчанию(Объект.Организация);
		Если Не ЗначениеЗаполнено(Объект.Организация) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
			|	Организации.Ссылка
			|ИЗ
			|	Справочник.Организации КАК Организации");
			
			Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Организация"". В информационной базе введено несколько организаций.
				|Включите опцию ""НСИ и администрирование""-""Предприятие""-""Несколько организаций""!'");
			ИначеЕсли БазоваяВерсия Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Организация"". Возможно, в информационной базе не введено ни одной организации!
				|Для настройки необходимо перейти в раздел ""Моя организация""-""Сведения об организации"".'");
			Иначе
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Организация"". Возможно, в информационной базе не введено ни одной организации!
				|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Сведения об организации"".'");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоСкладов")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Склад")
		И Не ЗначениеЗаполнено(Объект.Склад) Тогда
		Объект.Склад = ЗначениеНастроекПовтИсп.ПолучитьСкладПоУмолчанию(Объект.Склад);
		Если Не ЗначениеЗаполнено(Объект.Склад) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
			|	Склады.Ссылка
			|ИЗ
			|	Справочник.Склады КАК Склады");
			
			Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
				Если БазоваяВерсия Тогда
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Склад"". В информационной базе введено несколько складов.
					|Включите опцию ""Настройки""-""Склад""-""Несколько складов""!'");
				Иначе
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Склад"". В информационной базе введено несколько складов.
					|Включите опцию ""НСИ и администрирование""-""Склад и доставка""-""Несколько складов""!'");
				КонецЕсли;
			Иначе
				Если БазоваяВерсия Тогда
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Склад"". Возможно, в информационной базе не введено ни одного склада.
					|Для настройки необходимо перейти в раздел ""Настройки""-""Склад"".'");
				Иначе
					ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Склад"". Возможно, в информационной базе не введено ни одного склада.
					|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка складского учета"".'");
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Валюта")
		И Не ЗначениеЗаполнено(Объект.Валюта) Тогда
		Объект.Валюта = ДоходыИРасходыСервер.ПолучитьВалютуУправленческогоУчета(Объект.Валюта);
		Если Не ЗначениеЗаполнено(Объект.Валюта) Тогда
			Если БазоваяВерсия Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Валюта"". Необходимо заполнить валюту управленческого учета.
				|Для настройки необходимо перейти в раздел ""Моя организация""-""Настройки""-""Общие настройки""-""Валюты"".'");
			Иначе
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Валюта"". Необходимо заполнить валюту управленческого учета.
				|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Предприятие""-""Валюты"".'");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоВалют")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "ВалютаВзаиморасчетов")
		И Не ЗначениеЗаполнено(Объект.ВалютаВзаиморасчетов) Тогда
		Объект.ВалютаВзаиморасчетов = ДоходыИРасходыСервер.ПолучитьВалютуУправленческогоУчета(Объект.ВалютаВзаиморасчетов);
		Если Не ЗначениеЗаполнено(Объект.ВалютаВзаиморасчетов) Тогда
			Если БазоваяВерсия Тогда
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Валюта взаиморасчетов"". Необходимо заполнить валюту управленческого учета.
				|Для настройки необходимо перейти в раздел ""Моя организация""-""Настройки""-""Общие настройки""-""Валюты"".'");
			Иначе
				ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Валюта взаиморасчетов"". Необходимо заполнить валюту управленческого учета.
				|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Предприятие""-""Валюты"".'");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоКасс")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "Касса")
		И Не ЗначениеЗаполнено(Объект.Касса) Тогда
		
		Если ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "ДополнительныеСвойства")
			И Объект.ДополнительныеСвойства.Свойство("НеобходимостьЗаполненияКассыПриФОИспользоватьНесколькоКассЛожь") 
			И НЕ Объект.ДополнительныеСвойства.НеобходимостьЗаполненияКассыПриФОИспользоватьНесколькоКассЛожь Тогда
			// Не требуется заполнение кассы при не включенной опции "ИспользоватьНесколькоКасс".
		Иначе
			
			СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияКассыОрганизацииПоУмолчанию();
			СтруктураПараметров.Касса 			= Объект.Касса;
			Объект.Касса = ЗначениеНастроекПовтИсп.ПолучитьКассуОрганизацииПоУмолчанию(СтруктураПараметров);
			Если Не ЗначениеЗаполнено(Объект.Касса) Тогда
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
				|	Кассы.Ссылка
				|ИЗ
				|	Справочник.Кассы КАК Кассы
				|ГДЕ
				|	НЕ Кассы.ПометкаУдаления");
				
				Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
					Если БазоваяВерсия Тогда
						ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Касса"". В информационной базе введено несколько касс.
						|Включите опцию ""Моя организация""-""Настройки""-""Общие настройки""-""Несколько касс""!'");
					Иначе
						ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Касса"". В информационной базе введено несколько касс.
						|Включите опцию ""НСИ и администрирование""-""Казначейство""-""Несколько касс""!'");
					КонецЕсли;
				Иначе
					Если БазоваяВерсия Тогда
						ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Касса"". Возможно, в информационной базе не введено ни одной кассы!
						|Для настройки необходимо перейти в раздел ""Моя организация""-""Настройки""-""Общие настройки""-""Настройка кассы"".'");
					Иначе
						ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Касса"". Возможно, в информационной базе не введено ни одной кассы!
						|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка кассы"".'");
					КонецЕсли;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоРасчетныхСчетов")
		И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "БанковскийСчет")
		И Не ЗначениеЗаполнено(Объект.БанковскийСчет) Тогда
		
		Если ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Объект, "ДополнительныеСвойства")
			И Объект.ДополнительныеСвойства.Свойство("НеобходимостьЗаполненияСчетаПриФОИспользоватьНесколькоСчетовЛожь") 
			И НЕ Объект.ДополнительныеСвойства.НеобходимостьЗаполненияСчетаПриФОИспользоватьНесколькоСчетовЛожь Тогда
			// Не требуется заполнение расчетного счета при не включенной опции "ИспользоватьНесколькоРасчетныхСчетов".
		Иначе
			
			СтруктураПараметров = ДенежныеСредстваСервер.ПараметрыЗаполненияБанковскогоСчетаОрганизацииПоУмолчанию();
			СтруктураПараметров.БанковскийСчет = Объект.БанковскийСчет;  
			Объект.БанковскийСчет = ЗначениеНастроекПовтИсп.ПолучитьБанковскийСчетОрганизацииПоУмолчанию(СтруктураПараметров);
			
			Если Не ЗначениеЗаполнено(Объект.БанковскийСчет) Тогда
				
				Запрос = Новый Запрос(
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
				|	БанковскиеСчетаОрганизаций.Ссылка
				|ИЗ
				|	Справочник.БанковскиеСчетаОрганизаций КАК БанковскиеСчетаОрганизаций");
				
				Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
					Если БазоваяВерсия Тогда
						ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Банковский счет"". В информационной базе введено несколько банковских счетов организаций.
						|Включите опцию ""Моя организация""-""Настройки""-""Общие настройки""-""Несколько банковских счетов""!'");
					Иначе
						ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Банковский счет"". В информационной базе введено несколько банковских счетов организаций.
						|Включите опцию ""НСИ и администрирование""-""Казначейство""-""Несколько банковских счетов""!'");
					КонецЕсли;
				Иначе
					Если БазоваяВерсия Тогда
						ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Банковский счет"". Возможно, в информационной базе не введено ни одного банковского счета организации!
						|Для настройки необходимо перейти в раздел ""Моя организация""-""Настройки""-""Общие настройки""-""Настройка банковского счета"".'");
					Иначе
						ВызватьИсключение НСтр("ru = 'Не удалось заполнить поле ""Банковский счет"". Возможно, в информационной базе не введено ни одного банковского счета организации!
						|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка банковского счета"".'");
					КонецЕсли;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет уникальный идентификатор платежа
//
// Параметры:
// 	Объект - ДокументОбъект - Документ для заполнения уникального идентификатора платежа
//
// Возвращаемое значение:
// 	Строка -
Функция ПолучитьУникальныйИдентификаторПлатежа(Объект) Экспорт
	
	Префикс = ПолучитьПрефиксДляУИП(Объект.Ссылка);
	Дата = Формат(Объект.Дата, "ДФ=yyMM");
	Номер = СтрЗаменить(Объект.Номер, "-", "");
	Код = Строка(Префикс) + Строка(Дата) + Строка(Номер);
	УИН = ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код);
	
	Возврат УИН;
	
КонецФункции

// Функция возвращает изменения документа, относительно записанного в базе
// 
// Параметры:
// 	Объект - ДокументОбъект - Документ, изменение которого необходимо проанализировать
// 	РеквизитыИсключения - Структура - Структура имен реквизитов, изменение которых проверять не требуется
// 	ТабличныеЧастиИсключения - Структура - Структура имен табличных частей, изменение которых проверять не требуется.
//
// Возвращаемое значение:
// 	Структура - Содержит изменения объекта:
// 				* Реквизиты - ТаблицаЗначений - Таблица измененных реквизитов:
//	                                              * Имя - Строка - 
//	                                              * НовоеЗначение - Произвольный -
//											      * СтароеЗначение - Произвольный - 
// 				* ТабличныеЧасти - Структура - Изменные табличные части
Функция ИзмененияДокумента(Объект, РеквизитыИсключения = Неопределено, ТабличныеЧастиИсключения = Неопределено) Экспорт
	
	Результат = Новый Структура;
	
	Если РеквизитыИсключения = Неопределено Тогда
		РеквизитыИсключения = Новый Структура;
	КонецЕсли;
	
	Если ТабличныеЧастиИсключения = Неопределено Тогда
		ТабличныеЧастиИсключения = Новый Структура;
	КонецЕсли;
	
	МетаданныеДокумента = Объект.Метаданные(); 
	
	ПолноеИмя = МетаданныеДокумента.ПолноеИмя();
	
	СтрокаНеограниченнойДлинны = Новый ОписаниеТипов("Строка", , , , Новый КвалификаторыСтроки(0));
	
	РеквизитыДокумента = Новый Структура;
	РеквизитыДокумента.Вставить("Дата");
	Для каждого Реквизит Из МетаданныеДокумента.Реквизиты Цикл
		Если СтрНайти(Реквизит.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если Реквизит.Тип = СтрокаНеограниченнойДлинны Тогда
			Продолжить;
		КонецЕсли;
		Если РеквизитыИсключения.Свойство(Реквизит.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыДокумента.Вставить(Реквизит.Имя);
	КонецЦикла;
	
	ТабличныеЧастиДокумента = Новый Структура;
	Для каждого ТабличнаяЧасть Из МетаданныеДокумента.ТабличныеЧасти Цикл
		Если СтрНайти(ТабличнаяЧасть.Имя, "Удалить") = 1 Тогда
			Продолжить;
		КонецЕсли;
		Если ТабличныеЧастиИсключения.Свойство(ТабличнаяЧасть.Имя) Тогда
			Продолжить;
		КонецЕсли;
		РеквизитыТабличнойЧасти = Новый Структура;
		Для каждого Реквизит Из ТабличнаяЧасть.Реквизиты Цикл
			ТипРеквизита =  Реквизит.Тип;
			Если ТипРеквизита = СтрокаНеограниченнойДлинны Тогда
				Продолжить;
			КонецЕсли; 
			РеквизитыТабличнойЧасти.Вставить(Реквизит.Имя);
		КонецЦикла;
		ТабличныеЧастиДокумента.Вставить(ТабличнаяЧасть.Имя, РеквизитыТабличнойЧасти);
	КонецЦикла;
	
	ТекстЗапроса= "ВЫБРАТЬ
		|	Таблица.Проведен КАК Проведен";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ); 
	КонецЦикла;
	
	ШаблонПоместить = "
	|ИЗ
	|	%1 КАК Таблица
	|ГДЕ
	|	Таблица.Ссылка = &Ссылка
	|";
	ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ПолноеИмя);
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий(); 
	
	ТаблицаИзмененныхРеквизитов = Новый ТаблицаЗначений;
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("Имя");
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("НовоеЗначение");
	ТаблицаИзмененныхРеквизитов.Колонки.Добавить("СтароеЗначение");
	Для каждого Реквизит Из РеквизитыДокумента Цикл
		Если Выборка[Реквизит.Ключ] <> Объект[Реквизит.Ключ] Тогда
			НоваяСтрока = ТаблицаИзмененныхРеквизитов.Добавить();
			НоваяСтрока.Имя = Реквизит.Ключ;
			НоваяСтрока.НовоеЗначение = Объект[Реквизит.Ключ];
			НоваяСтрока.СтароеЗначение = Выборка[Реквизит.Ключ];
		КонецЕсли;
	КонецЦикла;
	
	Если ТаблицаИзмененныхРеквизитов.Количество() > 0 Тогда
		Результат.Вставить("Реквизиты", ТаблицаИзмененныхРеквизитов);
	КонецЕсли;
	
	Для каждого ТабличнаяЧасть Из ТабличныеЧастиДокумента Цикл
		
		ТекстЗапроса = "ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонПоместить = "
		|ПОМЕСТИТЬ НоваяТаблица%1
		|ИЗ
		|	&%1 КАК Таблица
		|;
		|
		|////////////////////////////
		|";
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонПоместить, ТабличнаяЧасть.Ключ);
		
		ТекстОбъединенияНовая =
		"ВЫБРАТЬ
		|	Таблица.НомерСтроки КАК НомерСтроки";
		
		ТекстОбъединенияСтарая =
		"ВЫБРАТЬ
		|	-Таблица.НомерСтроки КАК НомерСтроки";
		
		ШаблонРеквизит = ",
		|	Таблица.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстОбъединенияНовая  = ТекстОбъединенияНовая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
			ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		
		ШаблонИзНовая = "
		|ИЗ
		|	НоваяТаблица%1 КАК Таблица";
		ТекстОбъединенияНовая = ТекстОбъединенияНовая + СтрШаблон(ШаблонИзНовая, ТабличнаяЧасть.Ключ);
		
		ШаблонИзСтарая = "
		|ИЗ
		|	%1.%2 КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
		ТекстОбъединенияСтарая = ТекстОбъединенияСтарая + СтрШаблон(ШаблонИзСтарая, ПолноеИмя, ТабличнаяЧасть.Ключ);
		
		ТекстЗапроса = ТекстЗапроса + 
		"ВЫБРАТЬ
		|	СУММА(ВложенныйЗапрос.НомерСтроки) КАК НомерСтроки";
		ШаблонРеквизит = ",
		|	ВложенныйЗапрос.%1 КАК %1";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонРеквизит, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "
		|ИЗ 
		|(" 
		+ Символы.ПС + ТекстОбъединенияНовая 
		+ Символы.ПС + " ОБЪЕДИНИТЬ ВСЕ "
		+ Символы.ПС + ТекстОбъединенияСтарая + ") КАК ВложенныйЗапрос
		|
		|СГРУППИРОВАТЬ ПО";
		
		ШаблонСгруппировать = "
		|	ВложенныйЗапрос.%1,";
		Для каждого Реквизит Из ТабличнаяЧасть.Значение Цикл
			ТекстЗапроса  = ТекстЗапроса + СтрШаблон(ШаблонСгруппировать, Реквизит.Ключ);
		КонецЦикла;
		ТекстЗапроса = ТекстЗапроса + "ИСТИНА
		|ИМЕЮЩИЕ 
		|	СУММА(ВложенныйЗапрос.НомерСтроки) <> 0";
		
		Запрос = Новый Запрос;
		Запрос.Текст = ТекстЗапроса;
		Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
		Запрос.УстановитьПараметр(ТабличнаяЧасть.Ключ, Объект[ТабличнаяЧасть.Ключ]);
		
		РезультатЗапроса = Запрос.Выполнить();
		Если НЕ РезультатЗапроса.Пустой() Тогда
			Если НЕ Результат.Свойство("ТабличныеЧасти") Тогда
				Результат.Вставить("ТабличныеЧасти", Новый Структура);
			КонецЕсли;
			Результат.ТабличныеЧасти.Вставить(ТабличнаяЧасть.Ключ, РезультатЗапроса.Выгрузить());
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Очищает реквизит "ИдентификаторДокумента" и колонки "ИдентификаторФинЗаписи", "ИдентификаторСтроки" в табличных частях документа.
//
// Параметры:
// 	Документ - ДокументОбъект - Документ с очищаемым идентификатором
// 	ИменаТЧ - Строка - Имена ТЧ, в которых нужно очистить идентификаторы, разделенные запятыми
// 	НайтиТЧПоМетаданным - Булево - Необходимость поиска состава обрабатываемых ТЧ по метаданным, если их список не передан в параметре ИменаТЧ
//
Процедура ОчиститьИдентификаторыДокумента(Документ, ИменаТЧ = "", НайтиТЧПоМетаданным = Ложь) Экспорт
	
	МетаданныеДокумента = Документ.Метаданные();
	
	Если НЕ ПустаяСтрока(ИменаТЧ) Тогда
		МассивТЧ = СтрРазделить(ИменаТЧ, ",", Ложь);
	ИначеЕсли НайтиТЧПоМетаданным Тогда
		МассивТЧ = Новый Массив();
		Для Каждого МетаданныеТЧ Из МетаданныеДокумента.ТабличныеЧасти Цикл
			Если МетаданныеТЧ.Реквизиты.Найти("ИдентификаторСтроки") <> Неопределено
			 Или МетаданныеТЧ.Реквизиты.Найти("ИдентификаторФинЗаписи") <> Неопределено Тогда
				МассивТЧ.Добавить(МетаданныеТЧ.Имя);
			КонецЕсли;
		КонецЦикла;
	Иначе
		МассивТЧ = Новый Массив();
	КонецЕсли;
	
	//Идентификатор документа
	Если МетаданныеДокумента.Реквизиты.Найти("ИдентификаторДокумента") <> Неопределено Тогда
		Документ.ИдентификаторДокумента = "";
	КонецЕсли;
	
	//Идентификаторы строк ТЧ
	Для Каждого ИмяТЧ Из МассивТЧ Цикл
		МетаданныеТЧ = МетаданныеДокумента.ТабличныеЧасти[ИмяТЧ];
		ИмяРеквизита = "ИдентификаторФинЗаписи";
		
		Если МетаданныеТЧ.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			ИмяРеквизита = "ИдентификаторСтроки";
		КонецЕсли;

		ТабличнаяЧасть = Документ[ИмяТЧ];
		
		Для Каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
			СтрокаТаблицы[ИмяРеквизита] = "";
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет реквизит "ИдентификаторДокумента" и колонки "ИдентификаторФинЗаписи", "ИдентификаторСтроки" в табличных частях документа значениями уникальных идентификаторов.
//
// Параметры:
// 	Документ - ДокументОбъект - Записываемый новый документ с идентификатором
// 	ИменаТЧ - Строка - Имена ТЧ, в которых нужно заполнить идентификаторы, разделенные запятыми
// 	НайтиТЧПоМетаданным - Булево - Необходимость поиска состава обрабатываемых ТЧ по метаданным, если их список не передан в параметре ИменаТЧ
//
Процедура ЗаполнитьИдентификаторыДокумента(Документ, ИменаТЧ = "", НайтиТЧПоМетаданным = Ложь) Экспорт
	
	МетаданныеДокумента = Документ.Метаданные();
	
	Если НЕ ПустаяСтрока(ИменаТЧ) Тогда
		МассивТЧ = СтрРазделить(ИменаТЧ, ",", Ложь);
	ИначеЕсли НайтиТЧПоМетаданным Тогда
		МассивТЧ = Новый Массив();
		Для Каждого МетаданныеТЧ Из МетаданныеДокумента.ТабличныеЧасти Цикл
			Если МетаданныеТЧ.Реквизиты.Найти("ИдентификаторСтроки") <> Неопределено
			 Или МетаданныеТЧ.Реквизиты.Найти("ИдентификаторФинЗаписи") <> Неопределено Тогда
				МассивТЧ.Добавить(МетаданныеТЧ.Имя);
			КонецЕсли;
		КонецЦикла;
	Иначе
		МассивТЧ = Новый Массив();
	КонецЕсли;
	
	Уникальность = Новый Соответствие;
	
	//Идентификатор документа
	Если МетаданныеДокумента.Реквизиты.Найти("ИдентификаторДокумента") <> Неопределено Тогда
		Если Не ЗначениеЗаполнено(Документ.ИдентификаторДокумента) Тогда
			Документ.ИдентификаторДокумента = Строка(Новый УникальныйИдентификатор);
		КонецЕсли;
		Уникальность.Вставить(Документ.ИдентификаторДокумента, Документ.ИдентификаторДокумента);
	КонецЕсли;
	
	//Идентификаторы строк ТЧ
	Для Каждого ИмяТЧ Из МассивТЧ Цикл
		МетаданныеТЧ = МетаданныеДокумента.ТабличныеЧасти[ИмяТЧ];
		ИмяРеквизита = "ИдентификаторФинЗаписи";
		
		Если МетаданныеТЧ.Реквизиты.Найти(ИмяРеквизита) = Неопределено Тогда
			ИмяРеквизита = "ИдентификаторСтроки";
		КонецЕсли;

		ТабличнаяЧасть = Документ[ИмяТЧ];
		
		Для Каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
			Если Не ЗначениеЗаполнено(СтрокаТаблицы[ИмяРеквизита])
				Или Уникальность[СтрокаТаблицы[ИмяРеквизита]] <> Неопределено Тогда
				// Идентификатор в строке не заполнен ИЛИ идентификатор встречался ранее
				СтрокаТаблицы[ИмяРеквизита] = Строка(Новый УникальныйИдентификатор);
			КонецЕсли;
			Уникальность.Вставить(СтрокаТаблицы[ИмяРеквизита], СтрокаТаблицы[ИмяРеквизита]);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет в переданной таблице значений колонку с переданным именем уникальными идентификаторами.
// Если колонки с таким именем не существует, то добавляет ее в таблицу значений.
//
// Параметры:
// 	ТаблЗначений - ТаблицаЗначений - обрабатываемая таблица значений
// 	ИмяКолонки - Строка - имя заполняемой колонки
//
Процедура ДобавитьИдентификаторыВТаблицуЗначений(ТаблЗначений, ИмяКолонки = "ИдентификаторФинЗаписи") Экспорт
	
	КолонкиТаблицы = ТаблЗначений.Колонки;
	
	Если КолонкиТаблицы.Найти(ИмяКолонки) = Неопределено Тогда
		КолонкиТаблицы.Добавить(ИмяКолонки, ОбщегоНазначения.ОписаниеТипаСтрока(36));
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы Из ТаблЗначений Цикл
		СтрокаТаблицы[ИмяКолонки] = Строка(Новый УникальныйИдентификатор);
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в указанную временную таблицу колонку с переданным именем с уникальными идентификаторами
//
// Параметры:
// 	ИмяТаблицы - Строка - Имя временной таблицы
// 	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - содержит изменяемую временную таблицу
// 	ИмяКолонки - Строка - Имя колонки с идентификатором, которую необходимо добавить
//
Процедура ДобавитьИдентификаторыВоВременнуюТаблицу(ИмяТаблицы, МенеджерВременныхТаблиц, ИмяКолонки = "ИдентификаторСтроки") Экспорт
	
	ПоляИсходнойВременнойТаблицы = Новый Массив;
	ПоляНовойВременнойТаблицы = Новый Массив;
	
	КолонкиВременнойТаблицы = МенеджерВременныхТаблиц.Таблицы[ИмяТаблицы].Колонки; // КолонкиВременнойТаблицыЗапроса - 
	Для каждого Колонка Из КолонкиВременнойТаблицы Цикл
		Если Колонка.Имя <> ИмяКолонки Тогда
			Поле = СтрШаблон("%1.%2 КАК %2", ИмяТаблицы, Колонка.Имя);
			ПоляИсходнойВременнойТаблицы.Добавить(Поле);
			ПоляНовойВременнойТаблицы.Добавить(Поле);
		КонецЕсли;
	КонецЦикла;
	
	Если КолонкиВременнойТаблицы.Найти("НомерЗаписи") = Неопределено Тогда
		ПоляИсходнойВременнойТаблицы.Добавить("АВТОНОМЕРЗАПИСИ() КАК НомерЗаписи");	
	КонецЕсли;
	
	ПоляНовойВременнойТаблицы.Добавить(СтрШаблон("ТаблицаИдентификаторов.Идентификатор КАК %1", ИмяКолонки));
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	&ПоляИсходнойВременнойТаблицы
	|ПОМЕСТИТЬ ИмяТаблицы_Подготовленная
	|ИЗ
	|	ИмяТаблицы КАК ИмяТаблицы
	|ИНДЕКСИРОВАТЬ ПО
	|	НомерЗаписи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ ИмяТаблицы
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ИмяТаблицы_Подготовленная.НомерЗаписи КАК НомерЗаписи
	|ИЗ
	|	ИмяТаблицы_Подготовленная КАК ИмяТаблицы_Подготовленная
	|";
	
	Разделитель = ",
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИмяТаблицы", ИмяТаблицы);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляИсходнойВременнойТаблицы", СтрСоединить(ПоляИсходнойВременнойТаблицы, Разделитель));
			
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Результаты = Запрос.ВыполнитьПакет();
	
	ТаблицаИдентификаторов = Результаты[Результаты.ВГраница()].Выгрузить();
	ДобавитьИдентификаторыВТаблицуЗначений(ТаблицаИдентификаторов, "Идентификатор");
	
	ТекстЗапроса = "
	|ВЫБРАТЬ
	|	ТаблицаИдентификаторов.НомерЗаписи КАК НомерЗаписи,
	|	ТаблицаИдентификаторов.Идентификатор КАК Идентификатор
	|ПОМЕСТИТЬ ТаблицаИдентификаторов
	|ИЗ
	|	&ТаблицаИдентификаторов КАК ТаблицаИдентификаторов
	|ИНДЕКСИРОВАТЬ ПО
	|	НомерЗаписи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	&ПоляНовойВременнойТаблицы
	|ПОМЕСТИТЬ ИмяТаблицы
	|ИЗ
	|	ИмяТаблицы_Подготовленная КАК ИмяТаблицы
	|	ЛЕВОЕ СОЕДИНЕНИЕ
	|		ТаблицаИдентификаторов КАК ТаблицаИдентификаторов
	|	ПО
	|		ИмяТаблицы.НомерЗаписи = ТаблицаИдентификаторов.НомерЗаписи
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ ИмяТаблицы_Подготовленная
	|;
	|
	|//////////////////////////////////////////////////////////////////////////////// 
	|УНИЧТОЖИТЬ ТаблицаИдентификаторов
	|";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИмяТаблицы", ИмяТаблицы);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляНовойВременнойТаблицы", СтрСоединить(ПоляНовойВременнойТаблицы, Разделитель));
			
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("ТаблицаИдентификаторов", ТаблицаИдентификаторов);
	Запрос.Выполнить();
	
КонецПроцедуры

// Возвращает количество записей во временной таблице
// 
// Параметры:
// 	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - 
// 	ИмяВременнойТаблицы - Строка -
// 	
// Возвращаемое значение:
// 	Число - Количество записей
//
Функция РазмерВременнойТаблицы(МенеджерВременныхТаблиц, ИмяВременнойТаблицы) Экспорт

	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;

	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КОЛИЧЕСТВО(*) КАК КоличествоСтрок
	|ИЗ
	|	&ИмяТаблицы КАК Т";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяТаблицы", ИмяВременнойТаблицы);

	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();

	Возврат Выборка.КоличествоСтрок;

КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПолученияПредставленияДанных

// Возвращает строковое представление документа для отображения в сообщениях.
//
// Параметры:
//	Ссылка - ДокументСсылка - Ссылка на документ
//	Номер - Строка - Номер документа
//	Дата - Дата - Дата документа
//
// Возвращаемое значение:
//	Строка - представление документа
Функция ПолучитьПредставлениеДокумента(Ссылка, Номер, Дата) Экспорт
	
	Возврат
		Ссылка.Метаданные().Синоним
		+ ?(ЗначениеЗаполнено(Номер), " " + Номер, "")
		+ ?(ЗначениеЗаполнено(Дата), " " + НСтр("ru = 'от'") + " " + Формат(Дата,"ДЛФ=D"), "");
	
КонецФункции

// Формирует представление результата поиска по строке.
// 
// Параметры:
//  Наименование - Строка - Наименование.
//  СтрокаПоиска - Строка - Строка поиска.
// 
// Возвращаемое значение:
//  ФорматированнаяСтрока - Представление результата поиска по строке.
//
Функция ПредставлениеРезультатаПоискаПоСтроке(Наименование, СтрокаПоиска) Экспорт

	ПозНачало = СтрНайти(ВРег(Наименование), ВРег(СтрокаПоиска));
	Если ПозНачало <> 0 Тогда
		
		ДлинаТекста = СтрДлина(СтрокаПоиска);
		ДлинаПредставления = СтрДлина(Наименование);
		
		ПредставлениеСсылки = 
			Новый ФорматированнаяСтрока(
				?(ПозНачало <> 1, Лев(Наименование, ПозНачало - 1), ""),
				Новый ФорматированнаяСтрока(Сред(Наименование, ПозНачало, ДлинаТекста), Новый Шрифт(,, Истина), ЦветаСтиля.ЦветТекстаЗаголовокОтчетаВТакси),
				?(ДлинаПредставления > (ПозНачало + ДлинаТекста - 1) , Сред(Наименование, ПозНачало + ДлинаТекста), ""));
				
									
	Иначе
		
		ПредставлениеСсылки = Наименование;
		
	КонецЕсли; 

	Возврат ПредставлениеСсылки;
	
КонецФункции

#КонецОбласти

#Область ПрочиеПроцедурыИФункции

// Возвращает метаданные объекта по полному имени объекта метаданных. Не обрабатываются точки маршрутов бизнес-процессов.
//
// Параметры:
//  ПолноеИмя - Строка - Полное имя объекта метаданных, например, "Справочник.Организации".
//
// Возвращаемое значение:
//  ОбъектМетаданных -
// 
Функция МетаданныеОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	ЧастиИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмя, ".");
	
	КлассОМ = ЧастиИмени[0];
	ИмяОМ   = ЧастиИмени[1];
	
	Если      ВРег(КлассОМ) = "ПЛАНОБМЕНА" Тогда
		Возврат Метаданные.ПланыОбмена[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "СПРАВОЧНИК" Тогда
		Возврат Метаданные.Справочники[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ДОКУМЕНТ" Тогда
		Возврат Метаданные.Документы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЖУРНАЛДОКУМЕНТОВ" Тогда
		Возврат Метаданные.ЖурналыДокументов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЕРЕЧИСЛЕНИЕ" Тогда
		Возврат Метаданные.Перечисления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОТЧЕТ" Тогда
		Возврат Метаданные.Отчеты[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБРАБОТКА" Тогда
		Возврат Метаданные.Обработки[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВХАРАКТЕРИСТИК" Тогда
		Возврат Метаданные.ПланыВидовХарактеристик[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНСЧЕТОВ" Тогда
		Возврат Метаданные.ПланыСчетов[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПЛАНВИДОВРАСЧЕТА" Тогда
		Возврат Метаданные.ПланЫВидовРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРСВЕДЕНИЙ" Тогда
		Возврат Метаданные.РегистрыСведений[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРНАКОПЛЕНИЯ" Тогда
		Возврат Метаданные.РегистрыНакопления[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРБУХГАЛТЕРИИ" Тогда
		Возврат Метаданные.РегистрыБухгалтерии[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "РЕГИСТРРАСЧЕТА" Тогда
		Возврат Метаданные.РегистрыРасчета[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "БИЗНЕСПРОЦЕСС" Тогда
		Возврат Метаданные.БизнесПроцессы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ЗАДАЧА" Тогда
		Возврат Метаданные.Задачи[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "КОНСТАНТА" Тогда
		Возврат Метаданные.Константы[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ПОСЛЕДОВАТЕЛЬНОСТЬ" Тогда
		Возврат Метаданные.Последовательности[ИмяОМ];
		
	ИначеЕсли ВРег(КлассОМ) = "ОБЩИЙМОДУЛЬ" Тогда
		Возврат Метаданные.ОбщиеМодули[ИмяОМ];
		
	Иначе
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Неизвестный тип объекта метаданных (%1)'"), КлассОМ);
	КонецЕсли;
	
КонецФункции

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 		Объект - ДокументОбъект, СправочникОбъект - Проверяемый объект.
// 		МассивПроверяемыхРеквизитов - Массив Из Строка - Массив проверяемых реквизитов.
//
// Возвращаемое значение:
// 		Булево - Истина, если значение хотя бы одного реквизита не заполнено, иначе Ложь.
//
Функция ПроверитьЗаполнениеРеквизитовОбъекта(Объект, МассивПроверяемыхРеквизитов) Экспорт
	
	Перем ПроверяемыеРеквизитыТЧ;
	Отказ = Ложь;
	
	// Получение метаданных объекта
	МетаданныеОбъекта = Объект.Ссылка.Метаданные();
	
	// Создание структуры стандартных реквизитов
	СтандартныеРеквизиты = Новый Структура;
	Для Каждого Реквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		СтандартныеРеквизиты.Вставить(Реквизит.Имя, ?(ЗначениеЗаполнено(Реквизит.Представление()), Реквизит.Представление(), Реквизит.Имя));
	КонецЦикла;
	
	// Создание структуры для хранения имен табличных частей и проверяемых реквизитов в них.
	// 		Ключ -  Имя табличной части
	// 		Значение - Массив - Массив строк, реквизитов этой табличной части для проверки.
	ТабличныеЧасти = Новый Структура;
	
	// Создание шаблонов сообщений об ошибках не заполненных реквизитов и реквизитов табличных частей.
	ШаблонОшибкиРеквизита = НСтр("ru = 'Поле ""%ИмяРеквизита%"" не заполнено'");
	ШаблонОшибкиТЧ = НСтр("ru = 'Не введено ни одной строки в список ""%ИмяРеквизита%""'");
	ШаблонОшибкиРеквизитаТЧ = НСтр("ru = 'Не заполнена колонка ""%ИмяРеквизита%"" в строке %НомерСтроки% списка ""%ИмяТабличнойЧасти%""'");
	
	// Проверка реквизитов объекта и заполнение структуры по реквизитам табличных частей.
	Для Каждого Реквизит Из МассивПроверяемыхРеквизитов Цикл
		
		ПозицияТочки = СтрНайти(Реквизит,".");
		
		Если ПозицияТочки > 0 Тогда // В случае если указан реквизит табличной части
			
			ДлинаСтроки       = СтрДлина(Реквизит);
			ИмяТабличнойЧасти = Лев(Реквизит, ПозицияТочки-1);
			ИмяРеквизита      = Прав(Реквизит, ДлинаСтроки - ПозицияТочки);
			
			// Сохранение проверяемого реквизита табличной части в структуру
			Если НЕ ТабличныеЧасти.Свойство(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ) Тогда
				ПроверяемыеРеквизитыТЧ = Новый Массив;
				ТабличныеЧасти.Вставить(ИмяТабличнойЧасти, ПроверяемыеРеквизитыТЧ);
			КонецЕсли;
			ПроверяемыеРеквизитыТЧ.Добавить(ИмяРеквизита);
			
		Иначе // В случае если указан реквизит объекта
			
			Если Не ЗначениеЗаполнено(Объект[Реквизит]) Тогда
				
				Если МетаданныеОбъекта.Реквизиты.Найти(Реквизит) <> Неопределено Тогда // Если указано имя реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						МетаданныеОбъекта.Реквизиты[Реквизит].Синоним);
				ИначеЕсли СтандартныеРеквизиты.Свойство(Реквизит) Тогда // Если указано имя стандартного реквизита
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизита, "%ИмяРеквизита%",
						СтандартныеРеквизиты[Реквизит]);
				Иначе // Если указано имя табличной части
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиТЧ, "%ИмяРеквизита%",
						МетаданныеОбъекта.ТабличныеЧасти[Реквизит].Синоним);
				КонецЕсли;
				
				ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
					ТекстОшибки,
					Объект,
					Реквизит,
					,
					Отказ);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверка реквизитов в табличных частях
	Для Каждого ТабличнаяЧасть Из ТабличныеЧасти Цикл
		
		ИмяТабличнойЧасти = ТабличнаяЧасть.Ключ;
		ТабличнаяЧастьОбъекта = Объект[ТабличнаяЧасть.Ключ];
		МассивРеквизитов = ТабличнаяЧасть.Значение;
		
		// Цикл по всем строкам табличной части.
		Для НомерСтроки=0 По ТабличнаяЧастьОбъекта.Количество()-1 Цикл
			
			// Цикл по всем проверяемым реквизитам для текущей табличной части.
			Для НомерРеквизита=0 По МассивРеквизитов.Количество()-1 Цикл
				
				ИмяРеквизита = МассивРеквизитов[НомерРеквизита];
				
				Если Не ЗначениеЗаполнено(ТабличнаяЧастьОбъекта[НомерСтроки][ИмяРеквизита]) Тогда
					
					ТекстОшибки = СтрЗаменить(ШаблонОшибкиРеквизитаТЧ, "%ИмяРеквизита%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Реквизиты[ИмяРеквизита].Синоним);
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%НомерСтроки%", Формат(НомерСтроки+1, "ЧГ=0"));
					ТекстОшибки = СтрЗаменить(ТекстОшибки, "%ИмяТабличнойЧасти%", МетаданныеОбъекта.ТабличныеЧасти[ИмяТабличнойЧасти].Синоним);
					
					ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
						ТекстОшибки,
						Объект,
						ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТабличнойЧасти, НомерСтроки+1, ИмяРеквизита),
						,
						Отказ);
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	МассивПроверяемыхРеквизитов.Очистить();
	
	Возврат Отказ;
	
КонецФункции // ПроверитьЗаполнениеРеквизитовОбъекта()

// Осуществляет проверку соответствия организации документа и хозяйственной операции.
//
// Параметры:
// 	ДокументОбъект - ДокументОбъект - Проверяемый объект
//	Отказ - Булево - Флаг отказа записи
//
Процедура ПроверитьПравильностьУказанияХозяйственнойОперации(ДокументОбъект, Отказ) Экспорт
	
	Если ДокументОбъект.Организация = Справочники.Организации.УправленческаяОрганизация
	   И (ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.РеализацияКлиентуРеглУчет
	 ИЛИ ДокументОбъект.ХозяйственнаяОперация = Перечисления.ХозяйственныеОперации.ЗакупкаУПоставщикаРеглУчет) Тогда
	 
		Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В документе нельзя указывать операцию %1 и управленческую организацию'"),
			ДокументОбъект.ХозяйственнаяОперация);
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			Текст,
			ДокументОбъект,
			"ХозяйственнаяОперация",
			,
			Отказ);
	 
	КонецЕсли;
	
КонецПроцедуры // ПроверитьПравильностьУказанияХозяйственнойОперации()

// Устарела. Осуществляет проверку заполненности проверяемых реквизитов. Использовать ОбщегоНазначенияУТ.ПроверитьВозможностьВводаНаОснованииСПараметрами.
//
// Параметры:
// 	Документ - ДокументСсылка - Документ, на основании которого осуществляется ввод
// 	Статус - ПеречислениеСсылка - Статус документ, на основании которого осуществляется ввод
// 	ЕстьОшибкиПроведен - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// 	ЕстьОшибкиСтатус   - Булево - Если Истина - документ, на основании которого осуществляется ввод, имеет некорректный статус
// 	МассивДопустимыхСтатусов - Массив - Массив допустимых статусов
// 	СоглашениеДоступноВнешнемуПользователю - Булево - Если Истина, документ на основании которого осуществляется ввод имеет соглашение доступное внешнему пользователю.
// 	ПрерыватьВыполнение - Булево - Если Истина, то при наличии ошибки будет вызвано исключение, если Ложь, то просто выводится сообщение.
//
Процедура ПроверитьВозможностьВводаНаОсновании(Документ,
	                                           Статус = Неопределено,
	                                           ЕстьОшибкиПроведен = Ложь,
	                                           ЕстьОшибкиСтатус = Ложь,
	                                           МассивДопустимыхСтатусов = Неопределено,
	                                           СоглашениеДоступноВнешнемуПользователю = Неопределено) Экспорт
	
	ПараметрыПроверки = ПараметрыПроверкиВозможностиВводаНаОсновании();
	ПараметрыПроверки.Статус = Статус;
	ПараметрыПроверки.ЕстьОшибкиПроведен = ЕстьОшибкиПроведен;
	ПараметрыПроверки.ЕстьОшибкиСтатус = ЕстьОшибкиСтатус;
	ПараметрыПроверки.МассивДопустимыхСтатусов = МассивДопустимыхСтатусов;
	ПараметрыПроверки.СоглашениеДоступноВнешнемуПользователю = СоглашениеДоступноВнешнемуПользователю;
	
	ПроверитьВозможностьВводаНаОснованииСПараметрами(Документ, ПараметрыПроверки);
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОсновании()

// Осуществляет проверку заполненности проверяемых реквизитов.
// 
// Параметры:
//  Документ - ДокументСсылка - Документ, на основании которого осуществляется ввод
//  ПараметрыПроверки - см. ПараметрыПроверкиВозможностиВводаНаОсновании
Процедура ПроверитьВозможностьВводаНаОснованииСПараметрами(Документ, ПараметрыПроверки) Экспорт
	
	Если ПараметрыПроверки.ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru = 'Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		
		Если ПараметрыПроверки.ПрерыватьВыполнение Тогда
			ВызватьИсключение ТекстОшибки;
		Иначе
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
		КонецЕсли;
	КонецЕсли;
	
	Если ПараметрыПроверки.ЕстьОшибкиСтатус Тогда
		
		Если Не ЗначениеЗаполнено(ПараметрыПроверки.МассивДопустимыхСтатусов) Тогда
			ТекстОшибки = НСтр("ru = 'Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании запрещен.'");
		ИначеЕсли ТипЗнч(ПараметрыПроверки.МассивДопустимыхСтатусов) = Тип("Массив") Тогда
			
			Если ПараметрыПроверки.МассивДопустимыхСтатусов.Количество() = 1 Тогда
				ТекстОшибки = НСтр("ru = 'Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен только в статусе ""%СтрокаДопустимыхСтатусов%"".'");
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", ПараметрыПроверки.МассивДопустимыхСтатусов[0]);
			Иначе
				ТекстОшибки = НСтр("ru = 'Документ %Документ% находится в статусе ""%Статус%"". Ввод на основании разрешен только в статусах ""%СтрокаДопустимыхСтатусов%"".'");
				ТекстОшибки = СтрЗаменить(ТекстОшибки, "%СтрокаДопустимыхСтатусов%", СтрСоединить(ПараметрыПроверки.МассивДопустимыхСтатусов, """, """));
			КонецЕсли;
			
		КонецЕсли;
		
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Статус%",   ПараметрыПроверки.Статус);
		
		Если ПараметрыПроверки.ПрерыватьВыполнение Тогда
			ВызватьИсключение ТекстОшибки;
		Иначе
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОбщегоНазначенияУТКлиентСервер.АвторизованВнешнийПользователь() И НЕ ПараметрыПроверки.СоглашениеДоступноВнешнемуПользователю = Истина Тогда
		
		ТекстОшибки = НСтр("ru = 'Соглашение документа %Документ% недоступно для работы при самообслуживании. Ввод на основании запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		
		Если ПараметрыПроверки.ПрерыватьВыполнение Тогда
			ВызватьИсключение ТекстОшибки;
		Иначе
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ИсправлениеДокументов.ЕстьИсправлениеИлиСторно(Документ) Тогда
		
		ТекстОшибки = НСтр("ru = 'Документ %Документ% аннулирован. Ввод на основании запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
		
		Если ПараметрыПроверки.ПрерыватьВыполнение Тогда
			ВызватьИсключение ТекстОшибки;
		Иначе
			ОбщегоНазначения.СообщитьПользователю(ТекстОшибки);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОсновании()

// Параметры проверки возможности ввода на основании.
//
// Возвращаемое значение:
//  Структура:
//  * Статус - ПеречислениеСсылка - Статус документ, на основании которого осуществляется ввод
//  * ЕстьОшибкиПроведен - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
//  * ЕстьОшибкиСтатус   - Булево - Если Истина - документ, на основании которого осуществляется ввод, имеет некорректный статус
//  * МассивДопустимыхСтатусов - Массив - Массив допустимых статусов
//  * СоглашениеДоступноВнешнемуПользователю - Булево - Если Истина, документ на основании которого осуществляется ввод имеет соглашение доступное внешнему пользователю.
//  * ПрерыватьВыполнение - Булево - Если Истина, то при наличии ошибки будет вызвано исключение, если Ложь, то просто выводится сообщение.
//
Функция ПараметрыПроверкиВозможностиВводаНаОсновании() Экспорт
	
	ПараметрыПроверки = Новый Структура;
	ПараметрыПроверки.Вставить("Статус", Неопределено);
	ПараметрыПроверки.Вставить("ЕстьОшибкиПроведен", Ложь);
	ПараметрыПроверки.Вставить("ЕстьОшибкиСтатус", Ложь);
	ПараметрыПроверки.Вставить("МассивДопустимыхСтатусов", Неопределено);
	ПараметрыПроверки.Вставить("СоглашениеДоступноВнешнемуПользователю", Неопределено);
	ПараметрыПроверки.Вставить("ПрерыватьВыполнение", Истина);
	
	Возврат ПараметрыПроверки;
	
КонецФункции

// Осуществляет проверку возможности ввода документа на основании распоряжения по хозяйственной операции.
//
// Параметры:
//	ДокументОснование	- ДокументСсылка - документ, на основании которого осуществляется ввод.
//	ИмяДокумента		- Строка - имя документа, для которого определяются допустимые операции.
//	ХозяйственнаяОперация- ПеречислениеСсылка.ХозяйственныеОперации	- хозяйственная операция документа, 
//											на основании которого осуществляется ввод.
//	ПредставлениеДокумента - Строка - 
//	                       - Неопределено - Представление документа в информационной базе.
//
Процедура ПроверитьВозможностьВводаНаОснованииПоОперации(ДокументОснование,
							ИмяДокумента,
							ХозяйственнаяОперация,
							ПредставлениеДокумента = Неопределено) Экспорт
	
	ОперацииДокумента = ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента);
	
	Если ОперацииДокумента.Найти(ХозяйственнаяОперация) = Неопределено Тогда
		СинонимДокумента = ?(ЗначениеЗаполнено(ПредставлениеДокумента),
					ПредставлениеДокумента,
					Метаданные.Документы[ИмяДокумента].Синоним);
		
		ТекстОшибки = НСтр("ru = 'Невозможно оформить документ ""%1"" на основании распоряжения %2 с операцией ""%3"".'");
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстОшибки,
											СинонимДокумента,
											ДокументОснование,
											ХозяйственнаяОперация);
		
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// Документ                            - ДокументСсылка - Документ, на основании которого осуществляется ввод
// ЕстьОшибкиПроведен                  - Булево - Если Истина - документ, на основании которого осуществляется ввод, не проведен
// ЕстьОшибкиВернутьМногооборотнуюТару - Булево - Если Истина - по документу, на основании которого осуществляется ввод,
//                                                тара не возвратная.
//
Процедура ПроверитьВозможностьВводаНаОснованииВыкупаТары(Документ, ЕстьОшибкиПроведен, ЕстьОшибкиВернутьМногооборотнуюТару) Экспорт
	
	Если ЕстьОшибкиПроведен Тогда
		
		ТекстОшибки = НСтр("ru = 'Документ %Документ% не проведен. Ввод на основании непроведенного документа запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	ИначеЕсли ЕстьОшибкиВернутьМногооборотнуюТару Тогда
		
		ТекстОшибки = НСтр("ru = 'В документе %Документ% не стоит признак возврата многооборотной тары. Ввод на основании запрещен.'");
		ТекстОшибки = СтрЗаменить(ТекстОшибки, "%Документ%", Документ);
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// ЕстьОшибкиТиповое  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - типовое
// ЭтоАгентскиеУслуги  - Булево - Если Истина - соглашение, на основании которого осуществляется ввод - соглашение по
//                                оказанию агентских услуг.
//
Процедура ПроверитьВозможностьВводаНаОснованииСоглашения(ЕстьОшибкиТиповое = Ложь, ЭтоАгентскиеУслуги = Ложь) Экспорт
	
	Если ЕстьОшибкиТиповое Тогда
		
		ТекстОшибки = НСтр("ru = 'Ввод на основании типового соглашения с клиентом запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
	Если ЭтоАгентскиеУслуги Тогда
		
		ТекстОшибки = НСтр("ru = 'Ввод на основании типового соглашения по оказанию агентских услуг запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСоглашения()

// Осуществляет проверку заполненности проверяемых реквизитов.
//
// Параметры:
// 	Партнер - СправочникСсылка.Партнеры - Партнер из сделки по продаже.
//
Процедура ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже(Партнер) Экспорт
	
	Если Не ЗначениеЗаполнено(Партнер) Тогда
		
		ТекстОшибки = НСтр("ru = 'В сделке не указан клиент, ввод на основании запрещен.'");
	
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецПроцедуры // ПроверитьВозможностьВводаНаОснованииСделкиПоПродаже()

// Устанавливает или сбрасывает флаг Согласован у справочника.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// 	СправочникОбъект - СправочникОбъект - Справочник, в котором необходимо изменить флаг Согласован
// 	СтатусНеСогласован - ПеречислениеСсылка - Статус документа, в котором флаг Согласован должен быть сброшен.
//
Процедура ИзменитьПризнакСогласованностиСправочника(СправочникОбъект, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	// Справочник не имеет статуса
	Если СтатусНеСогласован = Неопределено Тогда
		
		Если Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	// Справочник имеет статус, в котором проведенный справочник не согласован
	Иначе
		
		Если СправочникОбъект.Статус = СтатусНеСогласован И СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Ложь;
		ИначеЕсли СправочникОбъект.Статус <> СтатусНеСогласован И Не СправочникОбъект.Согласован Тогда
			СправочникОбъект.Согласован = Истина;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиСправочника()

// Устанавливает или сбрасывает флаг Согласован у документа.
// Вызывается из процедуры ПередЗаписью документа.
//
// Параметры:
// 	ДокументОбъект - ДокументОбъект - Документ, в котором необходимо изменить флаг Согласован
// 	РежимЗаписи - РежимЗаписиДокумента - Режим записи документа
// 	СтатусНеСогласован - ПеречислениеСсылка -  Статус документа, в котором флаг Согласован должен быть сброшен.
//
Процедура ИзменитьПризнакСогласованностиДокумента(ДокументОбъект, Знач РежимЗаписи, Знач СтатусНеСогласован = Неопределено) Экспорт
	
	Если РежимЗаписи = РежимЗаписиДокумента.Запись
	 ИЛИ РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
		
		Если ДокументОбъект.Согласован Тогда
			ДокументОбъект.Согласован = Ложь;
		КонецЕсли;
		
	ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
		
		// Документ не имеет статуса
		Если СтатусНеСогласован = Неопределено Тогда
		
			Если Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		// Документ имеет статус из массива, в которых проведенный документ не согласован
		ИначеЕсли ТипЗнч(СтатусНеСогласован) = Тип("Массив") Тогда
			
			Если ДокументОбъект.Согласован Тогда
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						
						ДокументОбъект.Согласован = Ложь;
						Прервать;
						
					КонецЕсли;
					
				КонецЦикла;
				
			Иначе
				
				ДокументСогласован = Истина;
				
				Для Каждого ТекСтатус Из СтатусНеСогласован Цикл
					
					Если ДокументОбъект.Статус = ТекСтатус Тогда
						ДокументСогласован = Ложь;
					КонецЕсли;
					
				КонецЦикла;
				
				Если ДокументСогласован Тогда
					ДокументОбъект.Согласован = Истина;
				КонецЕсли;
				
			КонецЕсли;
			
		// Документ имеет статус, в котором проведенный документ не согласован
		Иначе
			
			Если ДокументОбъект.Статус = СтатусНеСогласован И ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Ложь;
			ИначеЕсли ДокументОбъект.Статус <> СтатусНеСогласован И Не ДокументОбъект.Согласован Тогда
				ДокументОбъект.Согласован = Истина;
			КонецЕсли;
			
		КонецЕсли;

	КонецЕсли;
	
КонецПроцедуры // ИзменитьПризнакСогласованностиДокумента()

// Настраивает подключаемое оборудование в форме, устанавливает флаг ИспользоватьПодключаемоеОборудование в форме.
// 
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - Форма, в которой необходимо настроить подключаемое оборудование.
//   ПрефиксыЭлементовФормы - Строка - 
//	                        - Массив Из Строка - ПрефиксыЭлементовФормы
//
Процедура НастроитьПодключаемоеОборудование(Форма, ПрефиксыЭлементовФормы = "Товары") Экспорт
	
	ТипыПодключенногоОборудования = ПодключаемоеОборудованиеУТПовтИсп.ТипыПодключенногоОборудования();
	
	Форма.ИспользоватьПодключаемоеОборудование = ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования);
	
	ЕстьТСД  =
		ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Найти(Перечисления.ТипыПодключаемогоОборудования.ТерминалСбораДанных) <> Неопределено;
	ЕстьВесы =
		ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Найти(Перечисления.ТипыПодключаемогоОборудования.ЭлектронныеВесы) <> Неопределено;
		
	Если ЗначениеЗаполнено(ПрефиксыЭлементовФормы) Тогда
		МассивПрефиксыЭлементовФормы = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПрефиксыЭлементовФормы, ",");
	Иначе
		МассивПрефиксыЭлементовФормы = Новый Массив;
		МассивПрефиксыЭлементовФормы.Добавить(ПрефиксыЭлементовФормы);
	КонецЕсли;
	
	Для Каждого Префикс Из МассивПрефиксыЭлементовФормы Цикл
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ЗагрузитьДанныеИзТСД",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьТСД);
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ВыгрузитьДанныеВТСД",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьТСД);
		
		ОбщегоНазначенияУТКлиентСервер.УстановитьСвойствоЭлементаФормы(
			Форма.Элементы,
			Префикс + "ПолучитьВес",
			"Видимость",
			Форма.ИспользоватьПодключаемоеОборудование И ЕстьВесы);
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет, что включена ф.о "Использовать подключаемое оборудование", настроено ли оборудование и авторизовался пользователь.
// 
// Параметры:
// 	ТипыПодключенногоОборудования - ПеречислениеСсылка.ТипыПодключаемогоОборудования - 
//
// Возвращаемое значение:
// 	Булево - 
Функция ИспользоватьПодключаемоеОборудование(ТипыПодключенногоОборудования = Неопределено) Экспорт
	
	ИспользоватьПодключаемоеОборудование = ПолучитьФункциональнуюОпцию("ИспользоватьПодключаемоеОборудование");
	ПользовательАвторизовался 			 = ТипЗнч(Пользователи.АвторизованныйПользователь()) = Тип("СправочникСсылка.Пользователи");
	
	Если ТипыПодключенногоОборудования = Неопределено Тогда
		ТипыПодключенногоОборудования = ПодключаемоеОборудованиеУТПовтИсп.ТипыПодключенногоОборудования();
	КонецЕсли;
	
	Возврат
		ИспользоватьПодключаемоеОборудование
		И ПользовательАвторизовался
		И ТипыПодключенногоОборудования <> Неопределено
		И ТипыПодключенногоОборудования.Количество() > 0;
												 
КонецФункции

// Возвращает список пользователей, имеющих роли, указанные в качестве параметра
//
// Параметры:
// 		МассивРолей - Массив из Строка - массив с именами ролей
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя.
// 
//	Возвращаемое значение:
//		СписокЗначений Из СправочникСсылка.Пользователи -
//
Функция ПользователиСДоступнымиРолями(МассивРолей, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	СписокПользователей = Новый СписокЗначений;
	Если ПредставлениеТекущегоПользователя = Неопределено Тогда
		ПредставлениеТекущегоПользователя = НСтр("ru = '<Мои документы>'");
	КонецЕсли;
	
	// Запрос получения списка всех пользователей. Выполняется в привилегированном режиме.
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ПрофилиГруппДоступаРоли.Ссылка КАК Ссылка
	|ПОМЕСТИТЬ ПрофилиГруппДоступа
	|ИЗ
	|	Справочник.ПрофилиГруппДоступа.Роли КАК ПрофилиГруппДоступаРоли
	|ГДЕ
	|	ПрофилиГруппДоступаРоли.Роль.Имя В(&МассивРолей)
	|
	|СГРУППИРОВАТЬ ПО
	|	ПрофилиГруппДоступаРоли.Ссылка
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Ссылка
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь) КАК Пользователь
	|ИЗ
	|	Справочник.ГруппыДоступа.Пользователи КАК ГруппыДоступаПользователи
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ГруппыПользователей.Состав КАК ГруппыПользователейСостав
	|		ПО ГруппыДоступаПользователи.Пользователь = ГруппыПользователейСостав.Ссылка
	|ГДЕ
	|	ГруппыДоступаПользователи.Ссылка.Профиль В
	|			(ВЫБРАТЬ
	|				ПрофилиГруппДоступа.Ссылка
	|			ИЗ
	|				ПрофилиГруппДоступа КАК ПрофилиГруппДоступа)
	|
	|СГРУППИРОВАТЬ ПО
	|	ЕСТЬNULL(ГруппыПользователейСостав.Пользователь, ГруппыДоступаПользователи.Пользователь)";
	
	Запрос.УстановитьПараметр("МассивРолей", МассивРолей);
	
	МассивВсехПользователей = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Пользователь");
	
	УстановитьПривилегированныйРежим(Ложь);
	
	// Запрос получения списка "разрешенных" пользователей
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Пользователи.Ссылка КАК Пользователь
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.Ссылка В(&МассивПользователей)
	|	И Пользователи.ПометкаУдаления = ЛОЖЬ
	|	И Пользователи.Недействителен = ЛОЖЬ
	|
	|УПОРЯДОЧИТЬ ПО
	|	Пользователи.Наименование";
	Запрос.УстановитьПараметр("МассивПользователей", МассивВсехПользователей);
	
	ТекущийПользователь = Пользователи.ТекущийПользователь();
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		Если ТекущийПользователь = Выборка.Пользователь Тогда
			СписокПользователей.Вставить(0, Выборка.Пользователь, ПредставлениеТекущегоПользователя);
		Иначе
			СписокПользователей.Добавить(Выборка.Пользователь);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СписокПользователей;
	
КонецФункции

// Возвращает список пользователей, имеющих право на изменение объекта метаданных
//
// Параметры:
// 		ОбъектМетаданных - ОбъектМетаданных - Объект метаданных, на которые проверяются права доступа
// 		ПредставлениеТекущегоПользователя - Строка - представление текущего пользователя.
// 
//	Возвращаемое значение:
//		СписокЗначений Из СправочникСсылка.Пользователи.
//
Функция ПолучитьСписокПользователейСПравомДобавления(ОбъектМетаданных, ПредставлениеТекущегоПользователя = Неопределено) Экспорт
	
	ИмяОбъектаМетаданных = ОбъектМетаданных.ПолноеИмя();
	МассивРолей = ПраваПользователяПовтИсп.ИменаРолейСПравомДобавления(ИмяОбъектаМетаданных);
	
	Если НЕ ЗначениеЗаполнено(МассивРолей) Тогда
		Возврат Новый СписокЗначений;
	КонецЕсли;
	
	Возврат ПользователиСДоступнымиРолями(МассивРолей, ПредставлениеТекущегоПользователя);;
	
КонецФункции

// Возвращает массив с уникальными значениями из колонки таблицы
//
// Параметры:
//  Таблица			 - ТаблицаЗначений -
//					 - ДанныеФормыСтруктура - 
//  ИмяКолонки		 - Строка -
//  ПараметрыОтбора	 - Структура - 
// 
// Возвращаемое значение:
// 	Массив -
//
Функция УникальныеЗначенияИзКолонкиТаблицы(Таблица, ИмяКолонки, ПараметрыОтбора = Неопределено) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ОбрабатываемаяТаблица = Таблица.Скопировать(ПараметрыОтбора, ИмяКолонки);
	Иначе
		ОбрабатываемаяТаблица = Таблица.Выгрузить(ПараметрыОтбора, ИмяКолонки);
	КонецЕсли;
		
	ОбрабатываемаяТаблица.Свернуть(ИмяКолонки);
	Возврат ОбрабатываемаяТаблица.ВыгрузитьКолонку(0);
	
КонецФункции

// Удаляет указанные строки из таблицы значений.
// 
// Параметры:
//	Таблица - ТаблицаЗначений - обрабатываемая таблица
//	Строки  - Массив Из СтрокаТаблицыЗначений - Массив удаляемых строк
//
Процедура УдалитьСтрокиТаблицыЗначений(Таблица, Строки) Экспорт
	
	Для Каждого СтрокаТаблицы Из Строки Цикл
		Таблица.Удалить(СтрокаТаблицы);
	КонецЦикла;
	
КонецПроцедуры

// Удаляет строки из таблицы значений с учетом переданного отбора.
// 
// Параметры:
//	Таблица 			  - ТаблицаЗначений - обрабатываемая таблица
//	СтруктураПоиска 	  - Структура - структура поиска строк, см. описание метода НайтиСтроки таблицы значений
//	УдалятьПопавшиеВОтбор - Булево - если указать Ложь, то будут удалены все строки, не входящие в отбор.
//
Процедура НайтиИУдалитьСтрокиТаблицыЗначений(Таблица, СтруктураПоиска, УдалятьПопавшиеВОтбор = Истина) Экспорт
	
	Строки = Таблица.НайтиСтроки(СтруктураПоиска);
	
	Если НЕ УдалятьПопавшиеВОтбор Тогда
		
		Если Строки.Количество() = Таблица.Количество() Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = 0 Тогда
			Таблица.Очистить();
		Иначе
			
			УдаляемыеСтроки = Новый Массив;
			
			Для Каждого СтрокаТаблицы Из Таблица Цикл
				
				Если Строки.Найти(СтрокаТаблицы) = Неопределено Тогда
					УдаляемыеСтроки.Добавить(СтрокаТаблицы); // строка не входит в переданный отбор
				КонецЕсли;
				
			КонецЦикла;
			
			УдалитьСтрокиТаблицыЗначений(Таблица, УдаляемыеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Если Строки.Количество() = 0 Тогда
			Возврат; // нечего удалять
		ИначеЕсли Строки.Количество() = Таблица.Количество() Тогда
			Таблица.Очистить();
		Иначе
			УдалитьСтрокиТаблицыЗначений(Таблица, Строки);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция проверяет наличие согласующего по указанной роли в регистре сведений "Исполнители задач".
//
// Параметры:
//	ПроверяемаяРоль - СправочникСсылка.РолиИсполнителей - Элемент справочника РолиИсполнителей.
// 
// Возвращаемое значение:
// 	Булево -
Функция ПроверитьСогласующегоБизнесПроцесс(ПроверяемаяРоль) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ИсполнителиЗадач.Исполнитель КАК ЕстьИсполнитель
		|ИЗ
		|	РегистрСведений.ИсполнителиЗадач КАК ИсполнителиЗадач
		|ГДЕ
		|	ИсполнителиЗадач.РольИсполнителя =&РольИсполнителя";

	Запрос.УстановитьПараметр("РольИсполнителя", ПроверяемаяРоль);
	Результат = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = Результат.Выбрать();

	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;
КонецФункции // ПроверитьСогласующегоБизнесПроцесс()

// Функция раскладывает переданный массив ссылок в соответствие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив Из ЛюбаяСсылка - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соответствие - Соотвествие типов ссылкам.
//			Ключ - полное имя типа ссылки.
//	        Значение - Массив Из ЛюбаяСсылка - ссылок этого типа.
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта); // Массив - 
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

// Возвращает разницу между двумя датами (в днях)
//
// Параметры:
//  ДатаНачала 		- Дата - начальная дата периода
//  ДатаОкончания	- Дата - конечная дата периода.
//  Периодичность	- ПеречислениеСсылка.Периодичность - Периодичность.
//
// Возвращаемое значение:
//   Число	 - количество дней между двумя датами.
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	СекундВМинуте = 60;
	МинутВЧасе = 60;
	ЧасовВДне = 24;
	
	Если Периодичность = Перечисления.Периодичность.Год Тогда
		Возврат Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		Возврат ?(Месяц(ДатаОкончания)>6, 2, 1) - ?(Месяц(ДатаНачала)>6, 2, 1) + 2*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		Возврат Цел(Месяц(НачалоКвартала(ДатаОкончания))/3) - Цел(Месяц(НачалоКвартала(ДатаНачала))/3) + 4*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		Возврат Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12*(Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		Возврат Цел((ДатаОкончания - ДатаНачала)/(10 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		Возврат Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала))/(7 * СекундВМинуте*МинутВЧасе*ЧасовВДне));
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		Возврат (ДатаОкончания - ДатаНачала)/(СекундВМинуте*МинутВЧасе*ЧасовВДне);
		
	КонецЕсли;
	
КонецФункции

// Возвращает массив дней, входящих в период.
//
// Параметры:
//   ДатаНачала - Дата
//   ДатаОкончания - Дата
//
// Возвращаемое значение:
//   Массив из Дата - Дни периода.
//
Функция МассивДатИзПериода(ДатаНачала, ДатаОкончания) Экспорт
	Результат = Новый Массив;
	
	ТекущийДень = НачалоДня(ДатаНачала);
	Пока ТекущийДень <= ДатаОкончания Цикл
		Результат.Добавить(ТекущийДень);
		ТекущийДень = ТекущийДень + 86400;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Проверяет использование объекта
//
// Параметры:
//  Параметры		- Структура - содержит объект использование которого нужно проверить
//  АдресХранилища	- Строка - адрес хранилища в которое будут помещен результат проверки.
//
Процедура ПроверитьИспользованиеОбъекта(Параметры, АдресХранилища) Экспорт
	
	ЕстьСсылки = ОбщегоНазначенияВызовСервера.ЕстьСсылкиНаОбъект(Параметры.Объект);
	
	ПоместитьВоВременноеХранилище(ЕстьСсылки, АдресХранилища);
	
КонецПроцедуры

// Возвращает ключ коллекции, имеющий указанное значение.
//
// Параметры:
// 	Коллекция - Структура -
// 	          - Соответствие -
//	          - ФиксированнаяСтруктура -
//	          - ФиксированноеСоответствие -
//  Значение - Произвольный - Указанное значение
//
// Возвращаемое значение:
//  Строка - 
Функция КлючКоллекцииПоЗначению(Коллекция, Значение) Экспорт
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		Если КлючИЗначение.Значение = Значение Тогда
			Возврат КлючИЗначение.Ключ;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает коллекцию, в которой ключи и значения поменяны местами.
//
// Параметры:
// 	Коллекция - Структура, Соответствие, ФиксированнаяСтруктура, ФиксированноеСоответствие -
// 	
// Возвращаемое значение:
//  Структура, Соответствие, ФиксированнаяСтруктура, ФиксированноеСоответствие -
Функция ПоменятьКлючИЗначениеКоллекции(Коллекция) Экспорт
	
	Если ТипЗнч(Коллекция) = Тип("Структура") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый Структура;
	ИначеЕсли ТипЗнч(Коллекция) = Тип("Соответствие") ИЛИ ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый Соответствие;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Коллекция Цикл
		НоваяКоллекция.Вставить(КлючИЗначение.Значение, КлючИЗначение.Ключ);
	КонецЦикла;
	
	Если ТипЗнч(Коллекция) = Тип("ФиксированнаяСтруктура") Тогда
		НоваяКоллекция = Новый ФиксированнаяСтруктура(НоваяКоллекция);
	ИначеЕсли ТипЗнч(Коллекция) = Тип("ФиксированноеСоответствие") Тогда
		НоваяКоллекция = Новый ФиксированноеСоответствие(НоваяКоллекция);
	КонецЕсли;
	
	Возврат НоваяКоллекция;
	
КонецФункции

// Возвращает количество документов прописью.
//
// Параметры:
//  КоличествоДокументов - Число - Количество документов.
//
// Возвращаемое значение:
//  Строка - Количество документов прописью.
//
Функция ЧислоДокументовПрописью(КоличествоДокументов) Экспорт
	
	КоличествоПрописью = ЧислоПрописью(
		КоличествоДокументов,
		НСтр("ru = 'SN = Истина; FN = Ложь; FS = Ложь;'"),
		НСтр("ru = 'документ,документа,документов,м,,,,,0'"));
	
	Поз = СтрНайти(КоличествоПрописью, НСтр("ru = 'документ'"));
	Если Поз <> 0 Тогда
		КоличествоПрописью = Сред(КоличествоПрописью, Поз);
	КонецЕсли;
	
	КоличествоПрописью = Строка(КоличествоДокументов) + " " + НРег(КоличествоПрописью);
	
	Возврат КоличествоПрописью;
	
КонецФункции

// Возвращает описание типов по переданному типу
// 
// Параметры:
//	Тип - Тип - Тип значения
//
// Возвращаемое значение:
//	ОписаниеТипов - созданное на основании переданного типа описание типов.
//
Функция ОписаниеТиповПоТипу(Тип) Экспорт
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(Тип);
	
	ОписаниеТипов = Новый ОписаниеТипов(МассивТипов);
	
	Возврат ОписаниеТипов;
КонецФункции

// Возвращает таблицу значений на основании массива структур
// 
// Параметры:
//	МассивСтруктур - Массив Из Структура - Массив структур, которые будут преобразованы в таблиц значений.
//										   Свойства структуры первого элемента массива определяют состав колонок результирующей таблицы.
//
// Возвращаемое значение:
//	ТаблицаЗначений - таблица значений, созданная из массива структур.
// 
Функция МассивВТаблицуЗначений(МассивСтруктур) Экспорт
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре массива
	Если ТипЗнч(МассивСтруктур) = Тип("Массив")
		И МассивСтруктур.Количество() <> 0 Тогда
		ПерваяСтруктура = МассивСтруктур[0];
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого Структура Из МассивСтруктур Цикл 
			НоваяСтрока = Таблица.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Структура);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
КонецФункции

// Возвращает таблицу значений на основании соответствия структур.
// Свойства структуры первого элемента соответствия определяют состав колонок результирующей таблицы.
// 
// Параметры:
// 	 Соответствие - Соответствие - Соответствие структур, которое будут преобразовано в таблицу значений, где:
// 			* Ключ - Произвольный - является одной из колонок таблицы значений
// 			* Значение - Структура - Структура, которую требуется преобразовать к таблице значений
// 
// Возвращаемое значение:
// 	 ТаблицаЗначений
//
Функция СоответствиеВТаблицуЗначений(Соответствие) Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	// Создадим колонки по первой структуре соответствия
	Если ТипЗнч(Соответствие) = Тип("Соответствие")
		И Соответствие.Количество() > 0 Тогда
		Для Каждого КлючИЗначение Из Соответствие Цикл 
			ПерваяСтруктура = КлючИЗначение.Значение;
			Прервать;
		КонецЦикла;
		Таблица.Колонки.Добавить("Ключ", ОписаниеТиповПоТипу(ТипЗнч(КлючИЗначение.Ключ)));
		Для Каждого Свойство Из ПерваяСтруктура Цикл 
			Таблица.Колонки.Добавить(Свойство.Ключ, ОписаниеТиповПоТипу(ТипЗнч(Свойство.Значение)));
		КонецЦикла;
		
		Для Каждого КлючИЗначение Из Соответствие Цикл 
			НоваяСтрока = Таблица.Добавить();
			НоваяСтрока.Ключ = КлючИЗначение.Ключ;
			ЗаполнитьЗначенияСвойств(НоваяСтрока, КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции

// Возвращает метаданные объекта по полному имени объекта метаданных
//
// Параметры:
//  МетаданныеСтрокой - Строка - Полный путь к метаданным реквизита как в дереве метаданных.
//                       Пример: "Документы.ПоступлениеБезналичныхДенежныхСредств.ТабличныеЧасти.РасшифровкаПлатежа.Реквизиты.Заказ"
//                               "РегистрыНакопления.ДвиженияКонтрагентДоходыРасходы.Измерения.ОбъектРасчетов".
//
// Возвращаемое значение:
//  ОбъектМетаданных - 
//
Функция МетаданныеПоИмени(МетаданныеСтрокой) Экспорт
	
	Возврат СвойствоМетаданных(Метаданные, СтрРазделить(МетаданныеСтрокой, "."));
	
КонецФункции

// Возвращает Истина, если включен режим отладки.
//
// Возвращаемое значение:
// 	 Булево -
Функция РежимОтладки() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	РежимОтладки = ОбщегоНазначения.РежимОтладки()
		ИЛИ Константы.РежимОтладки.Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат РежимОтладки;
	
КонецФункции

// Устанавливает пометку удаления и формирует список сообщений об ошибках установки пометки удаления документов.
//
// Параметры:
//  Ссылки - Массив Из ДокументСсылка - Список документов.
// 
// Возвращаемое значение:
//   Структура - см. ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю
//
Функция УстановитьПометкуУдаленияДокументов(Ссылки) Экспорт

	Перем СписокОшибок;
	ТекстНеЗаблокирован = НСтр("ru = '%1 - не удалось пометить на удаление документ, возможно документ редактируется другим пользователем.'");

	Для Каждого Ссылка Из Ссылки Цикл
		ДокументОбъект = Ссылка.ПолучитьОбъект();
		Если ДокументОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ДокументОбъект.ПометкаУдаления Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ДокументОбъект.Заблокировать();
		Исключение
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстНеЗаблокирован, СокрЛП(Ссылка)); 
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			Продолжить;
			
		КонецПопытки;
		
		ДокументОбъект.УстановитьПометкуУдаления(Истина);
	КонецЦикла;
	Возврат СписокОшибок;

КонецФункции

// Перед попыткой непосредственного удаления документа устанавливает
// пометку на удаление, что позволяет отработать предусмотренным
// механизмам в документе.
// Формирует список сообщений об успешном удалении документов, либо
// об ошибках не позволяющих удалить документы.
//
// Параметры:
//  СсылкиНаУдаление - Массив Из ДокументСсылка - Список созданных документов.
//  МассивИсключаемыхОбъектов - Неопределено, Массив из ОбъектМетаданных - Список объектов метаданных, в случае наличия ссылок
//  на которые в удаляемых объектах, удаление отменяется.
// 
// Возвращаемое значение:
//   Неопределено, Структура - Содержит список сообщений. Состав ключей определяется в функции ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.
//
Функция УдалитьДокументы(СсылкиНаУдаление, МассивИсключаемыхОбъектов = Неопределено) Экспорт
	
	СписокОшибок = Неопределено;
	
	Если СсылкиНаУдаление.Количество() = 0 Тогда
		Возврат СписокОшибок;
	КонецЕсли;
	
	ТекстИмеютсяСсылки  = НСтр("ru = 'Не удалось удалить документ %1, так как на него имеются ссылки в %2.'");
	ТекстПомечен        = НСтр("ru = '%1 - помечен на удаление.'");
	ТекстУдален         = НСтр("ru = '%1 - удален.'");
	ТекстНеЗаблокирован = НСтр("ru = '%1 - не удалось пометить на удаление документ, возможно документ редактируется другим пользователем.'");
	
	МассивИменОбъектовМетаданных = Новый Массив();
	Для Каждого ДокументКУдалению Из СсылкиНаУдаление Цикл
		ИмяОбъектаМетаданных = ДокументКУдалению.Метаданные().ПолноеИмя();
		Если МассивИменОбъектовМетаданных.Найти(ИмяОбъектаМетаданных) = Неопределено Тогда
			МассивИменОбъектовМетаданных.Добавить(ИмяОбъектаМетаданных);
		КонецЕсли;
	КонецЦикла;
	ИменаОбъектовМетаданных = СтрСоединить(МассивИменОбъектовМетаданных, ",");
	
	Регистры = ОбщегоНазначенияУТПовтИсп.РегистрыСведенийПоМетаданнымИзмерений(ИменаОбъектовМетаданных, Истина);
	
	НазначенияЗаказов = НазначенияЗаказов(СсылкиНаУдаление);
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(СсылкиНаУдаление, НазначенияЗаказов);
	
	УстановитьПривилегированныйРежим(Истина);
	
	ТабСсылок = НайтиПоСсылкам(СсылкиНаУдаление);
	
	ВсегоСтрок = ТабСсылок.Количество();
	Для Счетчик = 1 По ВсегоСтрок Цикл
		Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
		
		Если Ссылка[0] = Ссылка[1]
			ИЛИ ЭтоЗаписьВедомогоРегистраСведений(Ссылка[1], Регистры)
			ИЛИ (ТипЗнч(МассивИсключаемыхОбъектов) = Тип("Массив")
				И ЭтоЗаписьИсключаемогоОбъекта(Ссылка[1], МассивИсключаемыхОбъектов)) Тогда
			
			ТабСсылок.Удалить(Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ПомечатьНаУдаление = Новый Массив();
	
	ВсегоСтрок = ТабСсылок.Количество();
	Для Счетчик = 1 По ВсегоСтрок Цикл
		Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
		
		Индекс = СсылкиНаУдаление.Найти(Ссылка[1]);
		Если Индекс = Неопределено Тогда
			
			Если ПомечатьНаУдаление.Найти(Ссылка[0]) = Неопределено Тогда
				
				ПомечатьНаУдаление.Добавить(Ссылка[0]);
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстИмеютсяСсылки, СокрЛП(Ссылка[0]), СокрЛП(Ссылка[1])); 
				ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
				
			КонецЕсли;
			
			ТабСсылок.Удалить(Ссылка);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ОбработкаЗавершена = Ложь;
	Пока Не ОбработкаЗавершена Цикл
		
		ОбработкаЗавершена = Истина;
		
		ВсегоСтрок = ТабСсылок.Количество();
		Для Счетчик = 1 По ВсегоСтрок Цикл
			Ссылка = ТабСсылок[ВсегоСтрок - Счетчик];
			
			Если ПомечатьНаУдаление.Найти(Ссылка[0]) <> Неопределено Тогда
				
				Если ПомечатьНаУдаление.Найти(Ссылка[1]) = Неопределено Тогда
					
					ПомечатьНаУдаление.Добавить(Ссылка[1]);
					
				КонецЕсли;
				
				ТабСсылок.Удалить(Ссылка);
				ОбработкаЗавершена = Ложь;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из СсылкиНаУдаление Цикл
		
		ДокументОбъект = Ссылка.ПолучитьОбъект();
		Если ДокументОбъект = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			ДокументОбъект.Заблокировать();
		Исключение
			
			Если ПомечатьНаУдаление.Найти(Ссылка) = Неопределено Тогда
				ПомечатьНаУдаление.Добавить(Ссылка);
			КонецЕсли;
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстНеЗаблокирован, СокрЛП(Ссылка)); 
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			Продолжить;
			
		КонецПопытки;
		
		ДокументОбъект.УстановитьПометкуУдаления(Истина);
		Если ПомечатьНаУдаление.Найти(Ссылка) <> Неопределено Тогда
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстПомечен, СокрЛП(Ссылка));
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из ПомечатьНаУдаление Цикл
		
		Индекс = СсылкиНаУдаление.Найти(Ссылка);
		Если Индекс <> Неопределено Тогда
			СсылкиНаУдаление.Удалить(Индекс);
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого Ссылка Из СсылкиНаУдаление Цикл
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстУдален, СокрЛП(Ссылка)); 
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(СписокОшибок, Неопределено, ТекстОшибки, Неопределено);
		
	КонецЦикла;
	
	УдалитьОбъекты(СсылкиНаУдаление, Ложь);
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат СписокОшибок;
	
КонецФункции

// Возвращает данные первой записи результата запроса в виде структуры.
// 
// Параметры:
//  РезультатЗапроса - РезультатЗапроса - результат запроса, содержащий данные для обработки.
// 
// Возвращаемое значение:
//  Структура - структура с результатом.
//
Функция ПерваяСтрокаРезультатаЗапросаВСтруктуру(Знач РезультатЗапроса) Экспорт

	Результат = Новый Структура;
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		Результат.Вставить(Колонка.Имя);
	КонецЦикла;

	Если РезультатЗапроса.Пустой() Тогда
		Возврат Результат;
	КонецЕсли;

	Выборка = РезультатЗапроса.Выбрать();
	Выборка.Следующий();

	ЗаполнитьЗначенияСвойств(Результат, Выборка);

	Возврат Результат;

КонецФункции

// Возвращает структуру с ключами, соответствующими колонкам таблицы значений.
// Значения в структуре заполняются значениями полей из переданной строки таблицы.
//
// Параметры:
//	ТекущаяСтрока - СтрокаТаблицыЗначений -
//
// Возвращаемое значение:
//	Структура -
//
Функция ПреобразоватьСтрокуТаблицыВСтруктуру(ТекущаяСтрока) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого Колонка Из ТекущаяСтрока.Владелец().Колонки Цикл
		Результат.Вставить(Колонка.Имя, ТекущаяСтрока[Колонка.Имя]);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Устанавливает параметры запроса из переданной структуры.
//
// Параметры:
//	Запрос - Запрос - запрос, параметры которого надо установить
//	ПараметрыЗапроса - Структура - структура с устанавливаемыми параметрами запроса.
//
Процедура УстановитьПараметрыЗапроса(Запрос, ПараметрыЗапроса) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыЗапроса Цикл
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
КонецПроцедуры

// Получает макет в метаданных и возвращает его
//
// Параметры:
//  ИмяМакетаИлиАдрес - Строка - полное имя макета. Например, Документ.РеализацияТоваровУслуг.ДанныеШаблонаСообщений 
// 
// Возвращаемое значение:
//  ТабличныйДокумент, ТекстовыйДокумент, СхемаКомпоновкиДанных -
//
Функция МакетПоИмени(ИмяМакетаИлиАдрес) Экспорт
	
	ПоложениеТочки = СтрНайти(ИмяМакетаИлиАдрес, ".",,,2);
	
	Если ПоложениеТочки = 0 Тогда
		ПоложениеТочки = СтрНайти(ИмяМакетаИлиАдрес, ".",,,1);
		
		ИмяМакета    = Прав(ИмяМакетаИлиАдрес, СтрДлина(ИмяМакетаИлиАдрес) - ПоложениеТочки); 
		Результат = ПолучитьОбщийМакет(ИмяМакета);
	Иначе
		ИмяМенеджера = Лев(ИмяМакетаИлиАдрес, ПоложениеТочки);
		ИмяМакета    = Прав(ИмяМакетаИлиАдрес, СтрДлина(ИмяМакетаИлиАдрес) - ПоложениеТочки); 
		
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ИмяМенеджера);
		
		Результат = МенеджерОбъекта.ПолучитьМакет(ИмяМакета);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Свернуть табличную часть объекта
// По умолчанию все числовые колонки попадают в колонки суммирования. Те числовые колонки,
// которые должны попасть в колонки группировки, нужно перечислить в параметре КолонкиГруппировок.
// Нечисловые колонки перечислять в КолонкиГруппировки не нужно.
// 
// Параметры:
//  Объект - ДокументОбъект - 
//	       - СправочникОбъект - 
//		   - ПланВидовХарактеристикОбъект - 
//         - ПланОбменаОбъект - Объект, содержащий табличную часть 
//  ИмяТЧ			   - Строка - имя табличной части, которую нужно свернуть
//  КолонкиГруппировок - Массив Из Строка -
//                     - Строка - Массив строк с именами числовых колонок или строка с именами через запятую,
//  						      которые нужно включить в колонки группировки, а не суммирования.
//
Процедура СвернутьТабличнуюЧасть(Объект, ИмяТЧ, Знач КолонкиГруппировок = Неопределено) Экспорт
	
	Если КолонкиГруппировок = Неопределено Тогда
		КолонкиГруппировок = Новый Массив;
	ИначеЕсли ТипЗнч(КолонкиГруппировок) = Тип("Строка") Тогда
		КолонкиГруппировок = СтрРазделить(КолонкиГруппировок, ",", Ложь);
	КонецЕсли;
	
	КолонкиСуммирования = Новый Массив;
	
	МетаданныеДокумента = Объект.Метаданные();
	
	Для Каждого Колонка Из МетаданныеДокумента.ТабличныеЧасти[ИмяТЧ].Реквизиты Цикл
		Если ТипЗнч(Колонка.Тип.ПривестиЗначение()) = Тип("Число") Тогда
			Если КолонкиГруппировок.Найти(Колонка.Имя)  = Неопределено Тогда
				КолонкиСуммирования.Добавить(Колонка.Имя);
			КонецЕсли;
		Иначе
			КолонкиГруппировок.Добавить(Колонка.Имя);	
		КонецЕсли;
	КонецЦикла;
	
	ТабличнаяЧасть = Объект[ИмяТЧ]; // ТабличнаяЧасть - 
	ТабличнаяЧасть.Свернуть(СтрСоединить(КолонкиГруппировок, ","), СтрСоединить(КолонкиСуммирования,","));
	
КонецПроцедуры

// Проверяет соответствие функции переданному отбору
//
// Параметры:
//  Ссылка	 - ЛюбаяСсылка -
//  Отбор	 - Структура Из КлючИЗначение - Где:
//  			* Ключ - Строка - имя реквизита
//  			* Значение - Произвольный - значение реквизита, или массив значений реквизита
// 
// Возвращаемое значение:
//  Булево 
//
Функция СсылкаСоответствуетОтбору(Ссылка, Отбор) Экспорт
	
	ИменаРеквизитов = Новый Массив;
	
	Для Каждого КлючЗначение Из Отбор Цикл
		
		ИменаРеквизитов.Добавить(КлючЗначение.Ключ);
		
	КонецЦикла;

	ЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, СтрСоединить(ИменаРеквизитов, ","));
	
	Для Каждого КлючЗначение Из Отбор Цикл
		
		ЗначениеРеквизита = ЗначенияРеквизитов[КлючЗначение.Ключ];
		
		Если ТипЗнч(КлючЗначение.Значение) = Тип("Массив")
			Или ТипЗнч(КлючЗначение.Значение) = Тип("ФиксированныйМассив") Тогда
			
			Если КлючЗначение.Значение.Найти(ЗначениеРеквизита) = Неопределено Тогда
				Возврат Ложь;
			КонецЕсли;
			
		ИначеЕсли КлючЗначение.Значение <> ЗначениеРеквизита Тогда
			
			Возврат Ложь;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Выполняет проверку на соответствие операций создаваемого документа операции распоряжения.
//
// Параметры:
//	РаспоряжениеСсылка    - ДокументСсылка - ссылка распоряжения, на основании которого осуществляется создание документа.
//	ИмяДокумента          - Строка      - имя документа, для которого определяются допустимые операции.
//	ХозяйственнаяОперация - ПеречислениеСсылка.ХозяйственныеОперации - хозяйственная операция, для которой выполняется проверка
//
// Возвращаемое значение:
//	Булево - Истина, возможно создание документа на основании распоряжения.
//
Функция ПроверитьОперациюРаспоряжения(РаспоряжениеСсылка, ИмяДокумента, ХозяйственнаяОперация = Неопределено) Экспорт
	
	ДопустимыеОперации = ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента);
	
	Если ЗначениеЗаполнено(ХозяйственнаяОперация) Тогда
		ОперацияДокумента = ХозяйственнаяОперация;
	Иначе
		ОперацияДокумента  = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(РаспоряжениеСсылка, "ХозяйственнаяОперация");
	КонецЕсли;
	
	Если ДопустимыеОперации.Найти(ОперацияДокумента) = Неопределено Тогда
		ШаблонСтроки = НСтр("ru = 'Невозможно оформить документ ""%1"" на основании распоряжения %2 с операцией ""%3"".'");
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСтроки,
											Метаданные.Документы[ИмяДокумента].Синоним,
											РаспоряжениеСсылка,
											ОперацияДокумента);
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,РаспоряжениеСсылка);
		
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Возвращает массив с хозяйственными операциями, допустимые для документа по функциональным опциям.
//
// Параметры:
//	ИмяДокумента - Строка - имя документа, для которого определяются допустимые операции
//
// Возвращаемое значение:
//	Массив Из ПеречислениеСсылка.ХозяйственныеОперации -
//
Функция ДопустимыеХозяйственныеОперацииДокумента(ИмяДокумента) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЗначениеПустойСсылки", Документы[ИмяДокумента].ПустаяСсылка());
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ЕСТЬNULL(НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции, """") КАК ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация                     КАК ХозяйственнаяОперация
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ИдентификаторыОбъектовМетаданных КАК ИдентификаторыОбъектовМетаданных
	|		ПО (НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных = ИдентификаторыОбъектовМетаданных.Ссылка)
	|			И (ИдентификаторыОбъектовМетаданных.ЗначениеПустойСсылки = &ЗначениеПустойСсылки)
	|
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|		ПО (НастройкиХозяйственныхОперацийДокументы.Ссылка = НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ИмяФункциональнойОпции";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	ДопустимыеОперации = Новый СписокЗначений;
	
	Пока Выборка.СледующийПоЗначениюПоля("ИмяФункциональнойОпции") Цикл
		
		ПолноеИмяФО = СтрШаблон("ФункциональнаяОпция.%1", Выборка.ИмяФункциональнойОпции);
		ЕстьФО = ЗначениеЗаполнено(Выборка.ИмяФункциональнойОпции)
			И Метаданные.НайтиПоПолномуИмени(ПолноеИмяФО) <> Неопределено;
		Если Не ЕстьФО
			Или ПолучитьФункциональнуюОпцию(Выборка.ИмяФункциональнойОпции) Тогда
			
			Пока Выборка.Следующий() Цикл
				Если ДопустимыеОперации.НайтиПоЗначению(Выборка.ХозяйственнаяОперация) = Неопределено Тогда
					ДопустимыеОперации.Добавить(Выборка.ХозяйственнаяОперация);
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ДопустимыеОперации.СортироватьПоЗначению();
	
	Возврат ДопустимыеОперации.ВыгрузитьЗначения();
	
КонецФункции

// Возвращает описание типа денежного поля.
//
// Параметры:
//  ЗнакПоля - ДопустимыйЗнак - допустимый знак денежного поля (по умолчанию Любой)
//
// Возвращаемое значение:
//  ОписаниеТипов - Описание типа денежного поля
//
Функция ОписаниеТипаДенежногоПоля(ЗнакПоля = Неопределено) Экспорт
	
	Возврат РаботаСКурсамиВалют.ОписаниеТипаДенежногоПоля(ЗнакПоля);
	
КонецФункции

// Возвращает разрядность описания типа денежного поля.
//
// Параметры:
//  ЗнакПоля - ДопустимыйЗнак	 - допустимый знак денежного поля (по умолчанию Любой)
// 
// Возвращаемое значение:
//  Структура - Ключи:
// 		* Разрядность - Число -
//		* РазрядностьДробнойЧасти - Число -
//
Функция РазрядностьДенежногоПоля(ЗнакПоля = Неопределено) Экспорт
	
	Результат = Новый Структура("Разрядность, РазрядностьДробнойЧасти");
	ЗаполнитьЗначенияСвойств(Результат, ОписаниеТипаДенежногоПоля(ЗнакПоля).КвалификаторыЧисла);
	
	Возврат Результат;
	
КонецФункции
 
// Возвращает общий модуль локализации объекта по полному имени объекта метаданных.
//
// Параметры:
//  ПолноеИмя - Строка - полное имя объекта метаданных. Пример: "Справочник.Организации".
//
// Возвращаемое значение:
//  ОбщийМодуль - общий модуль локализации объекта.
//
Функция ПолучитьМодульЛокализации(ПолноеИмя) Экспорт
	ИмяМодуляЛокализации = "";
	ЧастиИмени = СтрРазделить(ПолноеИмя, ".");
	Если ЧастиИмени.Количество() > 1 Тогда
		ИмяМодуляЛокализации = ЧастиИмени[1] + "Локализация";
	Иначе
		ИмяМодуляЛокализации = ПолноеИмя + "Локализация";
	КонецЕсли;
	ОбщийМодульЛокализации = Неопределено;
	
	Если Метаданные.ОбщиеМодули.Найти(ИмяМодуляЛокализации) <> Неопределено Тогда
		ОбщийМодульЛокализации = Вычислить(ИмяМодуляЛокализации); // ВычислитьВБезопасномРежиме не требуется, т.к. проверка надежная.
	КонецЕсли;
	
	Если ТипЗнч(ОбщийМодульЛокализации) = Тип("ОбщийМодуль") Тогда
		Возврат ОбщийМодульЛокализации
	Иначе
		Возврат Неопределено
	КонецЕсли
	
КонецФункции

// Возвращает массив уникальных значений из колонки таблицы
//
// Параметры:
//  Таблица    - ТаблицаЗначений - 
//	           - ДанныеФормыКоллекция - таблица, из которой необходимо выбрать данные
//  ИмяКолонки - Строка - имя колонки таблицы значений, из которой необходимо выбрать значения.
// 
// Возвращаемое значение:
//  Массив Из Произвольный - Набор уникальных значений.
//
Функция ВыгрузитьЗначенияКолонки(Таблица, ИмяКолонки) Экспорт
	
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		ТаблицаКопия = Таблица.Скопировать(, ИмяКолонки);
	Иначе
		ТаблицаКопия = Таблица.Выгрузить(, ИмяКолонки);
	КонецЕсли;
	
	ТаблицаКопия.Свернуть(ИмяКолонки);
	
	Возврат ТаблицаКопия.ВыгрузитьКолонку(0);
	
КонецФункции

// Возвращает параметры рабочего места в зависимости от установленных отборов по операциям и типам документов.
//
// Параметры:
//  ТаблицаХозОперацииИТипыДокументов - ТаблицаЗначений - таблица с описанием метаданных, используемых в рабочем месте
//  КлючНазначенияФормыПоУмолчанию	 - Строка - параметр, определяющий раздел рабочего места, например, "ВнутреннееТовародвижение"
//  ЗаголовокФормыПоУмолчанию		 - Строка - заголовок рабочего места по умолчанию, например, "Внутреннее товародвижение".
// 
// Возвращаемое значение:
//  Структура - Содержит ключи:
//		* КлючНазначенияИспользования - Строка -
//		* ЗаголовокРабочегоМеста - Строка -
//
Функция ДанныеРабочегоМеста(ТаблицаХозОперацииИТипыДокументов, КлючНазначенияФормыПоУмолчанию, ЗаголовокФормыПоУмолчанию) Экспорт
	
	ОтобранныеХозОперацииИТипыДокументов = ТаблицаХозОперацииИТипыДокументов.Скопировать(Новый Структура("Отбор",Истина),
		"КлючНазначенияИспользования,ЗаголовокРабочегоМеста");
	ОтобранныеХозОперацииИТипыДокументов.Свернуть("КлючНазначенияИспользования,ЗаголовокРабочегоМеста");
	
	ДанныеРабочегоМеста = Новый Структура("КлючНазначенияИспользования,ЗаголовокРабочегоМеста",
		КлючНазначенияФормыПоУмолчанию, ЗаголовокФормыПоУмолчанию);
		
	Если ОтобранныеХозОперацииИТипыДокументов.Количество() = 1 Тогда
		Если ЗначениеЗаполнено(ОтобранныеХозОперацииИТипыДокументов[0].КлючНазначенияИспользования) Тогда
			ДанныеРабочегоМеста.КлючНазначенияИспользования = ОтобранныеХозОперацииИТипыДокументов[0].КлючНазначенияИспользования;	
		КонецЕсли;
		Если ЗначениеЗаполнено(ОтобранныеХозОперацииИТипыДокументов[0].ЗаголовокРабочегоМеста) Тогда
			ДанныеРабочегоМеста.ЗаголовокРабочегоМеста = ОтобранныеХозОперацииИТипыДокументов[0].ЗаголовокРабочегоМеста;	
		КонецЕсли;			
	КонецЕсли;
	
	Возврат ДанныеРабочегоМеста;
	
КонецФункции

// Добавляет колонки в таблицу значений
// 
// Параметры:
// 	Объект - ТаблицаЗначений, ДеревоЗначений - объект, в который нужно добавить колонки
// 	Колонки - Строка - названия колонок, разделенные запятыми.
Процедура ДобавитьКолонки(Объект, Колонки) Экспорт
	
	МассивКолонок = СтрРазделить(Колонки, ",", Ложь);
	Для Каждого Колонка Из МассивКолонок Цикл
		Объект.Колонки.Добавить(СокрЛП(Колонка));
	КонецЦикла;
	
КонецПроцедуры

// Добавляет запись в таблицу значений
// 
// Параметры:
// 	Таблица - ТаблицаЗначений - таблица значений, в которую будет добавлена запись
// 	Значение1 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение2 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение3 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение4 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение5 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение6 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение7 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение8 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
// 	Значение9 - Произвольный - значение, подставляемое в соответствующую колонку в порядке следования.
Процедура ДобавитьЗапись(Таблица, Значение1, Значение2=Неопределено, Значение3=Неопределено,
	Значение4=Неопределено, Значение5=Неопределено, Значение6=Неопределено, Значение7=Неопределено,
	Значение8=Неопределено, Значение9=Неопределено) Экспорт
	
	НовЗапись = Таблица.Добавить();
	НовЗапись[0] = Значение1;
	Если Значение2 <> Неопределено Тогда
		НовЗапись[1] = Значение2;
	КонецЕсли; 
	Если Значение3 <> Неопределено Тогда
		НовЗапись[2] = Значение3;
	КонецЕсли;
	Если Значение4 <> Неопределено Тогда
		НовЗапись[3] = Значение4;
	КонецЕсли;
	Если Значение5 <> Неопределено Тогда
		НовЗапись[4] = Значение5;
	КонецЕсли;
	Если Значение6 <> Неопределено Тогда
		НовЗапись[5] = Значение6;
	КонецЕсли;
	Если Значение7 <> Неопределено Тогда
		НовЗапись[6] = Значение7;
	КонецЕсли;
	Если Значение8 <> Неопределено Тогда
		НовЗапись[7] = Значение8;
	КонецЕсли;
	Если Значение9 <> Неопределено Тогда
		НовЗапись[8] = Значение9;
	КонецЕсли;

КонецПроцедуры

// Проверяет, что используемая версия платформы не ниже указанной.
//
// Параметры:
//	Версия - Строка - номер версии платформы.
//
// Возвращаемое значение:
//	Булево - Истина, если используемая версия не младше указанной в параметре Версия.
//
Функция ВерсияПлатформыНеНижеУказанной(Версия) Экспорт
	
	СистемнаяИнформация = Новый СистемнаяИнформация;
	
	Возврат (ОбщегоНазначенияКлиентСервер.СравнитьВерсии(СистемнаяИнформация.ВерсияПриложения, Версия) >= 0);
	
КонецФункции

#Область СинхнонизацияКлючей

// Составляет список ключевых реквизитов справочника ключей.
// Если справочнику сопоставлен регистр сведений, используемый для поиска ключа,
// то ключевые реквизиты соответствуют изменениям этого регистра сведений.
//
// Параметры:
//  МетаданныеРегистра	- ОбъектМетаданныхРегистрСведений -
// 
// Возвращаемое значение:
//  Соответствие -
//
Функция КлючевыеРеквизитыСправочникаКлючейПоРегиструСведений(МетаданныеРегистра) Экспорт
	
	Результат = Новый Соответствие;
	
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		
		Результат.Вставить(Измерение.Имя);	
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Подготавливает свойство ДополнительныеСвойства объекта для использования процедуры
// ОбщегоНазначенияУТ.СинхронизироватьКлючи. Должна быть вызвана в событии ПередЗаписью объекта.
//
// Параметры:
//  Объект - ДокументОбъект -
//	       - СправочникОбъект - объект, который должен быть синхронизирован с ключами 
//  Параметры - Соответствие Из КлючИЗначение - Где:
//		* Ключ - Строка - Полное имя объекта ключа, с которым нужно синхронизировать объект. 
//				Например, Справочник.КлючиРеестраДокументов
//				В модуле менеджера ключа обязательно должна быть объявлена экспортная функция КлючевыеРеквизиты,
//				возвращающая соответствие с именами реквизитов, по которым определяется уникальность ключа.
//		* Значение - Структура Из КлючИЗначение - Где:
//						** Ключ - Строка - имя реквизита объекта
//						** Значение - Строка - имя реквизита ключа. Если пусто, то используется Ключ.
//					- Строка -  список реквизитов через запятую. Имена реквизитов объекта должны совпадать с именами реквизитов ключа 
Процедура ПодготовитьДанныеДляСинхронизацииКлючей(Объект, Параметры) Экспорт
	
	Объект.ДополнительныеСвойства.Вставить("ЭтоНовый", Объект.ЭтоНовый());
	
	МетаданныеОбъекта = Объект.Метаданные();
		
	
	ПолучаемыеРеквизиты          = Новый Структура;
	ПараметрыСинхронизацииКлючей = Новый Соответствие;
	ПустыеЗначенияРеквизитов     = Новый Структура;
	
	Для Каждого КлючЗначение Из Параметры Цикл
		
		НормализованноеОписаниеРеквизитов = Новый Структура;
		
		Если ТипЗнч(КлючЗначение.Значение) = Тип("Строка") Тогда
			ТекущиеРеквизиты = СтрРазделить(КлючЗначение.Значение, ",");
			
			Для Каждого СтрМас Из ТекущиеРеквизиты Цикл
				ИмяРеквизита = СокрЛП(СтрМас);
				ПроверитьИспользованиеРеквизитаПолучитьПустоеЗначение(Объект, МетаданныеОбъекта, ИмяРеквизита, ПустыеЗначенияРеквизитов);
				
				Если ПустыеЗначенияРеквизитов[ИмяРеквизита] <> "Неиспользуется" Тогда 
					ПолучаемыеРеквизиты.Вставить(ИмяРеквизита,ИмяРеквизита);
					НормализованноеОписаниеРеквизитов.Вставить(ИмяРеквизита, ИмяРеквизита);
				КонецЕсли;
				
			КонецЦикла;
			
		ИначеЕсли ТипЗнч(КлючЗначение.Значение) = Тип("Структура") Тогда
			Для Каждого ТекущиеРеквизиты Из КлючЗначение.Значение Цикл
				
				ИмяРеквизита = ТекущиеРеквизиты.Ключ;
				ПроверитьИспользованиеРеквизитаПолучитьПустоеЗначение(Объект, МетаданныеОбъекта, ИмяРеквизита, ПустыеЗначенияРеквизитов);
				
				Если ПустыеЗначенияРеквизитов[ИмяРеквизита] <> "Неиспользуется" Тогда 
					
					ПолучаемыеРеквизиты.Вставить(ИмяРеквизита, ИмяРеквизита);
					
					Если ЗначениеЗаполнено(ТекущиеРеквизиты.Значение) Тогда
						НормализованноеОписаниеРеквизитов.Вставить(ИмяРеквизита, ТекущиеРеквизиты.Значение);
					Иначе
						НормализованноеОписаниеРеквизитов.Вставить(ИмяРеквизита, ИмяРеквизита);
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
		Иначе
			ТекстИсключения = НСтр("ru = 'Не поддерживаемый тип описания реквизитов, синхронизируемых с ключем %ИмяКлюча%'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", КлючЗначение.Ключ);
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;	
		
		ПараметрыСинхронизацииКлючей.Вставить(КлючЗначение.Ключ, НормализованноеОписаниеРеквизитов); 
		
	КонецЦикла;
	
	Объект.ДополнительныеСвойства.Вставить("ПараметрыСинхронизацииКлючей", ПараметрыСинхронизацииКлючей);
	
	Если Объект.ДополнительныеСвойства.ЭтоНовый Тогда
		
		Для Каждого КлючЗначение Из ПолучаемыеРеквизиты Цикл
			Объект.ДополнительныеСвойства.Вставить(КлючЗначение.Ключ + "ДоЗаписи", ПустыеЗначенияРеквизитов[КлючЗначение.Ключ]);
		КонецЦикла;
		
	Иначе
		
		ЗначенияРеквизитовДоЗаписи = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Объект.Ссылка, ПолучаемыеРеквизиты);
		
		Для Каждого КлючЗначение Из ЗначенияРеквизитовДоЗаписи Цикл
			Объект.ДополнительныеСвойства.Вставить(КлючЗначение.Ключ + "ДоЗаписи", КлючЗначение.Значение);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает значение реквизита "до записи", сохраненного в дополнительных свойствах с помощью метода см. ПодготовитьДанныеДляСинхронизацииКлючей.
// 
// Параметры:
// 	ИмяРеквизита - Строка - Имя реквизита объекта
// 	ДополнительныеСвойства - Структура - Дополнительные свойства объекта
//
// Возвращаемое значение:
// 	Произвольный - значение реквизита до записи
Функция ЗначениеРеквизитаДоЗаписиИзДополнительныхСвойств(ИмяРеквизита, ДополнительныеСвойства) Экспорт
	
	ИмяСвойства = ИмяРеквизита + "ДоЗаписи";
	Если ДополнительныеСвойства.Свойство(ИмяСвойства) Тогда
		Возврат ДополнительныеСвойства[ИмяСвойства];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Возвращаемое значение:
// 	Структура - Описание:
// * МенеджерОбъекта - СправочникМенеджер -
// * КлючевойРеквизитДляСоздания - Неопределено -
// * КлючевыеРеквизиты - Структура -
// * ИзменившиесяРеквизиты - Структура -
// * ПолноеИмя - Строка -
Функция ОписаниеКлюча()
	
	ОписаниеКлюча = Новый Структура;
	ОписаниеКлюча.Вставить("ПолноеИмя", "");
	ОписаниеКлюча.Вставить("ИзменившиесяРеквизиты", Новый Структура);
	ОписаниеКлюча.Вставить("КлючевыеРеквизиты", Новый Структура);
	ОписаниеКлюча.Вставить("КлючевойРеквизитДляСоздания", Неопределено); // если нужно создавать ключ, тут имя ключевого реквизита
	ОписаниеКлюча.Вставить("МенеджерОбъекта", Неопределено); // если нужно создавать ключ, тут имя ключевого реквизита
	
	Возврат ОписаниеКлюча;
	
КонецФункции

// Возвращаемое значение:
// Соответствие Из КлючИЗначение - Где:
// 			* Ключ - Строка - 
// 			* Значение - см. ОписаниеКлюча
Функция КлючиДляОбновления()
	Возврат Новый Соответствие()
КонецФункции

// Синхронизирует значения реквизитов объекта с ключами.
// Должна быть вызвана в событии ПриЗаписи объекта. При этом в событии ПередЗаписью этого объекта
// обязятельно должна быть вызвана процедура ОбщегоНазначенияУТ.ПодготовитьДанныеДляСинхронизацииКлючей.
//
// Если в ключе один ключевой реквизит, то проверяется существование ключа и если его нет, то он создается.
//
// Параметры:
//  Объект - ДокументОбъект - 
//	       - СправочникОбъект - объект, который должен быть синхронизирован с ключами 
//
Процедура СинхронизироватьКлючи(Объект) Экспорт
	
	ПараметрыСинхронизацииКлючей = Объект.ДополнительныеСвойства.ПараметрыСинхронизацииКлючей;
	КлючиДляОбновления = КлючиДляОбновления(); // Ключ - имя объекта, Значение - структура с изменившимися реквизитами
	
	Для Каждого ПараметрСинхронизации Из ПараметрыСинхронизацииКлючей Цикл
		
		ОписаниеКлюча = ОписаниеКлюча();
		
		ОписаниеКлюча.ПолноеИмя = ПараметрСинхронизации.Ключ;
		
		ОписаниеКлюча.МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ОписаниеКлюча.ПолноеИмя);
		
		МетаданныеСправочникаКлючей = Метаданные.НайтиПоПолномуИмени(ОписаниеКлюча.ПолноеИмя); // ОбъектМетаданныхСправочник - 
		
		КлючевыеРеквизиты = ОписаниеКлюча.МенеджерОбъекта.КлючевыеРеквизиты();
		
		Для Каждого ИмяРеквизита Из КлючевыеРеквизиты Цикл
			МетаданныеРеквизита = МетаданныеСправочникаКлючей.Реквизиты.Найти(ИмяРеквизита.Ключ);
			
			Если МетаданныеРеквизита = Неопределено Тогда
				
				Для Каждого СтандартныйРеквизит Из МетаданныеСправочникаКлючей.СтандартныеРеквизиты Цикл
					Если СтандартныйРеквизит.Имя = ИмяРеквизита.Ключ Тогда
						МетаданныеРеквизита = СтандартныйРеквизит;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если МетаданныеРеквизита = Неопределено Тогда
					ТекстИсключения = НСтр("ru = 'Для ключа %ИмяКлюча% ключевой реквизит %ИмяРеквизит% не найден. Ошибка в описании ключевых реквизитов'");
					ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", ОписаниеКлюча.ПолноеИмя);
					ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяРеквизит%", ИмяРеквизита.Ключ);
					ВызватьИсключение ТекстИсключения;
				КонецЕсли;	
				
			КонецЕсли;	
			
			ОписаниеКлюча.КлючевыеРеквизиты.Вставить(ИмяРеквизита.Ключ, МетаданныеРеквизита);
			
		КонецЦикла;
		
		Если ОписаниеКлюча.КлючевыеРеквизиты.Количество() = 0 Тогда
			ТекстИсключения = НСтр("ru = 'Для ключа %ИмяКлюча% не заданы ключевые реквизиты'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", ОписаниеКлюча.ПолноеИмя);
			ВызватьИсключение ТекстИсключения;
		ИначеЕсли ОписаниеКлюча.КлючевыеРеквизиты.Количество() = 1 Тогда
			// Если ключевой реквизит один, значит ключ нужно генерировать при создании элемента справочника
			Для Каждого ИмяРеквизита Из ОписаниеКлюча.КлючевыеРеквизиты Цикл
				// По индексу в соотвествии первый элемент не получить, поэтому такой цикл
				ОписаниеКлюча.КлючевойРеквизитДляСоздания = ИмяРеквизита.Ключ;
			КонецЦикла;
		КонецЕсли;
		
		Если Объект.ДополнительныеСвойства.ЭтоНовый Тогда
			
			Если ОписаниеКлюча.КлючевойРеквизитДляСоздания <> Неопределено Тогда
				
				Для Каждого ОписаниеРеквизита Из ПараметрСинхронизации.Значение Цикл
					ОписаниеКлюча.ИзменившиесяРеквизиты.Вставить(ОписаниеРеквизита.Ключ, ОписаниеРеквизита.Значение);	
				КонецЦикла;
				
				КлючиДляОбновления.Вставить(ОписаниеКлюча.ПолноеИмя, ОписаниеКлюча);
				
			КонецЕсли;
						
		Иначе
			
			ЕстьИзменившиесяРеквизиты = Ложь;
			
			Для Каждого ОписаниеРеквизита Из ПараметрСинхронизации.Значение Цикл
				
				ЗначениеРеквизитаДоЗаписи = ЗначениеРеквизитаДоЗаписиИзДополнительныхСвойств(ОписаниеРеквизита.Ключ, Объект.ДополнительныеСвойства);
				РеквизитИзменился = Объект[ОписаниеРеквизита.Ключ] <> ЗначениеРеквизитаДоЗаписи;
				
				Если РеквизитИзменился Тогда
					ЕстьИзменившиесяРеквизиты = Истина;
					ОписаниеКлюча.ИзменившиесяРеквизиты.Вставить(ОписаниеРеквизита.Ключ, ОписаниеРеквизита.Значение);
				ИначеЕсли ОписаниеКлюча.КлючевойРеквизитДляСоздания <> Неопределено Тогда
					// Если нужно создавать ключ при его отсутсвии, значит нужно иметь все реквизиты, а не только изменившиеся
					// При этом если ничего вообще не менялось в справочнике, но зря читать таблицу ключей не будем - в
					// в этом случае просто не добавится потом описание ключа в КлючиДляОбновления
					ОписаниеКлюча.ИзменившиесяРеквизиты.Вставить(ОписаниеРеквизита.Ключ, ОписаниеРеквизита.Значение);
				КонецЕсли;
				
			КонецЦикла;
			
			Если ЕстьИзменившиесяРеквизиты Тогда 
				КлючиДляОбновления.Вставить(ОписаниеКлюча.ПолноеИмя, ОписаниеКлюча);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если КлючиДляОбновления.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ШаблонТекстаЗапроса =
	"ВЫБРАТЬ
	|	Ключи.Ссылка КАК Ссылка,
	|	&УсловиеИзмененияРеквизитов КАК РеквизитыИзменены
	|ИЗ
	|	ПолноеИмяТаблицы КАК Ключи
	|ГДЕ
	|	(&УсловиеПоискаКлюча)
	|	И (&УсловиеИзмененияРеквизитов
	|		ИЛИ (&УсловиеИзмененияПометкиУдаления)
	|		ИЛИ &СоздаватьЕслиОтсутствует)";
	
	ТипЗначенияСправочника = ТипЗнч(Объект.Ссылка);
	
	Блокировка = Новый БлокировкаДанных;
	Запрос = Новый Запрос;
	
	ТекстыЗапросаККлючам = Новый Массив;
	НомерЗапросаИмяОбъектаКлючей = Новый Соответствие;
	Счетчик = 0;
	
	Для каждого КлючДляОбновления Из КлючиДляОбновления Цикл
		
		ОписаниеКлюча = КлючДляОбновления.Значение;
		
		УсловиеПоискаКлюча = Новый Массив;
		УсловиеИзмененияРеквизитов = Новый Массив;
		УсловиеИзмененияПометкиУдаления = Новый Массив;
		
		Для Каждого ИмяРеквизита Из ОписаниеКлюча.КлючевыеРеквизиты Цикл
			
			Если ИмяРеквизита.Значение.Тип.СодержитТип(ТипЗначенияСправочника) Тогда
				УсловиеПоискаКлюча.Добавить("Ключи." + ИмяРеквизита.Значение.Имя + " = &Ссылка ");
				// Все ключевые реквизиты должны быть добавлены в поля блокировки
				ЭлементБлокировки = Блокировка.Добавить(ОписаниеКлюча.ПолноеИмя); 
				ЭлементБлокировки.УстановитьЗначение(ИмяРеквизита.Значение.Имя, Объект.Ссылка);
			КонецЕсли;
			
		КонецЦикла;
			
		Если УсловиеПоискаКлюча.Количество() = 0 Тогда
			ТекстИсключения = НСтр("ru = 'Справочник %ИмяСправочника% не отражается в ключе %ИмяКлюча% (передано значение %Значение%)'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяСправочника%", Метаданные.НайтиПоТипу(ТипЗначенияСправочника).ПолноеИмя());
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", ОписаниеКлюча.ПолноеИмя);
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%Значение%", Строка(Объект.Ссылка));
			
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		Для Каждого ОписаниеРеквизита Из ОписаниеКлюча.ИзменившиесяРеквизиты Цикл
			
			Если ОписаниеРеквизита.Ключ = "ПометкаУдаления"
				И ОписаниеКлюча.КлючевойРеквизитДляСоздания = Неопределено Тогда
				// Ключ должен быть помечен на удаление, если хотя бы одно значение из ключевого реквизита
				// помечено на удаление.
				// Поведение такое:
				//	- помечаем элемент справочника на удаление
				//	      - помечаем все ключи, еще не помеченные на удаление
				//  - снимаем пометку удаления с элемента справочника
				//        - если ключ был помечен на удаление, то снимаем если все значения ключевых реквизитов не помечены на удаление
				// При этом если соответствие ключ-справочник один к одному, то проверку пометки удаления делаем
				// одинаково со всеми остальными реквизитами
				
				Если Объект.ПометкаУдаления Тогда
					УсловиеИзмененияПометкиУдаления.Добавить("НЕ Ключи.ПометкаУдаления ");
				Иначе
					УсловиеИзмененияПометкиУдаления.Добавить("Ключи.ПометкаУдаления ");
					
					Для Каждого ИмяРеквизита Из ОписаниеКлюча.КлючевыеРеквизиты Цикл
						
						ЕстьСсылкаСПометкойУдаления = Ложь;
						ТипыЗначенияРеквизита = ИмяРеквизита.Значение.Тип.Типы();
						
						Для Каждого ТипЗначенияРеквизита Из ТипыЗначенияРеквизита Цикл
							Если ОбщегоНазначения.ЭтоСсылка(ТипЗначенияРеквизита)
								И Не ОбщегоНазначения.ЭтоПеречисление(Метаданные.НайтиПоТипу(ТипЗначенияРеквизита)) Тогда
								
								ЕстьСсылкаСПометкойУдаления = Истина;
								Прервать;
								
							КонецЕсли;
						КонецЦикла;		
						
						Если ЕстьСсылкаСПометкойУдаления Тогда
							УсловиеИзмененияПометкиУдаления.Добавить("НЕ ЕСТЬNULL(Ключи." + ИмяРеквизита.Ключ + ".ПометкаУдаления, ЛОЖЬ) ");
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
			Иначе
				УсловиеИзмененияРеквизитов.Добавить(" Ключи." + ОписаниеРеквизита.Значение + " <> &" + ОписаниеРеквизита.Ключ + " ");
				Запрос.УстановитьПараметр(ОписаниеРеквизита.Ключ, Объект[ОписаниеРеквизита.Ключ]);
			КонецЕсли;
			
		КонецЦикла;
		
		ТекстЗапроса = СтрЗаменить(ШаблонТекстаЗапроса, "ПолноеИмяТаблицы", ОписаниеКлюча.ПолноеИмя); 
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеПоискаКлюча", СтрСоединить(УсловиеПоискаКлюча, " ИЛИ ")); 
		
		Если УсловиеИзмененияПометкиУдаления.Количество() = 0
			И УсловиеИзмененияРеквизитов.Количество() = 0 Тогда
			ТекстИсключения = НСтр("ru = 'Ошибка в алгоритме синхронизации с ключем %ИмяКлюча% значения %Значение% из справочника %ИмяСправочника%'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяСправочника%", Метаданные.НайтиПоТипу(ТипЗначенияСправочника).ПолноеИмя());
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяКлюча%", ОписаниеКлюча.ПолноеИмя);
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%Значение%", Строка(Объект.Ссылка));
			
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		Если УсловиеИзмененияПометкиУдаления.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеИзмененияПометкиУдаления", СтрСоединить(УсловиеИзмененияПометкиУдаления, " И "));
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеИзмененияПометкиУдаления", "ЛОЖЬ");
		КонецЕсли;
		
		Если УсловиеИзмененияРеквизитов.Количество() > 0 Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеИзмененияРеквизитов", СтрСоединить(УсловиеИзмененияРеквизитов, " ИЛИ "));
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеИзмененияРеквизитов", "ЛОЖЬ");
		КонецЕсли;	
			
		Если ОписаниеКлюча.КлючевойРеквизитДляСоздания <> Неопределено Тогда
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СоздаватьЕслиОтсутствует", "ИСТИНА");
		Иначе
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СоздаватьЕслиОтсутствует", "ЛОЖЬ");
		КонецЕсли;
		
		ТекстыЗапросаККлючам.Добавить(ТекстЗапроса);
		НомерЗапросаИмяОбъектаКлючей.Вставить(Счетчик, ОписаниеКлюча.ПолноеИмя); 
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	Запрос.УстановитьПараметр("Ссылка", Объект.Ссылка);
	Запрос.Текст = СтрСоединить(ТекстыЗапросаККлючам, ОбщегоНазначения.РазделительПакетаЗапросов());
	
	УстановитьПривилегированныйРежим(Истина);
	Блокировка.Заблокировать();
	РезультатыЗапроса = Запрос.ВыполнитьПакет();
	
	Для Индекс = 0 по РезультатыЗапроса.ВГраница() Цикл
		
		ОписаниеКлюча = КлючиДляОбновления[НомерЗапросаИмяОбъектаКлючей.Получить(Индекс)]; // см. ОписаниеКлюча
		РезультатЗапроса = РезультатыЗапроса[Индекс];
		
		Если РезультатЗапроса.Пустой() Тогда
			
			Если ОписаниеКлюча.КлючевойРеквизитДляСоздания <> Неопределено Тогда
				
				Если СтрНайти(ВРег(ОписаниеКлюча.ПолноеИмя), "ДОКУМЕНТ.") <> 0 Тогда
					ОбъектКлюча = ОписаниеКлюча.МенеджерОбъекта.СоздатьДокумент();
					ОбъектКлюча.Дата = ТекущаяДатаСеанса();
				Иначе
					ОбъектКлюча = ОписаниеКлюча.МенеджерОбъекта.СоздатьЭлемент();
				КонецЕсли;
				
				ОбъектКлюча[ОписаниеКлюча.КлючевойРеквизитДляСоздания] = Объект.Ссылка;
				
				Для Каждого Реквизит Из ОписаниеКлюча.ИзменившиесяРеквизиты Цикл
					ОбъектКлюча[Реквизит.Значение] = Объект[Реквизит.Ключ];
				КонецЦикла;
				
				ОбъектКлюча.ДополнительныеСвойства.Вставить("СинхронизацияКлючаСоЗначением");
				ОбъектКлюча.Записать();
				
			Иначе
				Продолжить;
			КонецЕсли;
			
		Иначе
			
			ВыборкаИзЗапроса = РезультатЗапроса.Выбрать();
			Пока ВыборкаИзЗапроса.Следующий() Цикл
				ОбъектКлюча = ВыборкаИзЗапроса.Ссылка.ПолучитьОбъект();
				Для Каждого Реквизит Из ОписаниеКлюча.ИзменившиесяРеквизиты Цикл
					ОбъектКлюча[Реквизит.Значение] = Объект[Реквизит.Ключ];
				КонецЦикла;
				
				ОбъектКлюча.ДополнительныеСвойства.Вставить("СинхронизацияКлючаСоЗначением");
				ОбъектКлюча.Записать();
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область ПоискВТаблице

// Выполняет нумерацию строк таблицы значений. Для нумерации используется колонка ПорядковыйНомер.
// Если колонка с таким именем отсутствует в переданной таблице, то она будет добавлена.
//
// Параметры:
//  Таблица	- ТаблицаЗначений - таблица, строки которой будут пронумерованы.
//
Процедура ДобавитьВТаблицуПорядковыйНомерСтрок(Таблица) Экспорт
	
	ПронумероватьТаблицуЗначений(Таблица, "ПорядковыйНомер");
	
КонецПроцедуры

// Заполняет значение колонки ПорядковыйНомер в новой строке таблицы значений,
// строки которой пронумерованы (см. ДобавитьВТаблицуПорядковыйНомерСтрок).
//
// Параметры:
//  Таблица		 - ТаблицаЗначений - таблица с пронумерованными строками.
//  НоваяСтрока	 - СтрокаТаблицыЗначений - строка в которой необходимо заполнить порядковый номер.
//
Процедура ЗаполнитьПорядковыйНомерВНовойСтроке(Таблица, НоваяСтрока) Экспорт
	
	НоваяСтрока.ПорядковыйНомер = Таблица.Количество() + 1;
	
КонецПроцедуры

// Осуществляет поиск строк в таблице значений с сохранением их порядка.
//
// Параметры:
//  Таблица				 - ТаблицаЗначений - таблица в которой необходимо выполнить поиск.
//  УсловиеПоиска		 - Структура - условие поиска строк.
//  СтрокиПронумерованы	 - Булево - Истина, если строки таблицы были предварительно пронумерованы
//		(см. ДобавитьВТаблицуПорядковыйНомерСтрок).
// 
// Возвращаемое значение:
//  Массив - найденные строки.
//
Функция НайтиСтрокиССохранениемПорядка(Таблица, УсловиеПоиска, СтрокиПронумерованы = Ложь) Экспорт
	
	НайденныеСтроки = Таблица.НайтиСтроки(УсловиеПоиска);
	
	Если НайденныеСтроки.Количество() > 1 Тогда
		
		Если СтрокиПронумерованы Тогда
			
			Результат = УпорядочитьПронумерованныеСтроки(Таблица, НайденныеСтроки);
			
		Иначе
			
			Результат = УпорядочитьНеПронумерованныеСтроки(Таблица, НайденныеСтроки);
			
		КонецЕсли;
		
	Иначе
		
		Результат = НайденныеСтроки;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

// Возвращает значения реквизитов переданной ссылки, если ссылка пустая - возвращается значение по умолчанию 
// для каждого типа реквизита.
//
// Параметры:
//	Ссылка - ДокументСсылка - ссылка на объект информационной базы.
//	Реквизиты	 - Строка -
//	             - Массив Из Строка - имена реквизитов через запятую или массив имен реквизитов.
//
// Возвращаемое значение:
//	Структура - структура, свойствами которой являются реквизиты ссылки объекта информационной базы,
//							а значениями - значения реквизитов ссылки.
//
Функция ЗначенияРеквизитовОбъектаПоУмолчанию(Ссылка, Реквизиты) Экспорт
	
	Если ЗначениеЗаполнено(Ссылка) Тогда
		Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Ссылка, Реквизиты);
	Иначе
		Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда 
			Результат = Новый Структура(Реквизиты);
		ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Тогда
			Результат = Новый Структура(СтрСоединить(Реквизиты, ","));
		Иначе
			ТекстИсключения = НСтр("ru = 'Неверный тип параметра ""Реквизиты""'");
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипЗнч(Ссылка)); // ОбъектМетаданныхДокумент - 
		
		Если МетаданныеОбъекта = Неопределено Тогда
			ТекстИсключения = НСтр("ru = 'Переданное значение не является ссылкой'");
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
		Для Каждого КлючЗначение Из Результат Цикл
			
			МетаданныеРеквизита = МетаданныеОбъекта.Реквизиты.Найти(КлючЗначение.Ключ);
			
			Если МетаданныеРеквизита = Неопределено Тогда
				
				Для Каждого СтандартныйРеквизит Из  МетаданныеОбъекта.СтандартныеРеквизиты Цикл
					Если СтандартныйРеквизит.Имя = КлючЗначение.Ключ Тогда
						МетаданныеРеквизита = СтандартныйРеквизит;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если МетаданныеРеквизита = Неопределено Тогда 
					
					ТекстИсключения = НСтр("ru = 'Реквизит %ИмяРеквизита% не найден'");
					ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяРеквизита%", КлючЗначение.Ключ);
					ВызватьИсключение ТекстИсключения;
				КонецЕсли;
				
			КонецЕсли;
			
			Результат[КлючЗначение.Ключ] = МетаданныеРеквизита.Тип.ПривестиЗначение();	
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Параметры:
// 	Ссылка - см. ОбщегоНазначения.ЗначениеРеквизитаОбъекта.Ссылка
// 	ИмяРеквизита - см. ОбщегоНазначения.ЗначениеРеквизитаОбъекта.ИмяРеквизита
// Возвращаемое значение:
//  Булево - значение реквизита, прочитанного из информационной базы по ссылке на объект
//  		см. ОбщегоНазначения.ЗначениеРеквизитаОбъекта. Если полученное значение не имеет тип булево, 
//  		возвращается значение Ложь.
//
Функция ЗначениеРеквизитаОбъектаТипаБулево(Ссылка, ИмяРеквизита) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	Результат = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, ИмяРеквизита);
	Если ТипЗнч(Результат) <> Тип("Булево") Тогда
		Результат = Ложь;
	КонецЕсли;
	УстановитьПривилегированныйРежим(Ложь);	
	Возврат Результат
КонецФункции

// Обходит реквизиты и стандартные реквизиты объекта метаданных и создает структуру с такими же полями.
//
// Параметры:
//	ОбъектМетаданных - ОбъектМетаданных - объект метаданных, используемый в качестве источника копирования свойств.
//
// Возвращаемое значение:
//	Структура - структура, свойствами которой являются реквизиты источника копирования.
//
Функция СтруктураСоСвойствамиОбъектаМетаданных(ОбъектМетаданных) Экспорт
	
	СтруктураСоСвойствамиОбъектаМетаданных = Новый Структура;
	
	Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
		СтруктураСоСвойствамиОбъектаМетаданных.Вставить(Реквизит.Имя, Реквизит.Тип.ПривестиЗначение());
	КонецЦикла;
	
	Для Каждого Реквизит Из ОбъектМетаданных.СтандартныеРеквизиты Цикл
		СтруктураСоСвойствамиОбъектаМетаданных.Вставить(Реквизит.Имя, Реквизит.Тип.ПривестиЗначение());
	КонецЦикла;
	
	Возврат СтруктураСоСвойствамиОбъектаМетаданных;
	
КонецФункции

// Получить максимальную дату однотипных документов.
// 
// Параметры:
//  МассивДокументов - Массив из ДокументСсылка - Массив однотипных документов
// 
// Возвращаемое значение:
//  Дата - максимальная дата документов, если был передлан не пустой массив и ТекущаяДатаСеанса если пустой
Функция ПолучитьМаксимальнуюДатуДокументов(МассивДокументов) Экспорт
	
	МаксимальнаяДата = ТекущаяДатаСеанса();

	Если МассивДокументов.Количество() = 0 Тогда
		Возврат МаксимальнаяДата;
	КонецЕсли;
	
	ТекстЗапроса = "ВЫБРАТЬ
	|	МАКСИМУМ(Документ.Дата) КАК Дата
	|ИЗ
	|	&ПолноеИмяОбъектаМетаданных КАК Документ
	|ГДЕ
	|	Документ.Ссылка В (&МассивДокументов)";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПолноеИмяОбъектаМетаданных", МассивДокументов[0].Метаданные().ПолноеИмя());
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	
	Запрос.УстановитьПараметр("МассивДокументов", МассивДокументов);

	Результат = Запрос.Выполнить().Выгрузить();
	
	Если Результат.Количество() Тогда
		МаксимальнаяДата = Результат[0].Дата;
	КонецЕсли;
	
	Возврат МаксимальнаяДата;
	
КонецФункции

// Останавливает выполнение кода на заданное время.
// Использовать можно только в фоновом задании.
//
// Параметры:
//  Секунд - Число - время ожидания в секундах.
//
Процедура Пауза(Секунд) Экспорт
	
	ТекущийСеансИнформационнойБазы = ПолучитьТекущийСеансИнформационнойБазы();
	ФоновоеЗадание = ТекущийСеансИнформационнойБазы.ПолучитьФоновоеЗадание();
	
	Если ФоновоеЗадание = Неопределено Тогда
		ИмяМетода = "ОбщегоНазначенияУТ.Пауза";
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Ошибка выполнения'"), 
			УровеньЖурналаРегистрации.Ошибка, 
			, 
			, 
			СтрШаблон(НСтр("ru = '%1 разрешается использовать только в фоновом задании.'"), ИмяМетода));
		Параметры = Новый Массив;
		Параметры.Добавить(Секунд);
		ФоновоеЗадание = ФоновыеЗадания.Выполнить("ОбщегоНазначенияУТ.Пауза", Параметры);
	КонецЕсли;
		
	ФоновоеЗадание.ОжидатьЗавершенияВыполнения(Секунд);
	
КонецПроцедуры

#КонецОбласти

#Область НастройкиФорм

// Устанавливает параметры контекстных функциональных опций формы.
//
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - 
// 	ПараметрыНастройки - Структура -
//
Процедура НастроитьФормуПоПараметрам(Форма, ПараметрыНастройки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НастройкиФорм.Ссылка
	|ИЗ
	|	Справочник.ПараметрыКонтекстныхФункциональныхОпций КАК НастройкиФорм
	|ГДЕ
	|	ИСТИНА";
	
	Для каждого ПараметрНастройки Из ПараметрыНастройки Цикл
	
		ТекстЗапроса = ТекстЗапроса + " 
		|	И НастройкиФорм." + ПараметрНастройки.Ключ + " = &" + ПараметрНастройки.Ключ;
		Запрос.УстановитьПараметр(ПараметрНастройки.Ключ, ПараметрНастройки.Значение);
	
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		
		Настройка = Выборка.Ссылка;
		
	Иначе
		
		СправочникОбъект = Справочники.ПараметрыКонтекстныхФункциональныхОпций.СоздатьЭлемент();
		
		ЗаполнитьЗначенияСвойств(СправочникОбъект, ПараметрыНастройки);
		
		СправочникОбъект.Записать();
		
		Настройка = СправочникОбъект.Ссылка;
		
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("НастройкаФормы", Настройка));
	
КонецПроцедуры

// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - 
// 	ИмяФОИспользованияППД - Строка -
//
Процедура ИнициализироватьРеквизитыФормыДляПолнотекстовогоПоиска(Форма, ИмяФОИспользованияППД) Экспорт
	
	Форма.ИнформационнаяБазаФайловая      = ОбщегоНазначения.ИнформационнаяБазаФайловая();
	Форма.ИспользоватьПолнотекстовыйПоиск = ОбщегоНазначенияУТВызовСервера.ИспользуетсяПолнотекстовыйПоиск(ИмяФОИспользованияППД);
	
	Если Форма.ИспользоватьПолнотекстовыйПоиск Тогда
			
		Форма.ИндексПолнотекстовогоПоискаАктуален = ПолнотекстовыйПоискСервер.ИндексПоискаАктуален();
		
	КонецЕсли;
	
КонецПроцедуры

// Сохраняет в реквизит КэшДанныхМеханизмов формы данные, необходимые для работы механизма.
// 
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - Форма
// 	ИмяМеханизма - Строка - Имя механизма, который сохраняет данные
// 	ДанныеДляКэширования - Произвольный - Кэшируемые данные
//
Процедура СохранитьДанныеМеханизмаВКэшФормы(Форма, ИмяМеханизма, ДанныеДляКэширования) Экспорт
	
	Если НЕ ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма, "КэшДанныхМеханизмов") Тогда
		ДобавляемыеРеквизиты = Новый Массив;
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("КэшДанныхМеханизмов", Новый ОписаниеТипов("Неопределено")));
		Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты);
		Форма.КэшДанныхМеханизмов = Новый Структура;
	КонецЕсли;
	Форма.КэшДанныхМеханизмов.Вставить(ИмяМеханизма, ДанныеДляКэширования);
	
КонецПроцедуры

// Удаляет повторяющиеся элементы массива.
//
// Параметры:
// 	Массив - Массив - 
//	НеИспользоватьНеопределено - Булево - 
// 
// Возвращаемое значение:
// 	Массив - Исходный массив, но уже без повторяющихся элементов
//
Функция УдалитьПовторяющиесяЭлементыМассива(Массив, НеИспользоватьНеопределено = Ложь) Экспорт
	
	ОписаниеТиповСправочники  = Справочники.ТипВсеСсылки(); 
	ОписаниеТиповДокументы    = Документы.ТипВсеСсылки(); 
	ОписаниеТиповПВХ          = ПланыВидовХарактеристик.ТипВсеСсылки(); 
	ОписаниеТиповПланыСчетов  = ПланыСчетов.ТипВсеСсылки(); 
	ОписаниеТиповПланыРасчета = ПланыВидовРасчета.ТипВсеСсылки(); 
	
	Если ТипЗнч(Массив) = Тип("Массив") Тогда 
		
		УжеВМассиве 		   = Новый Соответствие; 
		БылоНеопределено 	   = Ложь;
		КоличествоЭлементовВМассиве = Массив.Количество(); 
		
		Для ОбратныйИндекс = 1 По КоличествоЭлементовВМассиве Цикл 
			
			ЭлементМассива = Массив[КоличествоЭлементовВМассиве - ОбратныйИндекс]; 
			ТипЭлемента    = ТипЗнч(ЭлементМассива); 
			
			Если ЭлементМассива = Неопределено Тогда
				
				Если БылоНеопределено ИЛИ НеИспользоватьНеопределено Тогда
					Массив.Удалить(КоличествоЭлементовВМассиве - ОбратныйИндекс); 
				Иначе
					БылоНеопределено = Истина;
				КонецЕсли;
				
				Продолжить;
				
			ИначеЕсли ОписаниеТиповСправочники.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповДокументы.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПВХ.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыСчетов.СодержитТип(ТипЭлемента) 
			 ИЛИ ОписаниеТиповПланыРасчета.СодержитТип(ТипЭлемента) Тогда 
				
				ИДЭлемента = Строка(ЭлементМассива.УникальныйИдентификатор()); 
				
			Иначе 
				
				ИДЭлемента = ЭлементМассива; 
				
			КонецЕсли; 
			
			Если УжеВМассиве[ИДЭлемента] = Истина Тогда 
				Массив.Удалить(КоличествоЭлементовВМассиве - ОбратныйИндекс); 
			Иначе 
				УжеВМассиве[ИДЭлемента] = Истина; 
			КонецЕсли; 
			
		КонецЦикла;      
		
	КонецЕсли;
	
	Возврат Массив;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	ЗначениеКлавиша						- Клавиша
//
// Возвращаемое значение:
//	Строка - Представление клавиши.
//
Функция ПредставлениеКлавиши(ЗначениеКлавиша) Экспорт
	
	Если Строка(Клавиша._1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "1";
	ИначеЕсли Строка(Клавиша._2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "2";
	ИначеЕсли Строка(Клавиша._3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "3";
	ИначеЕсли Строка(Клавиша._4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "4";
	ИначеЕсли Строка(Клавиша._5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "5";
	ИначеЕсли Строка(Клавиша._6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "6";
	ИначеЕсли Строка(Клавиша._7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "7";
	ИначеЕсли Строка(Клавиша._8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "8";
	ИначеЕсли Строка(Клавиша._9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "9";
	ИначеЕсли Строка(Клавиша.Num0) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 0";
	ИначеЕсли Строка(Клавиша.Num1) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 1";
	ИначеЕсли Строка(Клавиша.Num2) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 2";
	ИначеЕсли Строка(Клавиша.Num3) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 3";
	ИначеЕсли Строка(Клавиша.Num4) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 4";
	ИначеЕсли Строка(Клавиша.Num5) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 5";
	ИначеЕсли Строка(Клавиша.Num6) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 6";
	ИначеЕсли Строка(Клавиша.Num7) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 7";
	ИначеЕсли Строка(Клавиша.Num8) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 8";
	ИначеЕсли Строка(Клавиша.Num9) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num 9";
	ИначеЕсли Строка(Клавиша.NumAdd) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num +";
	ИначеЕсли Строка(Клавиша.NumDecimal) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num .";
	ИначеЕсли Строка(Клавиша.NumDivide) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num /";
	ИначеЕсли Строка(Клавиша.NumMultiply) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num *";
	ИначеЕсли Строка(Клавиша.NumSubtract) = Строка(ЗначениеКлавиша) Тогда
		Возврат "Num -";
	Иначе
		Возврат Строка(ЗначениеКлавиша);
	КонецЕсли;
	
КонецФункции

// Функция возвращает представление клавиши
// Параметры:
//	СочетаниеКлавиш	 - СочетаниеКлавиш - Сочетание клавиш для которого нужно сформировать представление
//	БезСкобок - Булево - Флаг, указывающий, что представление должно быть сформировано без скобок.
//
// Возвращаемое значение:
//	Строка - Представление сочетания клавиш.
//
Функция ПредставлениеСочетанияКлавиш(СочетаниеКлавиш, БезСкобок = Ложь) Экспорт
	
	Если СочетаниеКлавиш.Клавиша = Клавиша.Нет Тогда
		Возврат "";
	КонецЕсли;
	
	Наименование = ?(БезСкобок, "", "(");
	Если СочетаниеКлавиш.Ctrl Тогда
		Наименование = Наименование + "Ctrl+"
	КонецЕсли;
	Если СочетаниеКлавиш.Alt Тогда
		Наименование = Наименование + "Alt+"
	КонецЕсли;
	Если СочетаниеКлавиш.Shift Тогда
		Наименование = Наименование + "Shift+"
	КонецЕсли;
	Наименование = Наименование + ПредставлениеКлавиши(СочетаниеКлавиш.Клавиша) + ?(БезСкобок, "", ")");
	
	Возврат Наименование;
	
КонецФункции

// Устанавливает свойство ОтображениеСтраницФормы в Нет, если фактически отображается только одна закладка
// Параметры:
//  ЭлементСтраница  - ГруппаФормы - страница, для которой определяется необходимость отображения закладок.
//
Процедура УдалитьЗакладкиЕслиСтраницаОдна(ЭлементСтраница) Экспорт
	
	Если ЭлементСтраница.ПодчиненныеЭлементы.Количество() = 1 Тогда
		ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
	Иначе
		КоличествоВидимыхСтраниц = 0;
		Для Каждого ПодчиненнаяСтраница Из ЭлементСтраница.ПодчиненныеЭлементы Цикл
			
			Если КоличествоВидимыхСтраниц > 1 Тогда
				Прервать;
			КонецЕсли;
			
			Для Каждого ЭлементСтраницы Из ПодчиненнаяСтраница.ПодчиненныеЭлементы Цикл
				
				Если ЭлементСтраницы.Видимость Тогда
					КоличествоВидимыхСтраниц = КоличествоВидимыхСтраниц + 1;
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Если КоличествоВидимыхСтраниц = 1 Тогда
			ЭлементСтраница.ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// В настройках пользователя могут быть битые ссылки. Процедура проверяет, что ссылки не битые, и если это так -
// заменяет эти ссылки на пустые. Если процедура вызывается в событии ПередЗагрузкойДанныхИзНастроекНаСервере - можно
// очистить ссылки собственно в загружаемых настройка. Если в ПриЗагрузкеДанныхИзНастроекНаСервере - настройки уже применены
// к реквизитам формы и чистить нужно их.
//
// Параметры:
//  Настройки	 - Структура, Соответствие -
//  Форма		 - ФормаКлиентскогоПриложения, Неопределено - если передана форма - очищаются реквизиты, если Неопределено - настройки 
//
Процедура ОчиститьНастройкиИлиРеквизитыФормыОтНесуществующихСсылок(Настройки, Форма = Неопределено) Экспорт
	
	Если Форма <> Неопределено Тогда
		ОчищаемыйОбъект = Форма;
	Иначе
		ОчищаемыйОбъект = Настройки;
	КонецЕсли;
	
	Если ТипЗнч(Настройки) = Тип("Структура")
		Или ТипЗнч(Настройки) = Тип("Соответствие") Тогда
		
		Для Каждого КлючЗначение Из Настройки Цикл
			
			Если ПустаяСтрока(КлючЗначение.Ключ) Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗначения = ТипЗнч(ОчищаемыйОбъект[КлючЗначение.Ключ]);
			
			Если ОбщегоНазначения.ЭтоСсылка(ТипЗначения)
				И Не ОбщегоНазначения.СсылкаСуществует(ОчищаемыйОбъект[КлючЗначение.Ключ]) Тогда
				ОписаниеТипов = Новый ОписаниеТипов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ТипЗначения));
				ОчищаемыйОбъект[КлючЗначение.Ключ] = ОписаниеТипов.ПривестиЗначение();
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает структуру измененных параметров
// 
// Параметры:
// 	СтруктураПараметровНовая - Структура - Структура параметров механизма до изменения ключевых реквизитов.
// 	СтруктураПараметровСтарая - Структура - Структура параметров механизма после изменения ключевых реквизитов.
// Возвращаемое значение:
// 	Структура -
Функция ИзмененныеПараметры(СтруктураПараметровНовая, СтруктураПараметровСтарая) Экспорт
	
	Результат = Новый Структура();
	
	Если ТипЗнч(СтруктураПараметровНовая) <> Тип("Структура") ИЛИ ТипЗнч(СтруктураПараметровСтарая) <> Тип("Структура") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для каждого КлючИЗначение Из СтруктураПараметровНовая Цикл
		
		Если ТипЗнч(КлючИЗначение.Значение) = Тип("Массив")
			ИЛИ ТипЗнч(КлючИЗначение.Значение) = Тип("Структура") Тогда
			Продолжить;
		КонецЕсли;
		
		Если КлючИЗначение.Значение <> СтруктураПараметровСтарая[КлючИЗначение.Ключ] Тогда
			Результат.Вставить(КлючИЗначение.Ключ, СтруктураПараметровСтарая[КлючИЗначение.Ключ] );
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ЗаполненияТабличныхЧастейДокумента

// Процедура проверяет дубли строк в табличной части
//
// Параметры:
//  Объект				 - ДокументОбъект, ФормаКлиентскогоПриложения - проверяемый ДокументОбъект или форма
//  ИмяТЧ				 - Строка			 - имя проверяемой табличной части
//  КлючевыеРеквизитыТЧ	 - Массив -
//	                     - Строка - массив имен реквизитов, по которым определяется уникальность строки
//	                     - Структура - Ключ это наименование реквизита, значение - представление реквизита
//  Отказ				 - Булево			 - отказ продолжения операции.
//  ПредставлениеТЧ		 - Строка			 - если не указано, то представление будет получено из метаданных.
//  УказыватьНомераСтрок - Булево			 - определяет необходимость вывода номера строки в сообщении об ошибке.
//
Процедура ПроверитьНаличиеДублейСтрокТЧ(Объект, ИмяТЧ, КлючевыеРеквизитыТЧ, Отказ, ПредставлениеТЧ = "", УказыватьНомераСтрок = Истина) Экспорт
	
	ТипЗначенияКлючевыеРеквизитыТЧ = ТипЗнч(КлючевыеРеквизитыТЧ);
	ПредставлениеРеквизитаИзСинонима = Истина;
	
	Если ТипЗначенияКлючевыеРеквизитыТЧ = Тип("Строка") Тогда
		КлючевыеРеквизиты = СтрРазделить(КлючевыеРеквизитыТЧ, ",");
	ИначеЕсли ТипЗначенияКлючевыеРеквизитыТЧ = Тип("Структура") Тогда
		
		ПредставлениеРеквизитаИзСинонима = Ложь;
		КлючевыеРеквизиты = Новый Массив;
		Для Каждого ИмяИПредставлениеРеквизита Из КлючевыеРеквизитыТЧ Цикл
			
			КлючевыеРеквизиты.Добавить(ИмяИПредставлениеРеквизита.Ключ);
			
		КонецЦикла;
		
	Иначе
		КлючевыеРеквизиты = КлючевыеРеквизитыТЧ;
	КонецЕсли;
	
	КлючДанных = КлючДанныхДляСообщенияПользователю(Объект);
	
	ЭтоФорма = Ложь;
	Если ТипЗнч(Объект) = Тип("ФормаКлиентскогоПриложения") Тогда
		ЭтоФорма = Истина;
	Иначе
		МетаданныеОбъекта = Объект.Метаданные();
		Если ПустаяСтрока(ПредставлениеТЧ) Тогда
			ПредставлениеТЧ = МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Синоним;
		КонецЕсли;
	КонецЕсли;
	
	МассивСтрокПоляВыборки = Новый Массив;
	МассивСтрокПоляСоединения = Новый Массив;
	МассивСтрокПоляВыгрузки = Новый Массив;
	МассивСтрокСообщенияОДублях = Новый Массив;
	
	Для Каждого СтрМас Из КлючевыеРеквизиты Цикл
		МассивСтрокПоляВыборки.Добавить(СтрШаблон("ТаблицаПроверки.%1", СтрМас));
		МассивСтрокПоляСоединения.Добавить(СтрШаблон("ТаблицаПроверки.%1 = ДублирующиесяСтроки.%1", СтрМас));
		МассивСтрокПоляВыгрузки.Добавить(СтрМас);
		Если ПредставлениеРеквизитаИзСинонима Тогда
			ПредставлениеРеквизита = ?(ЭтоФорма, "",МетаданныеОбъекта.ТабличныеЧасти[ИмяТЧ].Реквизиты[СтрМас].Синоним);
		Иначе
			ПредставлениеРеквизита = ?(ЭтоФорма, "", КлючевыеРеквизитыТЧ[СтрМас]);
		КонецЕсли;
		МассивСтрокСообщенияОДублях.Добавить(СтрШаблон("""%1""", ПредставлениеРеквизита));
	КонецЦикла;	
	
	ТекстПоляВыборки = СтрСоединить(МассивСтрокПоляВыборки, "," + Символы.ПС);
	ТекстПоляСоединения = СтрСоединить(МассивСтрокПоляСоединения, Символы.ПС + "И" + " ");
	ТекстПоляВыгрузки = СтрСоединить(МассивСтрокПоляВыгрузки, ",");
	ТекстДляСообщенияОДублях =  СтрСоединить(МассивСтрокСообщенияОДублях, ",");
	
	ТекстЗапроса =
	"ВЫБРАТЬ 
	|	ТаблицаПроверки.НомерСтроки,
	|	&ПоляВыборки
	|ПОМЕСТИТЬ ТаблицаПроверки
	|ИЗ
	|	&ТаблицаПроверки КАК ТаблицаПроверки
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	МИНИМУМ(ТаблицаПроверки.НомерСтроки) КАК НомерСтроки,
	|	СУММА(1) КАК КоличествоДублей,
	|	&ПоляВыборки
	|ПОМЕСТИТЬ ДублирующиесяСтроки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|
	|СГРУППИРОВАТЬ ПО 
	|	&ПоляВыборки
	|
	|ИМЕЮЩИЕ
	|	СУММА(1) > 1
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаПроверки.НомерСтроки,
	|	ДублирующиесяСтроки.НомерСтроки КАК ПерваяСтрока,
	|	&ПоляВыборки
	|ИЗ
	|	ТаблицаПроверки КАК ТаблицаПроверки
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ДублирующиесяСтроки КАК ДублирующиесяСтроки
	|		ПО ТаблицаПроверки.НомерСтроки <> ДублирующиесяСтроки.НомерСтроки 
	|			И &ПоляСоединения";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки", ТекстПоляВыборки);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляСоединения", ?(ТекстПоляСоединения = "", "ИСТИНА", ТекстПоляСоединения));
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ТаблицаПроверки",Объект[ИмяТЧ].Выгрузить(,"НомерСтроки," + ТекстПоляВыгрузки));
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если ЭтоФорма Тогда
		Если УказыватьНомераСтрок Тогда
			Если КлючевыеРеквизиты.Количество() = 1 Тогда
				ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется значение ""%ПовторяемоеЗначение%"" в ключевом поле.'");
			Иначе
				ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется сочетание значений ""%ПовторяемоеЗначение%"" в ключевых полях.'");
			КонецЕсли;
		Иначе
			Если КлючевыеРеквизиты.Количество() = 1 Тогда
				ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется значение ""%ПовторяемоеЗначение%"" в ключевом поле.'");
			Иначе
				ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется сочетание значений ""%ПовторяемоеЗначение%"" в ключевых полях.'");
			КонецЕсли;
		КонецЕсли;
	Иначе
		Если УказыватьНомераСтрок Тогда
			Если КлючевыеРеквизиты.Количество() = 1 Тогда
				ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется значение ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
			Иначе
				ШаблонСообщения = НСтр("ru = 'В строке %НомерСтроки% списка ""%ПредставлениеТЧ%"" по сравнению со строкой %ПерваяСтрока% повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
			КонецЕсли;
		Иначе
			Если КлючевыеРеквизиты.Количество() = 1 Тогда
				ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется значение ""%ПовторяемоеЗначение%"" в поле %НазванияПолей%.'");
			Иначе
				ШаблонСообщения = НСтр("ru = 'В списке ""%ПредставлениеТЧ%"" повторяется сочетание значений ""%ПовторяемоеЗначение%"" в полях %НазванияПолей%.'");
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Пока Выборка.Следующий() Цикл
		
		ТекстСообщения =  СтрЗаменить(ШаблонСообщения, "%ПредставлениеТЧ%", ПредставлениеТЧ);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НомерСтроки%", Выборка.НомерСтроки);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПерваяСтрока%", Выборка.ПерваяСтрока);
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%НазванияПолей%", ТекстДляСообщенияОДублях);
		
		ПовторяемоеЗначение = "";
		
		Для Каждого СтрМас Из КлючевыеРеквизиты Цикл
			ПредставлениеЗначения = СокрЛП(Строка(Выборка[СтрМас]));
			Если ЗначениеЗаполнено(ПредставлениеЗначения) Тогда
				ПовторяемоеЗначение = ПовторяемоеЗначение + Выборка[СтрМас] + "/";
			КонецЕсли;
		КонецЦикла;
		
		ПовторяемоеЗначение = Лев(ПовторяемоеЗначение, СтрДлина(ПовторяемоеЗначение) - 1);
		
		ТекстСообщения =  СтрЗаменить(ТекстСообщения, "%ПовторяемоеЗначение%", ПовторяемоеЗначение);
		
		Если УказыватьНомераСтрок Тогда
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти(ИмяТЧ, Выборка.НомерСтроки, "НомерСтроки");
		Иначе
			Поле = ИмяТЧ;
		КонецЕсли;
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения,КлючДанных,Поле,"Объект",Отказ);
		
	КонецЦикла;
КонецПроцедуры

// Процедура заполняет значения реквизитов табличной части по структуре
//
// Параметры:
// 		КоллекцияДанных - ДанныеФормыКоллекция - Табличная часть
// 		СтруктураРеквизитов - Структура - Ключ - имя реквизита флага активности. Значение - строка перечисления зависимых реквизитов.
//
Процедура ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции(КоллекцияДанных, СтруктураРеквизитов) Экспорт
	
	// Получение шаблона поля выборки для значения дубликата реквизита
	// 		Если флаг активности ИСТИНА - скопировать значение из реквизита
	// 		Иначе - заполнить пустым значением.
	ШаблонПоляВыборки = 
	"	ВЫБОР КОГДА Коллекция.%ИмяФлага% = ИСТИНА
	|		ТОГДА Коллекция.%ИмяРеквизита%
	|		ИНАЧЕ 0
	|	КОНЕЦ КАК %ИмяРеквизита%%ИмяФлага%";
	
	МассивПолейВыборки = Новый Массив; 
	МассивПолейВыгрузки = Новый Массив;
	МассивПолейВыгрузки.Добавить("НомерСтроки");
	Для Каждого РеквизитФлага Из СтруктураРеквизитов Цикл
		МассивПолейВыгрузки.Добавить(РеквизитФлага.Ключ);
		ЗависимыеРеквизиты = Новый Структура(РеквизитФлага.Значение);
		Для Каждого ЗависимыйРеквизит Из ЗависимыеРеквизиты Цикл
			ПолеВыборки = СтрЗаменить(ШаблонПоляВыборки, "%ИмяФлага%", РеквизитФлага.Ключ);
			ПолеВыборки = СтрЗаменить(ПолеВыборки, "%ИмяРеквизита%", ЗависимыйРеквизит.Ключ);
			МассивПолейВыборки.Добавить(ПолеВыборки);
			МассивПолейВыгрузки.Добавить(ЗависимыйРеквизит.Ключ + ", " + ЗависимыйРеквизит.Ключ + РеквизитФлага.Ключ);
		КонецЦикла;
	КонецЦикла;
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	Коллекция.НомерСтроки,
	|	&ПоляВыборки
	|ПОМЕСТИТЬ втКоллекция
	|ИЗ &КоллекцияДанных КАК Коллекция;
	|
	|ВЫБРАТЬ *
	|ИЗ втКоллекция КАК втКоллекция
	|УПОРЯДОЧИТЬ ПО НомерСтроки";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки", СтрСоединить(МассивПолейВыборки, "," + Символы.ПС));
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("КоллекцияДанных", КоллекцияДанных.Выгрузить( , СтрСоединить(МассивПолейВыгрузки, ",")));
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(КоллекцияДанных[Выборка.НомерСтроки-1], Выборка, , "НомерСтроки");
	КонецЦикла;
	
КонецПроцедуры // ЗаполнитьДубликатыЗависимыхРеквизитовВКоллекции()

// Процедура проверяет отмену строк в табличной части документа
// Параметры:
//	Объект - ДокументОбъект - Проверяемый документ
//	ИмяТЧ - Строка - имя проверяемой табличной части
//	ИмяРеквизитаОтменыСтрок - Строка - имя проверяемого булевого реквизита ТЧ.
// 
// Возвращаемое значение:
// 	Булево - Результат проверки
//
Функция ВсеСтрокиОтменены(Объект, ИмяТЧ, ИмяРеквизитаОтменыСтрок) Экспорт
	
	СтруктураОтбора = Новый Структура(ИмяРеквизитаОтменыСтрок, Ложь);
	НеОтмененныеСтроки = Объект[ИмяТЧ].НайтиСтроки(СтруктураОтбора);
	
	Возврат (НеОтмененныеСтроки.Количество() = 0);
	
КонецФункции

#КонецОбласти

#Область КонтрольНесогласованныхИзменений

// Осуществляет установку подписки на события изменения элементов формы.
//
// Параметры:
// 		Форма - ФормаКлиентскогоПриложения - Форма документа:
// 							* Объект - ДокументОбъект - Свойства:
// 								* Ссылка - ДокументСсылка -
// 		ИменаЭлементов - Массив Из Строка - массив имен элементов формы.
// 		Установить - Булево - необходимость установки или снятия предупреждения.
//
Процедура УстановитьПодпискуНаСобытияИзмененияЭлементовФормы(Форма, ИменаЭлементов, Установить) Экспорт
	
	Если Не ЗначениеЗаполнено(Форма.Объект.Ссылка) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураПолейТаблиц = Новый Структура;
	
	ТипУправляемаяФорма = Тип("ФормаКлиентскогоПриложения");
	ТипДанныеФормыСтруктура = Тип("ДанныеФормыСтруктура");
	ТипПолеФормы = Тип("ПолеФормы");
	ТипКнопкаФормы = Тип("КнопкаФормы");
	ТипТаблицаФормы = Тип("ТаблицаФормы");
	
	Элементы = Форма.Элементы;
	
	ОбработчикиСобытийТабличныхЧастей = Новый Структура();
	МассивЭлементов = Новый Массив;
	Для Каждого ИмяЭлементаПолное Из ИменаЭлементов Цикл
		
		ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
		Если ПозицияРазделителя > 0 Тогда
			Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЭлементаПолное, ";");
			ИмяЭлемента = Массив[0];
		Иначе
			ИмяЭлемента = ИмяЭлементаПолное;
		КонецЕсли;
		
		Если МассивЭлементов.Найти(ИмяЭлемента) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Элемент = Элементы.Найти(ИмяЭлемента);
		Если Элемент = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		МассивЭлементов.Добавить(ИмяЭлемента);
		
		Если ПозицияРазделителя > 0 И Массив.Количество() > 1 Тогда
			Если СтрНайти(Массив[1], ",") > 0 Тогда
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[1], ","));
			Иначе
				ОбработчикиСобытийТабличныхЧастей.Вставить(ИмяЭлемента, Массив[1]);
			КонецЕсли;
		КонецЕсли;
		
		ПоляИсключения = Новый Массив;
		Если ПозицияРазделителя > 0
			И Массив.Количество() > 2 Тогда
			ПоляИсключения = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Массив[2], ",");
		КонецЕсли;
		
		ОбработатьВложенныеПоля(Элементы, Элемент, МассивЭлементов, СтруктураПолейТаблиц, ПоляИсключения);
		
	КонецЦикла;
	
	ИмяОбработчикаПустой = "Подключаемый_ПустойОбработчик_УстановитьДоступностьЭлементовПоСтатусуСервер";
	Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Неопределено Тогда
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений = Новый Структура;
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Команды", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПриИзменении", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("Нажатие", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломИзменения", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередНачаломДобавления", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПередУдалением", Новый Структура);
		
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ОжидаетсяОповещение", Ложь);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ЗначенияРеквизитов", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("ПутьКДанным", Новый Структура);
		Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Вставить("СвязиПараметровВыбора", Новый Соответствие);
		
		Для Каждого ИмяТаблицы Из СтруктураПолейТаблиц Цикл
			
			Имена = Новый Массив;
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяТаблицы.Ключ, Новый Структура);
			
			Для Каждого ИмяЭлемента Из СтруктураПолейТаблиц[ИмяТаблицы.Ключ] Цикл
				
				Данные = Неопределено;
				ПутьКДанным = Элементы[ИмяЭлемента].ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					
					Позиция = СтрНайти(ПутьКДанным, ".");
					Пока Позиция > 0 Цикл
						ПутьКДанным = Сред(ПутьКДанным, Позиция + 1);
						Позиция = СтрНайти(ПутьКДанным, ".");
					КонецЦикла;
					Имена.Добавить(ПутьКДанным);
					
				КонецЕсли;
				
			КонецЦикла;
			
			Для Каждого Имя Из Имена Цикл
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов[ИмяТаблицы.Ключ].Вставить(Имя);
			КонецЦикла;
			
		КонецЦикла;
		
		ИмяОбработчикаПриИзменении            = "Подключаемый_ПриИзменении_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаНажатие                 = "Подключаемый_Нажатие_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаКоманды                 = "Подключаемый_Команда_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломИзменения   = "Подключаемый_ПередНачаломИзменения_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередНачаломДобавления  = "Подключаемый_ПередНачаломДобавления_УстановитьДоступностьЭлементовПоСтатусуСервер";
		ИмяОбработчикаПередУдалением          = "Подключаемый_ПередУдалением_УстановитьДоступностьЭлементовПоСтатусуСервер";
		
		Для Каждого ИмяЭлементаПолное Из МассивЭлементов Цикл
			
			ПозицияРазделителя = СтрНайти(ИмяЭлементаПолное, ";");
			Если ПозицияРазделителя > 0 Тогда
				ИмяЭлемента = Лев(ИмяЭлементаПолное, ПозицияРазделителя - 1);
			Иначе
				ИмяЭлемента = ИмяЭлементаПолное;
			КонецЕсли;
			
			Элемент = Элементы[ИмяЭлемента];
			Если Элемент = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТипЗнчЭлемент = ТипЗнч(Элемент);
			
			Если ТипЗнчЭлемент = ТипПолеФормы Тогда
				
				Действие = Элемент.ПолучитьДействие("ПриИзменении");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПриИзменении.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Данные = Неопределено;
				ПутьКДанным = Элемент.ПутьКДанным;
				Если ЗначениеЗаполнено(ПутьКДанным) Тогда
					Массив = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьКДанным, ".");
					Данные = Форма;
					Для Каждого СтрокаМассива Из Массив Цикл
						ТипЗнчДанные = ТипЗнч(Данные);
						Если ТипЗнчДанные = ТипУправляемаяФорма
							ИЛИ ТипЗнчДанные = ТипДанныеФормыСтруктура Тогда
							Данные = Данные[СтрокаМассива];
						Иначе
							Данные = Неопределено;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Если Данные <> Неопределено Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ЗначенияРеквизитов.Вставить(ИмяЭлемента, Данные);
				КонецЕсли;
				Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПутьКДанным.Вставить(ИмяЭлемента, ПутьКДанным);
				Элемент.УстановитьДействие("ПриИзменении", ИмяОбработчикаПриИзменении);
				
				Если Элемент.Вид = ВидПоляФормы.ПолеВвода Тогда
					Для Каждого СвязьПараметровВыбора Из Элемент.СвязиПараметровВыбора Цикл
						Если СвязьПараметровВыбора.ИзменениеЗначения = РежимИзмененияСвязанногоЗначения.Очищать Тогда
							Массив = Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.СвязиПараметровВыбора.Получить(СвязьПараметровВыбора.ПутьКДанным);
							Если Массив = Неопределено Тогда
								Массив = Новый Массив;
								Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.СвязиПараметровВыбора.Вставить(СвязьПараметровВыбора.ПутьКДанным, Массив);
							КонецЕсли;
							Массив.Добавить(ИмяЭлементаПолное);
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
			ИначеЕсли ТипЗнчЭлемент = ТипТаблицаФормы Тогда
				
				Действия = Неопределено;
				ОбработчикиСобытийТабличныхЧастей.Свойство(ИмяЭлемента, Действия);
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередНачаломДобавления") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломДобавления");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломДобавления.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломДобавления", ИмяОбработчикаПередНачаломДобавления);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередУдалением") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередУдалением");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередУдалением.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередУдалением", ИмяОбработчикаПередУдалением);
				КонецЕсли;
				
				Если Не ЗначениеЗаполнено(Действия) Или Действия.Найти("ПередНачаломИзменения") <> Неопределено Тогда
					Действие = Элементы[ИмяЭлемента].ПолучитьДействие("ПередНачаломИзменения");
					Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
						Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ПередНачаломИзменения.Вставить(ИмяЭлемента, Действие);
					КонецЕсли;
					Элемент.УстановитьДействие("ПередНачаломИзменения", ИмяОбработчикаПередНачаломИзменения);
				КонецЕсли;
				
			ИначеЕсли ТипЗнчЭлемент = ТипКнопкаФормы Тогда
				
				ИмяКоманды = Элемент.ИмяКоманды;
				
				Если Не ЗначениеЗаполнено(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Свойство(ИмяКоманды) Тогда
					Продолжить;
				КонецЕсли;
				
				КомандаФормы = Форма.Команды[ИмяКоманды]; // КомандаФормы - 
				
				Действие = КомандаФормы.Действие;
				Если ЗначениеЗаполнено(Действие) Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Команды.Вставить(ИмяКоманды, Действие);
				КонецЕсли;
				
				КомандаФормы.Действие = ИмяОбработчикаКоманды;
				
			ИначеЕсли ТипЗнчЭлемент = Тип("ДекорацияФормы") Тогда
				
				Действие = Элемент.ПолучитьДействие("Нажатие");
				Если ЗначениеЗаполнено(Действие) И Действие <> ИмяОбработчикаПустой Тогда
					Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.Нажатие.Вставить(ИмяЭлемента, Действие);
				КонецЕсли;
				
				Элемент.УстановитьДействие("Нажатие", ИмяОбработчикаНажатие);
				
			Иначе
				ВызватьИсключение НСтр("ru = 'Внутренняя ошибка'");
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		Если Форма.СтруктураДействийКонтрольНеСогласованныхИзменений <> Неопределено Тогда
			Форма.СтруктураДействийКонтрольНеСогласованныхИзменений.ОжидаетсяОповещение = Ложь;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область УсловноеОформление

// Устанавливаем условное оформление для поля формы "Приоритет"
//    в зависимости от его значения.
//
// Параметры:
// 		Форма - ФормаКлиентскогоПриложения - Содержит данную форму с реквизитами:
// 			* Элементы - ВсеЭлементыФормы - Коллекция элементов формы:
// 				** Приоритет - ПолеФормы - 
//
Процедура УстановитьУсловноеОформлениеПриоритета(Форма) Экспорт
	
	Если Форма.ИмяФормы = "Обработка.СамообслуживаниеПартнеров.Форма.МастерОформленияЗаказа" Тогда
		ПутьКРеквизитуПриоритет = "Приоритет";
	Иначе
		ПутьКРеквизитуПриоритет = "Объект.Приоритет";
	КонецЕсли;
	
	УсловноеОформление = Форма.УсловноеОформление;
	ЭлементыФормы = Форма.Элементы;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьВысшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.ВысокийПриоритетДокумента);

	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Справочники.Приоритеты.ПолучитьНизшийПриоритет();

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветФона", ЦветаСтиля.НизкийПриоритетДокумента);
	
	//
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Приоритеты.Ссылка КАК Приоритет,
	|	Приоритеты.Цвет   КАК Цвет
	|ИЗ
	|	Справочник.Приоритеты КАК Приоритеты");
	
	РезультатЗапроса = Запрос.Выполнить();
	
	Если НЕ РезультатЗапроса.Пустой() Тогда
		
		Выборка = РезультатЗапроса.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			Элемент = УсловноеОформление.Элементы.Добавить();

			ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
			ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ЭлементыФормы.Приоритет.Имя);

			ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизитуПриоритет);
			ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			ОтборЭлемента.ПравоеЗначение = Выборка.Приоритет;
			
			Цвет = Выборка.Цвет; // ХранилищеЗначения -
			Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", Цвет.Получить());
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура заполняет всеми подчиненными полями (с учетом вложенности в группы) оформляемые поля условного оформления
// Пример вызова: ЗаполнитьРекурсивноПоляУсловногоОформления(ЭлементУО.Поля, Элементы.Товары.ПодчиненныеЭлементы).
//
// Параметры:
//	ОформляемыеПоляКомпоновкиДанных	- ОформляемыеПоляКомпоновкиДанных -
//	КоллекцияЭлементов - ЭлементыФормы -
//	ИсключаяПоля - Массив -
//	             - Строка -
//	             - Неопределено - значение по умолчанию Неопределено, массив имен элементов, которые не нужно добавлять в оформляемые поля.
//
Процедура ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, КоллекцияЭлементов, Знач ИсключаяПоля = Неопределено) Экспорт
	
	Если ТипЗнч(ИсключаяПоля) = Тип("Строка") Тогда
		ИсключаяПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяПоля);
	КонецЕсли;
	
	Для Каждого Поле Из КоллекцияЭлементов Цикл
		Если ТипЗнч(Поле) = Тип("ПолеФормы") Тогда
			Если ИсключаяПоля = Неопределено
				Или ИсключаяПоля.Найти(Поле.Имя) = Неопределено Тогда
					ПолеЭлемента = ОформляемыеПоляКомпоновкиДанных.Элементы.Добавить();
					ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Поле.Имя);
			КонецЕсли;
		ИначеЕсли ТипЗнч(Поле) = Тип("ГруппаФормы")Тогда	
			ЗаполнитьРекурсивноПоляУсловногоОформления(ОформляемыеПоляКомпоновкиДанных, Поле.ПодчиненныеЭлементы);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Добавляет на форму условное оформление элемента (отметку незаполненного), исходя из значения служебного реквизита
// по следующему правилу: если реквизит не заполнен а служебный реквизит заполнен то пометка устанавливается, иначе снимается.
//
//  Параметры:
//   УсловноеОформление - УсловноеОформлениеКомпоновкиДанных - условное оформление формы.
//   ИмяЭлемента - Строка - имя элемента для условного оформления.
//   ПутьКРеквизиту - Строка - путь к оформляемому реквизиту, например "Объект.Товары".
//   ПутьКПризнаку - Строка - путь к служебному реквизиту, определяющему необходимость отметки незаполненного значения.
//
Процедура УстановитьСнятьОтметкуНезаполненного(УсловноеОформление, ИмяЭлемента, ПутьКРеквизиту, ПутьКПризнаку) Экспорт
	
	// Установка отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Истина);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКПризнаку);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
	// Снятие отметки.
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяЭлемента);
	
	Отбор = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Отбор.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКРеквизиту);
	Отбор.ВидСравнения = ВидСравненияКомпоновкиДанных.Заполнено;
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ОтметкаНезаполненного", Ложь);
	
КонецПроцедуры

#КонецОбласти

#Область ПереключениеИнтерфейса

// Установка набора видимых подсистем командного интерфейса
//  и настроек всем пользователям вида интерфейса (Такси / в закладках).
//
// Параметры:
//  Режим	 - Строка	 - ИнтерфейсТакси / ИнтерфейсВерсии82 - соответствует константе, которая будет установлена в Истину.
//
Процедура УстановитьРежимКомандногоИнтерфейса(Режим) Экспорт
	
	Если НЕ ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		Возврат;
	КонецЕсли;
	
	// Установка констант
	
	РежимТакси = ВРег(Режим) = ВРег("ИнтерфейсТакси");
	Режим82    = ВРег(Режим) = ВРег("ИнтерфейсВерсии82");
	
	Если НЕ РежимТакси
		И НЕ Режим82 Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	Константы.ИнтерфейсВерсии82.Установить(Режим82);
	
	// Установка настроек по умолчанию всем пользователям
	
	ВсеПользователи = ПользователиИнформационнойБазы.ПолучитьПользователей(); // Массив из ПользовательИнформационнойБазы -
	Если ВсеПользователи.Количество() > 0 Тогда
		Для каждого ПользовательИБ Из ВсеПользователи Цикл
			ПользователиСлужебный.УстановитьНачальныеНастройки(ПользовательИБ.Имя);
		КонецЦикла;
	Иначе
		ПользователиСлужебный.УстановитьНачальныеНастройки("");
	КонецЕсли;

КонецПроцедуры

// Процедура - Переключение интерфейса при создании на сервере
//
// Параметры:
//  Форма	 - ФормаКлиентскогоПриложения - Форма панели администрирования.
//
Процедура ПереключениеИнтерфейсаПриСозданииНаСервере(Форма) Экспорт 

	// Значения реквизитов формы
	Если Константы.ИнтерфейсВерсии82.Получить() Тогда
		Форма.ВариантИнтерфейса = "ИнтерфейсВерсии82";
	Иначе
		Форма.ВариантИнтерфейса = "ИнтерфейсТакси";
	КонецЕсли;
	Форма.ВариантИнтерфейсаДоИзменения = Форма.ВариантИнтерфейса;
	
	ТекущийРежим = Метаданные.РежимСовместимостиИнтерфейса;
	Такси = (ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.Такси
		ИЛИ ТекущийРежим = Метаданные.СвойстваОбъектов.РежимСовместимостиИнтерфейса.ТаксиРазрешитьВерсия8_2);
	
	Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Очистить();
	ПредставлениеИнтерфейса82 = НСтр("ru = 'Как в предыдущих версиях Управления торговлей'");
	Если Такси ИЛИ ПолучитьФункциональнуюОпцию("БазоваяВерсия") Тогда
	
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru = '""Такси"" (рекомендуется)'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82);
		
	Иначе
		
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсТакси", НСтр("ru = '""Такси""'"));
		Форма.Элементы.ВариантИнтерфейса.СписокВыбора.Добавить("ИнтерфейсВерсии82", ПредставлениеИнтерфейса82 + " " + НСтр("ru = '(рекомендуется)'"));
		
	КонецЕсли; 

КонецПроцедуры

#КонецОбласти

#Область ДинамическийСписок

// Восстанавливает настройки динамического списка, используется после изменения текста запроса 
//
// Параметры:
//  Список - ДинамическийСписок - динамический список, для которого нужно восстановить настройки
//
Процедура ВосстановитьНастройкиДинамическогоСписка(Список) Экспорт
	
	Список.КомпоновщикНастроек.Восстановить(СпособВосстановленияНастроекКомпоновкиДанных.Полное);
	
	ДоступныеПоляПорядка = Список.Порядок.ДоступныеПоляПорядка;
	
	ЭлементыПорядка = Список.Порядок.Элементы;
	ИндексЭлементов = ЭлементыПорядка.Количество() - 1;
	Пока ИндексЭлементов > -1 Цикл
		
		Если ДоступныеПоляПорядка.НайтиПоле(ЭлементыПорядка[ИндексЭлементов].Поле) = Неопределено Тогда
			ЭлементыПорядка.Удалить(ЭлементыПорядка[ИндексЭлементов]);	
		КонецЕсли;
		
		ИндексЭлементов = ИндексЭлементов - 1;
		
	КонецЦикла;	
	
КонецПроцедуры	

#КонецОбласти

#Область ПолучениеДанныхВыбора

Процедура ОбработкаПолученияДанныхВыбораХозяйственныеОперации(ДанныеВыбора, Параметры, СтандартнаяОбработка) Экспорт
	
	СтандартнаяОбработка = Ложь;
	
	ДоступныеФО = Новый Массив;
	Для Каждого ФО Из Метаданные.ФункциональныеОпции Цикл
		ДоступныеФО.Добавить(ФО.Имя);
	КонецЦикла;
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|ГДЕ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции В(&ДоступныеФункциональныеОпции)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ХозяйственнаяОперация
	|
	|ИТОГИ ПО
	|	ХозяйственнаяОперация";
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("ДоступныеФункциональныеОпции", ДоступныеФО);
	
	МассивИсключаемыхЗначений = Новый Массив;
	ВыборкаПоОперациям = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаПоОперациям.Следующий() Цикл
		ФункциональныеОпции = ВыборкаПоОперациям.Выбрать();
		ДоступнаПоФО = Ложь;
		Пока ФункциональныеОпции.Следующий() Цикл
			ПолноеИмяФО = СтрШаблон("ФункциональнаяОпция.%1", ФункциональныеОпции.ИмяФункциональнойОпции);
			ЕстьФО = Метаданные.НайтиПоПолномуИмени(ПолноеИмяФО) <> Неопределено;
			ДоступнаПоФО = Не ЕстьФО
				Или ПолучитьФункциональнуюОпцию(ФункциональныеОпции.ИмяФункциональнойОпции);
			Если ДоступнаПоФО Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если НЕ ДоступнаПоФО Тогда
			МассивИсключаемыхЗначений.Добавить(ВыборкаПоОперациям.ХозяйственнаяОперация);
		КонецЕсли;
	КонецЦикла;
	
	Если Параметры.Свойство("ЭтоВыборЗначенияДоступа") Тогда
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	НастройкиХозяйственныхОпераций.ХозяйственнаяОперация КАК Ссылка
		|ИЗ
		|	Справочник.НастройкиХозяйственныхОпераций КАК НастройкиХозяйственныхОпераций
		|ГДЕ
		|	НастройкиХозяйственныхОпераций.ИспользоватьДляОграниченийДоступа = ЛОЖЬ";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		ЗапрещенныеДляВыбора = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(МассивИсключаемыхЗначений, ЗапрещенныеДляВыбора);
	КонецЕсли;
	
	ДоступныеДляВыбораЗначенияПеречисления(
		"ХозяйственныеОперации",
		ДанныеВыбора,
		Параметры,
		МассивИсключаемыхЗначений);
	
КонецПроцедуры

Процедура ОбработкаПолученияДанныхВыбораГруппыФинансовогоУчетаРасчетов(ДанныеВыбора, Параметры, СтандартнаяОбработка) Экспорт
	Справочники.ГруппыФинансовогоУчетаРасчетов.ПреобразоватьОтборПараметровВыбора(Параметры.Отбор);
КонецПроцедуры

#КонецОбласти

#Область РаботаСЖурналамиДокументов

// Возвращает таблицу с хозяйственными операциями и типами документов доступными по функциональным опциям
// и по правам.
//
// Параметры:
//	ТаблицаЗначений - ТаблицаЗначений -
//	ОтборХозяйственныеОперации - Структура  -
//	ОтборТипыДокументов - Структура -
//	КлючНазначенияИспользования - Строка
//
// Возвращаемое значение:
//	ТаблицаЗначений - Колонки:
//		* ХозяйственнаяОперация - ПеречислениеСсылка.ХозяйственныеОперации - 
//		* ИдентификаторОбъектаМетаданных - СправочникСсылка.ИдентификаторыОбъектовМетаданных - 
//		* Отбор - Булево - 
//		* ДокументПредставление - Строка -
//
Функция ДоступныеХозяйственныеОперацииИДокументы(ТаблицаЗначений, ОтборХозяйственныеОперации, ОтборТипыДокументов, КлючНазначенияИспользования) Экспорт
	
	ТаблицаРезультата = ТаблицаЗначений.СкопироватьКолонки();
	ИмяТаблицы        = "РегистрСведений.РеестрДокументов";
	
	НеДоступныеХозяйственныеОперации = НеДоступныеХозяйственныеОперации(ИмяТаблицы);
	ПроверяемыеХозяйственныеОперации = ТаблицаЗначений.ВыгрузитьКолонку("ХозяйственнаяОперация");
	
	МассивХозяйственныхОпераций = ?(НеДоступныеХозяйственныеОперации.Количество() = 0,
									ПроверяемыеХозяйственныеОперации,
									ОбщегоНазначенияКлиентСервер.РазностьМассивов(ПроверяемыеХозяйственныеОперации,
																				НеДоступныеХозяйственныеОперации));
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции КАК ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ИспользоватьВРеестреДокументов КАК ИспользоватьВРеестреДокументов
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|ГДЕ
	|	НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка.ХозяйственнаяОперация В(&МассивХозяйственныхОпераций)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ХозяйственнаяОперация
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	НастройкиХозяйственныхОперацийДокументы.НомерСтроки КАК НомерСтроки,
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмя,
	|	ПРЕДСТАВЛЕНИЕ(ТИПЗНАЧЕНИЯ(НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных.ЗначениеПустойСсылки)) КАК Синоним
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|ГДЕ
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация В(&МассивХозяйственныхОпераций)
	|	И НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных <> ЗНАЧЕНИЕ(Справочник.ИдентификаторыОбъектовМетаданных.ПустаяСсылка)
	|ИТОГИ ПО
	|	ХозяйственнаяОперация";
	
	Запрос.УстановитьПараметр("МассивХозяйственныхОпераций", МассивХозяйственныхОпераций);
	
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	ВыборкаПоФункциональнымОпциям = РезультатЗапроса[0].Выбрать();
	ВыборкаПоДокументам = РезультатЗапроса[1].Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	
	ИдентификаторыОбъектовМетаданных = РезультатЗапроса[1].Выгрузить().ВыгрузитьКолонку("ИдентификаторОбъектаМетаданных");
	ИдентификаторыОбъектовМетаданных = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ИдентификаторыОбъектовМетаданных);
	
	Если ИдентификаторыОбъектовМетаданных.Количество() = 0 Тогда
		ВызватьИсключение НСтр("ru = 'Нет доступных для отображения хозяйственных операций. Возможно права доступа для пользователя назначены некорректно.'");
	КонецЕсли;
	
	// Удалим пустое значение.
	ИдентификаторыОбъектовМетаданных.Удалить(0);
	ПраваПоИдентификаторам = УправлениеДоступом.ПраваПоИдентификаторам(ИдентификаторыОбъектовМетаданных);
	
	
	Пока ВыборкаПоДокументам.Следующий() Цикл
		
		ХозяйственнаяОперацияДоступнаПоФо = Ложь;
		ЕстьФО = Ложь;
		
		Пока ВыборкаПоФункциональнымОпциям.НайтиСледующий(Новый Структура("ХозяйственнаяОперация", ВыборкаПоДокументам.ХозяйственнаяОперация)) Цикл
			
			ПолноеИмяФО = СтрШаблон("ФункциональнаяОпция.%1", ВыборкаПоФункциональнымОпциям.ИмяФункциональнойОпции);
			ЕстьФО = Метаданные.НайтиПоПолномуИмени(ПолноеИмяФО) <> Неопределено;
			ХозяйственнаяОперацияДоступнаПоФо = (ЕстьФО
													И ПолучитьФункциональнуюОпцию(ВыборкаПоФункциональнымОпциям.ИмяФункциональнойОпции))
												Или ХозяйственнаяОперацияДоступнаПоФо;
			
		КонецЦикла;
		ВыборкаПоФункциональнымОпциям.Сбросить();
		Если ЕстьФО И Не ХозяйственнаяОперацияДоступнаПоФо Тогда
			Продолжить;
		КонецЕсли;
		
		Выборка = ВыборкаПоДокументам.Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			ПраваИдентификатораОбъектаМетаданных = ПраваПоИдентификаторам.Получить(Выборка.ИдентификаторОбъектаМетаданных);
			Если ПраваИдентификатораОбъектаМетаданных = Неопределено
				Или Не ПраваИдентификатораОбъектаМетаданных.Чтение Тогда
				Продолжить;
			КонецЕсли;
			
			ИмяДокумента = СтрРазделить(Выборка.ПолноеИмя,".")[1];
			ОбъектМетаданных = Метаданные.Документы[ИмяДокумента];
			
			Если ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
				
				Отбор = Новый Структура("ХозяйственнаяОперация, ПолноеИмяДокумента", Выборка.ХозяйственнаяОперация, Выборка.ПолноеИмя);
				НайденныеСтроки = ТаблицаЗначений.НайтиСтроки(Отбор);
				Для Каждого Строка Из НайденныеСтроки Цикл
					НоваяСтрока = ТаблицаРезультата.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
					НоваяСтрока.ИдентификаторОбъектаМетаданных = Выборка.ИдентификаторОбъектаМетаданных;
					НоваяСтрока.ДокументПредставление = 
						?(НЕ ПустаяСтрока(Строка.ДокументПредставление), Строка.ДокументПредставление, Выборка.Синоним);
					НоваяСтрока.ПравоДоступаДобавление = ПраваИдентификатораОбъектаМетаданных.Добавление;
					НоваяСтрока.ПравоДоступаИзменение = ПраваИдентификатораОбъектаМетаданных.Изменение;
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Если ОтборХозяйственныеОперации.Количество() = 0
		И ОтборТипыДокументов.Количество() = 0 Тогда
		Если КлючНазначенияИспользования = "" Тогда
			ТаблицаРезультата.ЗаполнитьЗначения(Истина, "Отбор");
		Иначе
			Для Каждого Строка Из ТаблицаРезультата Цикл
				Если Строка.КлючНазначенияИспользования = КлючНазначенияИспользования Тогда 
					Строка.Отбор = Истина;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	Иначе
		ЕстьХозяйственныеОперацииКОтбору = Ложь;
		Для Каждого Строка Из ТаблицаРезультата Цикл
			Если ОтборХозяйственныеОперации.НайтиПоЗначению(Строка.ХозяйственнаяОперация) <> Неопределено
				И ОтборТипыДокументов.НайтиПоЗначению(Строка.ИдентификаторОбъектаМетаданных) <> Неопределено Тогда
				Строка.Отбор = Истина;
				ЕстьХозяйственныеОперацииКОтбору = Истина;
			КонецЕсли;
		КонецЦикла;
		Если НЕ ЕстьХозяйственныеОперацииКОтбору Тогда
			ТаблицаРезультата.ЗаполнитьЗначения(Истина, "Отбор");
		КонецЕсли;
	КонецЕсли;
	ЗаполнитьОтборыПоТаблицеХозОперацийИТиповДокументов(ТаблицаРезультата, ОтборХозяйственныеОперации, ОтборТипыДокументов);
	
	Возврат ТаблицаРезультата;
	
КонецФункции

// Устанавливает условное оформление поля Контрагент в журнале.
//
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - 
//  ИмяПоля - Строка - 
//  ПутьКДаннымПоля - Строка - 
//
Процедура УстановитьУсловноеОформлениеПоляСКлючемРеестраДокументов(Форма, ИмяПоля, ПутьКДаннымПоля) Экспорт
	
	//
	ЭлементУсловногоОформления = Форма.УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ПутьКДаннымПоля);
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
	КлючиПустыхСсылок = Новый СписокЗначений;
	КлючиПустыхСсылок.ЗагрузитьЗначения(ОбщегоНазначенияУТПовтИсп.ЗначенияПустыхКлючейРеестраДокументов());
	ОтборЭлемента.ПравоеЗначение = КлючиПустыхСсылок;

	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", "");
	
КонецПроцедуры

// Функция - Данные по штрих коду печатной формы
//
// Параметры:
//	Штрихкод - Строка - Штрихкод
//  ХозяйственныеОперацииИДокументы	 - 	ТаблицаЗначений -  таблица с колонкой "ПолноеИмяДокумента".
// 
// Возвращаемое значение:
//  Неопределено, Структура -
//
Функция ДанныеПоШтрихКодуПечатнойФормы(Штрихкод, ХозяйственныеОперацииИДокументы) Экспорт 
	
	ТаблицаОперацииНакладные = ОбщегоНазначенияУТ.ВыделенныеХозяйственныеОперацииИДокументы(ХозяйственныеОперацииИДокументы);
	
	ИменаДокументов = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ПолноеИмяДокумента");
	
	МассивПустыхСсылок = Новый Массив();
	
	Для Каждого ИмяДокумента Из ИменаДокументов Цикл
		ПустаяСсылка = ПредопределенноеЗначение(ИмяДокумента+".ПустаяСсылка");
		МассивПустыхСсылок.Добавить(ПустаяСсылка);
	КонецЦикла;
	
	МассивПустыхСсылок = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивПустыхСсылок);
	
	Ссылки = ШтрихкодированиеПечатныхФорм.ПолучитьСсылкуПоШтрихкодуТабличногоДокумента(Штрихкод, МассивПустыхСсылок);
	
	ДанныеПоШтрихКоду = Неопределено;
	Если Ссылки.Количество() > 0 Тогда
		
		ДанныеПоШтрихКоду = Новый Структура("Ссылка,КлючЗаписи");
		ДанныеПоШтрихКоду.Ссылка = Ссылки[0];
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	РеестрДокументов.ТипСсылки,
		|	РеестрДокументов.Организация,
		|	РеестрДокументов.ХозяйственнаяОперация,
		|	РеестрДокументов.Партнер,
		|	РеестрДокументов.Контрагент,
		|	РеестрДокументов.НаправлениеДеятельности,
		|	РеестрДокументов.ДополнительнаяЗапись,
		|	РеестрДокументов.Подразделение,
		|	РеестрДокументов.МестоХранения,
		|	РеестрДокументов.ДатаДокументаИБ,
		|	РеестрДокументов.Ссылка
		|ИЗ
		|	РегистрСведений.РеестрДокументов КАК РеестрДокументов
		|ГДЕ
		|	РеестрДокументов.Ссылка = &Ссылка";
		
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.УстановитьПараметр("Ссылка", Ссылки[0]);
		
		Результат = Запрос.Выполнить();
		Если Не Результат.Пустой() Тогда
			НайденнаяСтрока = Результат.Выгрузить()[0];
			СтруктураКлючевыхПолей = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(НайденнаяСтрока);
			ДанныеПоШтрихКоду.КлючЗаписи = РегистрыСведений.РеестрДокументов.СоздатьКлючЗаписи(СтруктураКлючевыхПолей);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ДанныеПоШтрихКоду;
	
КонецФункции

// Заполняет отборы по таблице хоз операций и типов документов.
// 
// Параметры:
//  ТаблицаЗначенийДоступно - ТаблицаЗначений - 
//  ОтборХозяйственныеОперации - СписокЗначений -
//  ОтборТипыДокументов - СписокЗначений -
Процедура ЗаполнитьОтборыПоТаблицеХозОперацийИТиповДокументов(ТаблицаЗначенийДоступно, ОтборХозяйственныеОперации, ОтборТипыДокументов) Экспорт
	
	СтруктураОтбора = Новый Структура("Отбор", Истина);
	ТЗХозОперацииИТипыДокументов = ТаблицаЗначенийДоступно.Скопировать(СтруктураОтбора, "ХозяйственнаяОперация,ИдентификаторОбъектаМетаданных");
	
	ТЗХозОперации = ТЗХозОперацииИТипыДокументов.Скопировать(,"ХозяйственнаяОперация");
	ТЗХозОперации.Свернуть("ХозяйственнаяОперация");
	ОтборХозяйственныеОперации.ЗагрузитьЗначения(ТЗХозОперации.ВыгрузитьКолонку("ХозяйственнаяОперация"));
	
	ТЗХозОперацииИТипыДокументов.Свернуть("ИдентификаторОбъектаМетаданных");
	ОтборТипыДокументов.ЗагрузитьЗначения(ТЗХозОперацииИТипыДокументов.ВыгрузитьКолонку("ИдентификаторОбъектаМетаданных"));
	
КонецПроцедуры

// Корректирует состав команд управления документами 
//
// Параметры:
//  СтруктураПараметров	 - см. ОбщегоНазначенияУТ.СтруктураПараметровНастройкиКнопокУправленияДокументами
//
Процедура НастроитьКнопкиУправленияДокументами(СтруктураПараметров) Экспорт
	
	Форма 												= СтруктураПараметров.Форма; // ФормаКлиентскогоПриложения - 
	ИмяТаблицыХозяйственныхОперацийИДокументов 			= СтруктураПараметров.ИмяТаблицыХозяйственныхОперацийИДокументов;
	ИмяКнопкиСкопировать 								= СтруктураПараметров.ИмяКнопкиСкопировать;
	ИмяКнопкиСкопироватьКонтекстноеМеню 				= СтруктураПараметров.ИмяКнопкиСкопироватьКонтекстноеМеню;
	ИмяКнопкиИзменить 									= СтруктураПараметров.ИмяКнопкиИзменить;
	ИмяКнопкиИзменитьКонтекстноеМеню 					= СтруктураПараметров.ИмяКнопкиИзменитьКонтекстноеМеню;
	ИмяКнопкиПровести 									= СтруктураПараметров.ИмяКнопкиПровести;
	ИмяКнопкиПровестиКонтекстноеМеню 					= СтруктураПараметров.ИмяКнопкиПровестиКонтекстноеМеню;
	ИмяКнопкиОтменаПроведения 							= СтруктураПараметров.ИмяКнопкиОтменаПроведения;
	ИмяКнопкиОтменаПроведенияКонтекстноеМеню 			= СтруктураПараметров.ИмяКнопкиОтменаПроведенияКонтекстноеМеню;
	ИмяКнопкиУстановитьПометкуУдаления 					= СтруктураПараметров.ИмяКнопкиУстановитьПометкуУдаления;
	ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню 	= СтруктураПараметров.ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню;
	ИмяГруппыСоздать 									= СтруктураПараметров.ИмяГруппыСоздать;
	ИмяГруппыСоздатьКонтекст							= СтруктураПараметров.ИмяГруппыСоздатьКонтекст;
	ПрефиксЭлементов									= СтруктураПараметров.ПрефиксЭлементов;
	
	ПравоДоступаДобавление = Ложь;
	ПравоДоступаИзменение  = Ложь;
	
	ОтобранныеСтроки = Форма[ИмяТаблицыХозяйственныхОперацийИДокументов].НайтиСтроки(Новый Структура("Отбор", Истина));
	
	Для Каждого Строка Из ОтобранныеСтроки Цикл
		
		Если ПравоДоступаДобавление И ПравоДоступаИзменение Тогда 
			Прервать;
		КонецЕсли;
		
		ПравоДоступаДобавление = ?(Строка.ПравоДоступаДобавление, Истина, ПравоДоступаДобавление);
		ПравоДоступаИзменение  = ?(Строка.ПравоДоступаИзменение, Истина, ПравоДоступаИзменение);
		
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяГруппыСоздать, "Видимость", ПравоДоступаДобавление);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяГруппыСоздатьКонтекст, "Видимость", ПравоДоступаДобавление);
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиСкопировать, "Видимость", ПравоДоступаДобавление);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиСкопироватьКонтекстноеМеню, "Видимость", ПравоДоступаДобавление);
	
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиИзменить, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиИзменитьКонтекстноеМеню, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиПровести, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиПровестиКонтекстноеМеню, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиОтменаПроведения, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиОтменаПроведенияКонтекстноеМеню, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиУстановитьПометкуУдаления, "Видимость", ПравоДоступаИзменение);
	ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы, ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню, "Видимость", ПравоДоступаИзменение);
	
	ВидимостьГруппыСоздать = ОбщегоНазначенияКлиентСервер.ЗначениеСвойстваЭлементаФормы(Форма.Элементы, ИмяГруппыСоздать, "Видимость");
	
	Если ВидимостьГруппыСоздать <> Неопределено И ВидимостьГруппыСоздать Тогда
		СформироватьКомандыСоздания(СтруктураПараметров);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает структуру параметров настройки кнопок управления документами.
// 
// Возвращаемое значение:
//  Структура - Свойства:
//		* Форма - ФормаКлиентскогоПриложения - сюда должна быть помещена управляемая форма, в которой происходит настройка кнопок
//		* ИмяТаблицыХозяйственныхОперацийИДокументов - Строка - имя реквизита формы, который является табличной частью и хранит хоз. операции и документы рабочего места
//		* ИмяКнопкиСкопировать - Строка - имя элемента формы (кнопки Скопировать)
//		* ИмяКнопкиИзменить - Строка - имя элемента формы (кнопки Изменить)
//		* ИмяКнопкиПровести - Строка - имя элемента формы (кнопки Провести)
//		* ИмяКнопкиОтменаПроведения - Строка - имя элемента формы (кнопки ОтменитьПроведение)
//		* ИмяКнопкиУстановитьПометкуУдаления - Строка - имя элемента формы (кнопки УстановитьПометкуУдаления)
//		* ИмяГруппыСоздать - Строка - имя элемента формы (группы Создать)
//		* МаксимальноеКоличествоКомандВПодменю - Число - максимальное количество команд в подменю
//		* ЗаголовокПодменюСоздать - Строка - позволяет определить заголовок подменю "Создать"
//
Функция СтруктураПараметровНастройкиКнопокУправленияДокументами() Экспорт 
	
	СтруктураПараметров = Новый Структура;
	СтруктураПараметров.Вставить("Форма");
	СтруктураПараметров.Вставить("ИмяТаблицыХозяйственныхОперацийИДокументов", "ХозяйственныеОперацииИДокументы");
	СтруктураПараметров.Вставить("ИмяКнопкиСкопировать");
	СтруктураПараметров.Вставить("ИмяКнопкиСкопироватьКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиИзменить");
	СтруктураПараметров.Вставить("ИмяКнопкиИзменитьКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиПровести");
	СтруктураПараметров.Вставить("ИмяКнопкиПровестиКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиОтменаПроведения");
	СтруктураПараметров.Вставить("ИмяКнопкиОтменаПроведенияКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяКнопкиУстановитьПометкуУдаления");
	СтруктураПараметров.Вставить("ИмяКнопкиУстановитьПометкуУдаленияКонтекстноеМеню");
	СтруктураПараметров.Вставить("ИмяГруппыСоздать", "ГруппаСоздатьГенерируемая");
	СтруктураПараметров.Вставить("ИмяГруппыСоздатьКонтекст", "ГруппаСоздатьГенерируемаяКонтекст");
	СтруктураПараметров.Вставить("ПрефиксЭлементов", "");
	СтруктураПараметров.Вставить("МаксимальноеКоличествоКомандВПодменю", 7);
	СтруктураПараметров.Вставить("ЗаголовокПодменюСоздать", "");
	
	Возврат СтруктураПараметров;
		
КонецФункции

// Формирует надпись отбора.
// 
// Параметры:
//  ИнформационнаяНадписьОтбор - ФорматированнаяСтрока -
//  ХозяйственныеОперацииИДокументы - ДанныеФормыКоллекция -
//  ОтборТипыДокументов - СписокЗначений - 
//  ОтборХозяйственныеОперации - СписокЗначений - 
Процедура СформироватьНадписьОтбор(ИнформационнаяНадписьОтбор, ХозяйственныеОперацииИДокументы, ОтборТипыДокументов, ОтборХозяйственныеОперации) Экспорт
	
	МассивСтрокНадписи = Новый Массив();
	
	ЕстьОтборы = ХозяйственныеОперацииИДокументы.НайтиСтроки(Новый Структура("Отбор",Ложь)).Количество() > 0;
	Если ЕстьОтборы Тогда
		
		ТекстНадписи = НСтр("ru = 'Показаны %КоличествоХозОпераций% по %КоличествоДокументов%'");
		
		КоличествоХозОпераций = СтроковыеФункцииКлиентСервер.ЧислоЦифрамиПредметИсчисленияПрописью(ОтборХозяйственныеОперации.Количество(),НСтр("ru = 'хоз. операция, хоз. операции, хоз. операций'"));
		ТекстНадписи = СтрЗаменить(ТекстНадписи,"%КоличествоХозОпераций%", КоличествоХозОпераций);
		КоличествоТипыДокументов = СтроковыеФункцииКлиентСервер.ЧислоЦифрамиПредметИсчисленияПрописью(ОтборТипыДокументов.Количество(),НСтр("ru = 'документу, документам, документам'"));
		ТекстНадписи = СтрЗаменить(ТекстНадписи,"%КоличествоДокументов%", КоличествоТипыДокументов);
		
		МассивСтрокНадписи.Добавить(ТекстНадписи);
		
		МассивСтрокНадписи.Добавить("  ");
		
		МассивСтрокНадписи.Добавить(Новый ФорматированнаяСтрока(НСтр("ru = 'Настроить'"),,,,"НастроитьОтбор"));
		
	Иначе
		
		МассивСтрокНадписи.Добавить(НСтр("ru = 'Показаны все документы журнала'"));
		МассивСтрокНадписи.Добавить("  ");
		МассивСтрокНадписи.Добавить(Новый ФорматированнаяСтрока(НСтр("ru = 'Настроить'"),,,,"НастроитьОтбор"));
		
	КонецЕсли;
	
	ИнформационнаяНадписьОтбор = Новый ФорматированнаяСтрока(МассивСтрокНадписи);
	
КонецПроцедуры

// Обрабатывает мультиязычную строку таблицы значений колонки дополнительно из РеестраДокументов
//
// Параметры:
//  ИмяКолонки - Строка - Имя колонки
//  Таблица - ТаблицаЗначений
//
Процедура ОбработатьМультиязычнуюКолонкуТаблицыЗначений(Таблица, ИмяКолонки = "Дополнительно") Экспорт
	
	Если Таблица.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Строка Из Таблица Цикл
		ЗначениеКолонки = Строка[ИмяКолонки]; // Строка -
		Если ПустаяСтрока(ЗначениеКолонки) Тогда
			Продолжить;
		КонецЕсли;
		Если СтрокаВВидеНСтр(ЗначениеКолонки) Тогда
			Строка[ИмяКолонки] = НСтр(ЗначениеКолонки);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область МетодыРаботыСЗапросом

// Выполняет запрос, формируя текст запроса из списка текста запросов. 
// 
// Параметры:
// 	Запрос - Запрос - Запрос.
// 	ТекстыЗапроса - СписокЗначений - Значение содержит текст запроса, представление содержит имя запроса.
// 	ДобавитьРазделитель - Булево - Добавить разделитель пакета запросов.
// 	УничтожитьСозданныеВременныеТаблицы - Булево - Уничтожить созданные временные таблицы
// 	
// Возвращаемое значение:
// 	Неопределено, Массив - Результат запроса.
Функция ВыполнитьПакетЗапросов(Запрос, ТекстыЗапроса, ДобавитьРазделитель = Истина, УничтожитьСозданныеВременныеТаблицы = Ложь) Экспорт
	
	Результаты = Новый Массив;
	
	МассивТекстовЗапросов 	 = Новый Массив;
	МассивУничтожаемыхТаблиц = Новый Массив;
	
	РежимОтладки = ОбщегоНазначения.РежимОтладки();
	ЗакрытьМенеджерВременныхТаблиц = Ложь;
	Если РежимОтладки И Запрос.МенеджерВременныхТаблиц = Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц; 
		ЗакрытьМенеджерВременныхТаблиц = Истина;
	КонецЕсли;
	
	ВыполнятьЗамерыПроизводительности = ОценкаПроизводительностиВызовСервераПовтИсп.ВыполнятьЗамерыПроизводительности();
	
	Если РежимОтладки И ВыполнятьЗамерыПроизводительности Тогда
		ИмяОбъектаМетаданных = "";
		Если Запрос.Параметры.Свойство("Ссылка") Тогда
			Если ТипЗнч(Запрос.Параметры.Ссылка) = Тип("Массив") Тогда
				ИмяОбъектаМетаданных = Запрос.Параметры.Ссылка[0].Метаданные().ПолноеИмя();
			Иначе
				ИмяОбъектаМетаданных = Запрос.Параметры.Ссылка.Метаданные().ПолноеИмя();
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
		
		// Сделано для удобства отладки проведения
		Если РежимОтладки Тогда
			
			Запрос.Текст = ТекстЗапроса.Значение;
			
			Если ВыполнятьЗамерыПроизводительности И ЗначениеЗаполнено(ИмяОбъектаМетаданных) И ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
				ВремяНачала = ОценкаПроизводительности.НачатьЗамерВремени();
				КлючеваяОперация = ИмяОбъектаМетаданных + "." + "ПакетЗапроса." + ТекстЗапроса.Представление;
				ПакетЗапроса = Запрос.ВыполнитьПакет();
				ОценкаПроизводительности.ЗакончитьЗамерВремени(КлючеваяОперация, ВремяНачала,,, Истина);
			Иначе
				ПакетЗапроса = Запрос.ВыполнитьПакет();
			КонецЕсли;
			
			ОбщегоНазначенияКлиентСервер.ДополнитьМассив(Результаты, ПакетЗапроса);
			
		Иначе
			
			Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
				МассивТекстовЗапросов.Добавить("// " + ТекстЗапроса.Представление);
			КонецЕсли; 
			
			МассивТекстовЗапросов.Добавить(ТекстЗапроса.Значение + ?(ДобавитьРазделитель, ОбщегоНазначения.РазделительПакетаЗапросов(), ""));
			
		КонецЕсли;
		
		Если УничтожитьСозданныеВременныеТаблицы
		 И ЗначениеЗаполнено(ТекстЗапроса.Представление)
		 И СтрНайти(ВРег(ТекстЗапроса.Значение), "ПОМЕСТИТЬ") <> 0 Тогда
			МассивУничтожаемыхТаблиц.Добавить(ТекстЗапроса.Представление);
		КонецЕсли;
		
	КонецЦикла;
		
	Для Каждого ИмяУдаляемойТаблицы Из МассивУничтожаемыхТаблиц Цикл
		
		Если РежимОтладки Тогда
			
			Запрос.Текст = СтрШаблон("УНИЧТОЖИТЬ %1", ИмяУдаляемойТаблицы);
			Результаты.Добавить(Запрос.Выполнить());
			
		Иначе
			
			МассивТекстовЗапросов.Добавить("УНИЧТОЖИТЬ " + ИмяУдаляемойТаблицы + ОбщегоНазначения.РазделительПакетаЗапросов());
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если МассивТекстовЗапросов.Количество() > 0 Тогда
		
		Запрос.Текст = СтрСоединить(МассивТекстовЗапросов, Символы.ПС);
		Результаты = Запрос.ВыполнитьПакет();
		
	КонецЕсли;
	
	Если ЗакрытьМенеджерВременныхТаблиц Тогда
		Запрос.МенеджерВременныхТаблиц.Закрыть(); 	
	КонецЕсли;
	
	Возврат Результаты;
	
КонецФункции

// Формирует пакет запросов и возвращает результат каждого запроса в виде таблицы значений.
//
// Параметры:
//	Запрос			- Запрос - запрос, параметры которого предварительно установлены.
//	ТекстыЗапроса	- СписокЗначений - в списке перечислены тексты запросов и их имена.
//	ОбходРезультата - ОбходРезультатаЗапроса - вариант обхода результата запроса.
//	ДобавитьРазделитель - Булево - добавлять разделитель между запросами из ТекстыЗапроса
//	УничтожитьСозданныеВременныеТаблицы - Булево - добавить уничтожение временных таблиц, создаваемых в ТекстыЗапроса
//										Для уничтожения таблице должно быть присвоено имя в ТекстыЗапроса.
//
// Возвращаемое значение:
//   Структура   - структура в которую помещены полученные таблицы.
//
Функция ВыгрузитьРезультатыЗапроса(Запрос,
								 	ТекстыЗапроса,
									ОбходРезультата = Неопределено,
									ДобавитьРазделитель = Ложь,
									УничтожитьСозданныеВременныеТаблицы = Ложь) Экспорт
	
	Таблицы = Новый Структура;
	
	// Инициализация варианта обхода результата запроса.
	Если ОбходРезультата = Неопределено Тогда
		ОбходРезультата = ОбходРезультатаЗапроса.Прямой;
	КонецЕсли;
	
	Результаты = ВыполнитьПакетЗапросов(Запрос, ТекстыЗапроса, ДобавитьРазделитель, УничтожитьСозданныеВременныеТаблицы);
	
	Если Результаты <> Неопределено Тогда
		
		// Помещение результатов запроса в таблицы.
		Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
			ИмяТаблицы = ТекстЗапроса.Представление;
			Если НЕ ПустаяСтрока(ИмяТаблицы) Тогда // имя таблицы
				Результат = Результаты[ТекстыЗапроса.Индекс(ТекстЗапроса)];
				Если Результат <> Неопределено Тогда
					ТаблицаЗапроса = Результат.Выгрузить(ОбходРезультата);
					Таблицы.Вставить(ИмяТаблицы, ТаблицаЗапроса);
				КонецЕсли;
			КонецЕсли;

		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Таблицы;
	
КонецФункции

// Формирует пакет запросов и возвращает результат каждого запроса в виде результата запроса.
//
// Параметры:
//	Запрос			- Запрос - запрос, параметры которого предварительно установлены.
//	ТекстыЗапроса	- СписокЗначений - в списке перечислены тексты запросов и их имена.
//	ДобавитьРазделитель - Булево - добавлять разделитель между запросами из ТекстыЗапроса
//	УничтожитьСозданныеВременныеТаблицы - Булево - добавить уничтожение временных таблиц, создаваемых в ТекстыЗапроса
//										Для уничтожения таблице должно быть присвоено имя в ТекстыЗапроса.
//
// Возвращаемое значение:
// 	Структура из КлючИЗначение - содержит: 
// 		* Ключ - Строка - Имя запроса
//		* Значение - РезультатЗапроса - Результат запроса
//
Функция ПолучитьРезультатыЗапроса(Запрос,
								 	ТекстыЗапроса,
									ДобавитьРазделитель = Истина,
									УничтожитьСозданныеВременныеТаблицы = Ложь) Экспорт
	
	РезультатыЗапроса = Новый Структура;

	Результаты = ВыполнитьПакетЗапросов(Запрос, ТекстыЗапроса, ДобавитьРазделитель, УничтожитьСозданныеВременныеТаблицы);

	Если Результаты = Неопределено Тогда
		Возврат РезультатыЗапроса;
	КонецЕсли;
			
	ИндексРезультата = -1;
	Для Каждого ТекстЗапроса Из ТекстыЗапроса Цикл
		
		ИмяТаблицы = ТекстЗапроса.Представление;
		ПакетЗапроса = СтрРазделить(СокрЛП(ТекстЗапроса.Значение), ";", Ложь);
		ИндексРезультата = ИндексРезультата + ПакетЗапроса.Количество(); 

		Если НЕ ПустаяСтрока(ИмяТаблицы) Тогда
			Результат = Результаты[ИндексРезультата];
			РезультатыЗапроса.Вставить(ИмяТаблицы, Результат);
		КонецЕсли;

	КонецЦикла;
	
	Возврат РезультатыЗапроса;

КонецФункции

// Возвращает структуру границ оборотов по регистру
//
// Параметры:
//  ИмяРегистра - Строка - Имя регистра накопления.
//  Отборы      - Строка - Отборы виртуальной таблицы оборотов, для которой необходимо получить границы.
//  Параметры   - Структура - Параметры запроса для отборов виртуальной таблицы.
//
// Возвращаемое значение:
//  Структура - Структура границ со свойствами:
//  	* МинимальнаяДата - Дата - Начальная граница оборотов.
//  	* МаксимальнаяДата - Дата - Конечная граница оборотов.
//
Функция ГраницыОборотовРегистра(ИмяРегистра, Отборы, Параметры) Экспорт
	
	// Без отбора по умолчанию по полю Активность, т.к. по нему нет индекса,
	// из-за чего запрос может выполняться недопустимо долго.
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	МИНИМУМ(Таблица.Период)  КАК МинимальнаяДата,
	|	МАКСИМУМ(Таблица.Период) КАК МаксимальнаяДата
	|ИЗ
	|	&ИмяТаблицы КАК Таблица
	|ГДЕ
	|	&Отбор";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицы", "РегистрНакопления." + ИмяРегистра);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Отбор", ?(ПустаяСтрока(Отборы), "ИСТИНА", Отборы));
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Для каждого Параметр Из Параметры Цикл
		Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
	КонецЦикла;
	
	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();
	УстановитьПривилегированныйРежим(Ложь);
	
	СтруктураГраниц = Новый Структура;
	Если Выборка.Следующий() И ЗначениеЗаполнено(Выборка.МинимальнаяДата) Тогда
		СтруктураГраниц.Вставить("МинимальнаяДата", Выборка.МинимальнаяДата);
		СтруктураГраниц.Вставить("МаксимальнаяДата", Выборка.МаксимальнаяДата);
	Иначе
		СтруктураГраниц.Вставить("МинимальнаяДата", '00010101');
		СтруктураГраниц.Вставить("МаксимальнаяДата", '39991231');
	КонецЕсли;
	
	Возврат СтруктураГраниц;
	
КонецФункции

// Устарела. Следует использовать ОбщегоНазначения.РазделительПакетаЗапросов.
// Возвращает текст разделителя для вставки между текстами пакета запросов.
//
// Возвращаемое значение:
//  Строка - текст разделителя.
//
Функция РазделительЗапросовВПакете() Экспорт
	
	Возврат "
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";
	
КонецФункции

// Возвращает текст разделителя для вставки между текстами объединяемых запросов.
//
// Параметры:
//  ТолькоУникальные - Булево - признак того, что необходимо выбирать только уникальные записи при объединении.
//
// Возвращаемое значение:
//  Строка - текст разделителя.
//
Функция РазделительЗапросовВОбъединении(ТолькоУникальные = Ложь) Экспорт
	
	Если ТолькоУникальные Тогда
		Возврат "
		|
		|ОБЪЕДИНИТЬ
		|
		|";
	Иначе
		Возврат "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
	КонецЕсли;
	
КонецФункции

//Добавляет настройку отбора для запросов в коллекцию 
//
// Параметры:
//  Отбор               - Соответствие - коллекция настроек отборов
//  ЛевоеЗначение       - Строка       - левое значение отбора в запросах
//  ПравоеЗначение      - Строка       - правое значение отбора в запросах
//  ВидСравненияЗапроса - Строка       - вид сравнения запроса, по умолчанию: "В"
//
Процедура ДобавитьЭлементОтбораВКоллекцию(Отбор, ЛевоеЗначение, ПравоеЗначение, ВидСравненияЗапроса = "") Экспорт
	
	ВидСравненияПравоеЗначение = Новый Структура;
	
	ВидСравненияПравоеЗначение.Вставить(
		"ВидСравнения",
		?(ЗначениеЗаполнено(ВидСравненияЗапроса),
			ВидСравненияЗапроса,
			"В"));
		
	ВидСравненияПравоеЗначение.Вставить("ПравоеЗначение", ПравоеЗначение);
		
	Отбор.Вставить(ЛевоеЗначение, ВидСравненияПравоеЗначение);
	
КонецПроцедуры

// Добавляет ключевые реквизиты распоряжения в коллекцию отбора
// 
// Параметры:
// 	КлючевыеРеквизиты - Массив
// 	Отбор - Соответствие
//
Процедура ДобавитьОтборПоКлючевымРеквизитамРаспоряжения(КлючевыеРеквизиты, Отбор) Экспорт
	
	Для Каждого ТекРеквизит Из КлючевыеРеквизиты Цикл
		
		ДобавитьЭлементОтбораВКоллекцию(
			Отбор,
			"ТаблицаРаспоряжений." + ТекРеквизит,
			"&" + ТекРеквизит,
			"=");
		
	КонецЦикла;
	
КонецПроцедуры

// Формирует текст условий запроса по коллекции отборов
// 
// Параметры:
// 	Отбор - Соответствие
// Возвращаемое значение:
// 	Строка
//
Функция ТекстОтбораПоКоллекцииОтборов(Отбор) Экспорт
	
	ТекстОтбора = "ИСТИНА";
	
	Если ТипЗнч(Отбор) = Тип("Структура")
		Или ТипЗнч(Отбор) = Тип("Соответствие") Тогда
		
		Для Каждого ТекОтбор Из Отбор Цикл
			
			ЛевоеЗначение = "(" + ТекОтбор.Ключ + ") ";
			
			Если ТипЗнч(ТекОтбор.Значение) = Тип("Структура")
				Или ТипЗнч(ТекОтбор.Значение) = Тип("Соответствие") Тогда
				ВидСравненияЗапроса = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ТекОтбор.Значение, "ВидСравнения", "В");
				ПравоеЗначение = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ТекОтбор.Значение, "ПравоеЗначение", "ИСТИНА");
			Иначе
				ВидСравненияЗапроса = "В";
				ПравоеЗначение = "&" + ТекОтбор.Значение;
			КонецЕсли;
			
			ТекстОтбора =
				ТекстОтбора + " И "
				+ ЛевоеЗначение
				+ ВидСравненияЗапроса
				+ " (" + ПравоеЗначение + ")";
				
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ТекстОтбора;
	
КонецФункции

// Формирует текст запроса получения данных табличной части документа
// 
// Параметры:
// 	Ссылка - ЛюбаяСсылка
// 	ИмяТЧ - Строка
// 	ДанныеИзИБ - Булево - флаг определяющий откуда будут получены данные табличной части - из ИБ, либо из параметра запроса
// 	ПоляИндекса - Строка, Массив - перечень полей, по которым будет построен индекс временной таблицы
// 	ИмяПоляОтменено - Строка
// Возвращаемое значение:
// 	Строка - текст запроса получения данных табличной части документа
//
Функция ТекстЗапросаДанныеТЧОбъекта(Ссылка, ИмяТЧ, ДанныеИзИБ, ПоляИндекса = "", ИмяПоляОтменено = "Отменено") Экспорт
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	&ПоляВыборки
	|ПОМЕСТИТЬ ИмяТЧ
	|ИЗ
	|	ТекстИсточникДанных КАК ТабличнаяЧасть
	|ГДЕ
	|	&ОтборПоСсылке
	|	И &ЕстьОтменено
	|";
	
	ТабличнаяЧасть = Ссылка.Метаданные().ТабличныеЧасти[ИмяТЧ];
	ПоляВыборки    = Новый Массив;
	ЕстьОтменено   = Ложь;
	
	ШаблонПоля = "ТабличнаяЧасть.%1 КАК %2";
	Для Каждого ТекРеквизит Из ТабличнаяЧасть.СтандартныеРеквизиты Цикл
		ПоляВыборки.Добавить(СтрШаблон(ШаблонПоля, ТекРеквизит.Имя, ТекРеквизит.Имя));
	КонецЦикла;
	
	Для Каждого ТекРеквизит Из ТабличнаяЧасть.Реквизиты Цикл
		
		Если ТекРеквизит.Имя = ИмяПоляОтменено Тогда
			ЕстьОтменено = Истина;
		КонецЕсли;
		
		ПоляВыборки.Добавить(СтрШаблон(ШаблонПоля, ТекРеквизит.Имя, ТекРеквизит.Имя));
		
	КонецЦикла;
	
	ТекстИсточникДанных = "&" + ИмяТЧ;
	ТекстОтборПоСсылке = "ИСТИНА";
	
	Если ДанныеИзИБ Тогда
		ТекстИсточникДанных = СтрШаблон(ТекстИсточникДанных, РаботаСФормулами.ПолноеИмяТаблицыДанных(ТабличнаяЧасть));
		ТекстОтборПоСсылке = "ТабличнаяЧасть.Ссылка В(&Ссылка)";
	КонецЕсли;
	
	ТекстЕстьОтменено = "ИСТИНА";
	Если ЕстьОтменено Тогда
		ТекстЕстьОтменено = "НЕ ТабличнаяЧасть.Отменено";
	КонецЕсли;
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ТекстИсточникДанных", ТекстИсточникДанных);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборПоСсылке",      ТекстОтборПоСсылке);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИмяТЧ",               ИмяТЧ);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ПоляВыборки", СтрСоединить(ПоляВыборки, "," + Символы.ПС));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ЕстьОтменено", ТекстЕстьОтменено);
	
	Если ТипЗнч(ПоляИндекса) = Тип("Массив") Тогда
		ПоляИндекса = СтрСоединить(ПоляИндекса, ",");
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПоляИндекса) Тогда
		ТекстЗапроса =
			ТекстЗапроса + Символы.ПС +
			"ИНДЕКСИРОВАТЬ ПО
			|" + ПоляИндекса;
	КонецЕсли;
	
	Возврат ТекстЗапроса;
	
КонецФункции

// Структура параметров формирования текста запроса распоряжений накладных
// 
// Возвращаемое значение:
//  Структура - Описание:
//		* ИменаРеквизитовНакладной - Структура -
//		* Отбор - Соответствие -
//		* ИмяВТ - Строка -
//		* СформироватьВТ - Булево -
//
Функция ПараметрыТекстаЗапросаРаспоряженийНакладных() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("СформироватьВТ", Ложь);
	Результат.Вставить("ИмяВТ", "РаспоряженияНакладной");
	Результат.Вставить("Отбор", Новый Соответствие);
	
	Возврат Результат;
	
КонецФункции

// Формирует список временных таблиц.
//
// Параметры:
//  МенеджерВременныхТаблиц	 - МенеджерВременныхТаблиц	 - менеджер временных таблиц, таблицы которого нужно получить.
// 
// Возвращаемое значение:
//  Массив - Временные таблицы, находящиеся в менеджере.
//
Функция СписокВременныхТаблиц(МенеджерВременныхТаблиц) Экспорт

	СписокВременныхТаблиц = Новый Массив;
	
	Для каждого Таблица Из МенеджерВременныхТаблиц.Таблицы Цикл
		СписокВременныхТаблиц.Добавить(Таблица.ПолноеИмя);
	КонецЦикла; 
	
	Возврат СписокВременныхТаблиц;

КонецФункции

// Уничтожает временные таблицы менеджера временных таблиц.
//
// Параметры:
//  МенеджерВременныхТаблиц	 - МенеджерВременныхТаблиц	 - менеджер временных таблиц, таблицы которого нужно уничтожить.
//  СписокТаблиц - Строка, Массив из Строка - имена временных таблиц для уничтожения, разделенные запятыми. Если параметр не установлен - все таблицы.
//  ИсключаяТаблицы	- Строка, Массив из Строка - имена временных таблиц, которые нужно оставить, разделенные запятыми.
//
Процедура УничтожитьВременныеТаблицы(МенеджерВременныхТаблиц, СписокТаблиц = Неопределено, ИсключаяТаблицы = Неопределено) Экспорт
	
	Если ИсключаяТаблицы <> Неопределено Тогда
		МассивИсключаемыхТаблиц = ?(ТипЗнч(ИсключаяТаблицы) = Тип("Массив"), ИсключаяТаблицы, СтрРазделить(ИсключаяТаблицы, ","));
	Иначе
		МассивИсключаемыхТаблиц = Новый Массив();
	КонецЕсли;
	
	Если СписокТаблиц <> Неопределено Тогда
		МассивТаблиц = ?(ТипЗнч(СписокТаблиц) = Тип("Массив"), СписокТаблиц, СтрРазделить(СписокТаблиц, ","));
	Иначе
		МассивТаблиц = Новый Массив();
		Для Каждого Таблица Из МенеджерВременныхТаблиц.Таблицы Цикл
			Если МассивИсключаемыхТаблиц.Найти(Таблица.ПолноеИмя) = Неопределено Тогда
				МассивТаблиц.Добавить(Таблица.ПолноеИмя);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если МассивТаблиц.Количество() > 0 Тогда
		ТекстЗапроса = "";
		Для Каждого ИмяТаблицы Из МассивТаблиц Цикл
			ТекстЗапроса = ТекстЗапроса + "УНИЧТОЖИТЬ " + ИмяТаблицы + "; ";
		КонецЦикла;
		Запрос = Новый Запрос(ТекстЗапроса);
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Запрос.Выполнить();
	КонецЕсли;
	
КонецПроцедуры

// Преобразователь текста запроса с временными таблицами - если поле есть, то оно выбирается, если нет - текст
// заменяется на значение по умолчанию. В тексте запроса поле должно быть в виде &ТекстПоляИмяТаблицыИмяПоля_
// (начитается с "&ТекстПоля", затем имя таблицы источника данных запроса, потом собственно имя поля и "_").
//
// Параметры:
//	МенеджерВременныхТаблиц	 - МенеджерВременныхТаблиц -менеджер временных таблиц запроса.
//	ТекстЗапроса			 - Строка - текст запроса, в котором выполняется преобразование.
//	ТекстЗамены				 - Строка - заменяемый текст запроса.
//	ИмяТаблицы				 - Строка - имя временной таблицы, для которой выполняется преобразование текста.
//	ИмяПоля					 - Строка - имя поля, наличие которого проверяет во временной таблице.
//	ТекстВыражениеВыборки	 - Строка - выражение выборки поля в тексте запроса. Значение по умолчанию- пустая строка.
//										Если значение не указано - выбирается ИмяТаблицы.ИмяПоля.
//	ТекстЗначенияПоУмолчанию - Строка - значение поля по умолчанию. Если не указано, тогда значение по умолчанию - "НЕОПРЕДЕЛЕНО".
//
Процедура ЗаменитьОтсутствующиеПоляВтВТекстеЗапроса(МенеджерВременныхТаблиц,
													ТекстЗапроса,
													ТекстЗамены,
													ИмяТаблицы,
													ИмяПоля,
													ТекстВыражениеВыборки = "",
													ТекстЗначенияПоУмолчанию = "НЕОПРЕДЕЛЕНО") Экспорт
	
	ВременнаяТаблица = МенеджерВременныхТаблиц.Таблицы[ИмяТаблицы]; // ВременнаяТаблицаЗапроса -
	
	Если ВременнаяТаблица.Колонки.Найти(ИмяПоля) <> Неопределено Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
									ТекстЗамены,
									?(ПустаяСтрока(ТекстВыражениеВыборки),
										ИмяТаблицы + "." + ИмяПоля,
										ТекстВыражениеВыборки));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
									ТекстЗамены,
									ТекстЗначенияПоУмолчанию);
	КонецЕсли;
	
КонецПроцедуры

// Преобразователь текста запроса, источником данных которого является таблица значений.
// Если поле есть, то оно выбирается, если нет - текст  заменяется на значение по умолчанию.
// В тексте запроса поле должно быть в виде &ТекстПоляИмяТаблицыИмяПоля_ (начитается с "&ТекстПоля", затем имя таблицы
// источника данных запроса, потом собственно имя поля и "_").
//
// Параметры:
//	Таблица					 - ТаблицаЗначений, ТабличнаяЧасть - таблица источник данных для текста запроса.
//	ТекстЗапроса			 - Строка - текст запроса, в котором выполняется преобразование.
//	ТекстЗамены				 - Строка - заменяемый текст запроса.
//	ИмяТаблицы				 - Строка - имя таблицы источника данных в запросе, для которой выполняется преобразование текста.
//	ИмяПоля					 - Строка - имя поля, наличие которого проверяет в таблице значений.
//	ТекстВыражениеВыборки	 - Строка - выражение выборки поля в тексте запроса. Значение по умолчанию- пустая строка.
//										Если значение не указано - выбирается ИмяТаблицы.ИмяПоля.
//	ТекстЗначенияПоУмолчанию - Строка - значение поля по умолчанию. Если не указано, тогда значение по умолчанию - "НЕОПРЕДЕЛЕНО".
//
Процедура ЗаменитьОтсутствующиеПоляТаблицыЗначенийВТекстеЗапроса(Знач Таблица,
																ТекстЗапроса,
																ТекстЗамены,
																ИмяТаблицы,
																ИмяПоля,
																ТекстВыражениеВыборки = "",
																ТекстЗначенияПоУмолчанию = "НЕОПРЕДЕЛЕНО") Экспорт
	
	Если ТипЗнч(Таблица) <> Тип("ТаблицаЗначений") Тогда
		Таблица = Таблица.ВыгрузитьКолонки();
	КонецЕсли;
	
	Если Таблица.Колонки.Найти(ИмяПоля) <> Неопределено Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
									ТекстЗамены,
									?(ПустаяСтрока(ТекстВыражениеВыборки),
										ИмяТаблицы + "." + ИмяПоля,
										ТекстВыражениеВыборки));
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса,
									ТекстЗамены,
									ТекстЗначенияПоУмолчанию);
	КонецЕсли;
	
КонецПроцедуры

// Формирует текст распределения суммы в запросе.
// 
// Параметры:
//  ИмяПоляСумма - Строка - Имя поля, содержащего сумму, которую нужно распределить
//  ИмяПоляБаза - Строка - Имя поля, содержащего коэффициент распределения
//  ИмяПоляБазаНакопленная - Строка - Имя поля, содержащего сумму коэффициентов предыдущих строк
//  ИмяПоляСуммаБазы - Строка - Имя поля, содержащего сумму всех коэффициентов
// 
// Возвращаемое значение:
//  Строка - Текст распределения суммы
Функция ТекстРаспределенияСуммы(ИмяПоляСумма, ИмяПоляБаза = Неопределено, ИмяПоляБазаНакопленная = Неопределено, ИмяПоляСуммаБазы = Неопределено) Экспорт

	Если ИмяПоляБаза = Неопределено Тогда
		ИмяПоляБаза = "ЕСТЬNULL(СпособыОтраженияРасходов.База, 0)";
	КонецЕсли;
	
	Если ИмяПоляБазаНакопленная = Неопределено Тогда
		ИмяПоляБазаНакопленная = "ЕСТЬNULL(СпособыОтраженияРасходов.БазаНакопленная, 0)";
	КонецЕсли;
	
	Если ИмяПоляСуммаБазы = Неопределено Тогда
		ИмяПоляСуммаБазы = "ЕСТЬNULL(СпособыОтраженияРасходов.СуммаБазы, 0)";
	КонецЕсли;
	
	ТекстЗапроса =	
	"	ВЫБОР
	|		КОГДА (&СуммаБазы_Шаблон) = 0
	|			ТОГДА 0
	|		ИНАЧЕ (ВЫРАЗИТЬ(&Сумма_Шаблон
	|				* (&БазаНакопленная_Шаблон + &База_Шаблон) 
	|					/ &СуммаБазы_Шаблон КАК ЧИСЛО(31,2)))
	|			- (ВЫРАЗИТЬ(&Сумма_Шаблон * &БазаНакопленная_Шаблон / &СуммаБазы_Шаблон КАК ЧИСЛО(31,2)))
	|	КОНЕЦ";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СуммаБазы_Шаблон", ИмяПоляСуммаБазы);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Сумма_Шаблон", ИмяПоляСумма);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&БазаНакопленная_Шаблон", ИмяПоляБазаНакопленная);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&База_Шаблон", ИмяПоляБаза);
	
	Возврат ТекстЗапроса;

КонецФункции

#КонецОбласти

#Область ГлобальныйПоиск

// Находит документы в реестре документов и дополняет результат глобального поиска.
// 
// Параметры:
//  СтрокаПоиска - Строка - строка, которую ввел пользователь
//  РезультатПоиска - РезультатГлобальногоПоиска - дополняемый результат поиска
Процедура НайтиДокументВРеестре(СтрокаПоиска, РезультатПоиска) Экспорт
	
	Слова = СтрРазделить(СтрокаПоиска, " ", Ложь);
	
	ОбъединитьДатуИВремя(Слова);
	
	Если Слова.Количество() > 3 Тогда
		ДатаДокумента = ДатаИзСтроки(Слова.Получить(Слова.ВГраница()));
// Наименование Номер от Дата
		Если ЗначениеЗаполнено(ДатаДокумента) Тогда
			Если (ВРег(Слова.Получить(Слова.ВГраница() - 1)) = НСтр("ru = 'ОТ'")
				Или ВРег(Слова.Получить(Слова.ВГраница() - 1)) = "DATED") Тогда
				СловаНазвания = Новый Массив;
				Для Индекс = 0 По Слова.ВГраница() - 3 Цикл
					СловаНазвания.Добавить(Слова.Получить(Индекс));
				КонецЦикла;
				НаименованиеДокумента = СтрСоединить(СловаНазвания, " ");
				Для Каждого ОбъектМетаданных Из Метаданные.Документы Цикл
					Если ВРег(ОбъектМетаданных.Синоним) = ВРег(НаименованиеДокумента) Тогда
						ТипСсылки = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Документ." + ОбъектМетаданных.Имя);
						Прервать;
					КонецЕсли;
				КонецЦикла;
				ВыбратьДокументыИзРеестра(РезультатПоиска, Слова.Получить(Слова.ВГраница() - 2), ТипСсылки,
					НаименованиеДокумента, ДатаДокумента);
			КонецЕсли;
		Иначе
// Наименование Номер
			НайтиДокументВРеестреПоНаименованиюИНомеру(Слова, РезультатПоиска)
		КонецЕсли;
	ИначеЕсли Слова.Количество() = 3 Тогда
		ДатаДокумента = ДатаИзСтроки(Слова.Получить(Слова.ВГраница()));
		Если ЗначениеЗаполнено(ДатаДокумента) Тогда
			Если (ВРег(Слова.Получить(Слова.ВГраница() - 1)) = НСтр("ru = 'ОТ'")
				Или ВРег(Слова.Получить(Слова.ВГраница() - 1)) = "DATED") Тогда
// Номер от Дата
				ВыбратьДокументыИзРеестра(РезультатПоиска, Слова.Получить(0), , , ДатаДокумента);
			КонецЕсли;
		Иначе
// Наименование Номер
			НайтиДокументВРеестреПоНаименованиюИНомеру(Слова, РезультатПоиска)
		КонецЕсли;
	ИначеЕсли Слова.Количество() = 2 Тогда
// Наименование Номер
		НайтиДокументВРеестреПоНаименованиюИНомеру(Слова, РезультатПоиска)
	ИначеЕсли Слова.Количество() = 1 И СтрокаСодержитЦифру(Слова.Получить(0)) Тогда
// Номер
		ВыбратьДокументыИзРеестра(РезультатПоиска, Слова.Получить(0));
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

// Возвращает представление переданного объекта.
//
// Параметры:
//	ПараметрОбъект - Строка - 
//	               - ОбъектМетаданных - объект для получения представления
//
// Возвращаемое значение:
//	Строка - представление объекта
//
Функция ПредставлениеОбъекта(ПараметрОбъект) Экспорт
	
	Если ПараметрОбъект = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	МетаданныеОбъекта = ?(ТипЗнч(ПараметрОбъект) = Тип("Строка"), Метаданные.НайтиПоПолномуИмени(ПараметрОбъект), ПараметрОбъект);
	
	Представление = Новый Структура("ПредставлениеОбъекта");
	ЗаполнитьЗначенияСвойств(Представление, МетаданныеОбъекта);
	Если Не ПустаяСтрока(Представление.ПредставлениеОбъекта) Тогда
		Возврат Представление.ПредставлениеОбъекта;
	КонецЕсли;
	
	Возврат МетаданныеОбъекта.Представление();
	
КонецФункции

// Выполняет программное рекурсивное копирование элементов формы.
// Новые элементы будут привязаны к тем же данным, что и исходные.
// Для новых элементов будут подключены те же обработчики событий, что и к исходным.
//
// Параметры:
// 	Форма - ФормаКлиентскогоПриложения - Форма, элементы на которой требуется скопировать.
// 	Источник - ГруппаФормы - Группа, подчиненные элементы которой необходимо скопировать.
// 	Приемник - ГруппаФормы - Группа, в которую необходимо добавить новые элементы.
// 	Постфикс - Строка - Постфикс, который будет добавлен к именам новых элементов.
//
Процедура СкопироватьЭлементыФормыРекурсивно(Форма, Источник, Приемник, Постфикс) Экспорт
	
	КопируемыеСвойстваЭлементовФормы = КопируемыеСвойстваЭлементовФормы();
	КопируемыеОбработчикиСобытий = КопируемыеОбработчикиЭлементовФормы();
	
	Для каждого ПодчиненныйЭлемент Из Источник.ПодчиненныеЭлементы Цикл
		
		ТипЭлемента = ТипЗнч(ПодчиненныйЭлемент);
		
		НовыйЭлемент = Форма.Элементы.Добавить(
							ПодчиненныйЭлемент.Имя + Постфикс,
							ТипЗнч(ПодчиненныйЭлемент),
							Приемник);
		
		КопируемыеСвойстваЭлемента = КопируемыеСвойстваЭлементовФормы[ТипЭлемента];
		Если КопируемыеСвойстваЭлемента = Неопределено Тогда
			ЗаполнитьЗначенияСвойств(НовыйЭлемент, ПодчиненныйЭлемент);
		Иначе
			Для каждого СвойствоЭлемента Из КопируемыеСвойстваЭлемента Цикл
				Если Не ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ПодчиненныйЭлемент, СвойствоЭлемента) Тогда
					Продолжить;
				КонецЕсли;
				Если ПодчиненныйЭлемент[СвойствоЭлемента] = ""
						ИЛИ ПодчиненныйЭлемент[СвойствоЭлемента] = Неопределено Тогда
					Продолжить;
				КонецЕсли;
				НовыйЭлемент[СвойствоЭлемента] = ПодчиненныйЭлемент[СвойствоЭлемента];
			КонецЦикла;
		КонецЕсли;
		
		КопируемыеОбработчикиЭлемента = КопируемыеОбработчикиСобытий[ТипЭлемента];
		Если КопируемыеОбработчикиЭлемента <> Неопределено Тогда
			Для каждого ИмяСобытия Из КопируемыеОбработчикиЭлемента Цикл
				ИмяПроцедуры = ПодчиненныйЭлемент.ПолучитьДействие(ИмяСобытия);
				Если ИмяПроцедуры <> "" Тогда
					НовыйЭлемент.УстановитьДействие(ИмяСобытия, ИмяПроцедуры);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если ТипЭлемента = Тип("ТаблицаФормы") Тогда
			СкопироватьЭлементыФормыРекурсивно(
				Форма, ПодчиненныйЭлемент.КоманднаяПанель, НовыйЭлемент.КоманднаяПанель, Постфикс);
		КонецЕсли;
		
		Если ТипЭлемента = Тип("ГруппаФормы")
				ИЛИ ТипЭлемента = Тип("ТаблицаФормы") Тогда
			СкопироватьЭлементыФормыРекурсивно(
				Форма, ПодчиненныйЭлемент, НовыйЭлемент, Постфикс);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Отключает проверку заполнения реквизитов.
// 
// Параметры:
// 	ПараметрыРеквизитовОбъекта - Массив из см. ОбщегоНазначенияУТКлиентСервер.НовыйПараметрРеквизитаОбъекта - Параметры реквизитов.
// 	МассивНепроверяемыхРеквизитов - Массив из Строка - 
Процедура ОтключитьПроверкуЗаполненияРеквизитовОбъекта(ПараметрыРеквизитовОбъекта, МассивНепроверяемыхРеквизитов) Экспорт

	Если ПараметрыРеквизитовОбъекта = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Для каждого ПараметрыРеквизита Из ПараметрыРеквизитовОбъекта Цикл
		Если ЗначениеЗаполнено(ПараметрыРеквизита.ИмяРеквизита)
			И (ПараметрыРеквизита.Свойство = "Видимость"
				ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотр"
				ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненного"
				ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненногоБезОчистки"
				ИЛИ ПараметрыРеквизита.Свойство = "ОтметкаНезаполненного"
				ИЛИ ПараметрыРеквизита.Свойство = "АвтоОтметкаНезаполненного") Тогда
			
			Если (ПараметрыРеквизита.Свойство = "Видимость"
						ИЛИ ПараметрыРеквизита.Свойство = "ОтметкаНезаполненного"
						ИЛИ ПараметрыРеквизита.Свойство = "АвтоОтметкаНезаполненного")
					И ПараметрыРеквизита.Значение = Ложь 
				ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненного"
					И ПараметрыРеквизита.Значение = Истина
				ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотрБезОтметкиНезаполненногоБезОчистки"
					И ПараметрыРеквизита.Значение = Истина
				ИЛИ ПараметрыРеквизита.Свойство = "ТолькоПросмотр"
					И ПараметрыРеквизита.Значение = Истина Тогда
					
				МассивНепроверяемыхРеквизитов.Добавить(ПараметрыРеквизита.ИмяРеквизита);
			КонецЕсли;
			
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает управляемую блокировку таблицы.
//
// Параметры:
//  СтруктураПараметров 		- Структура - Структура параметров блокировки. Обязательный параметр.
//								Обязательно должна содержать свойства:
//								"ИмяТаблицы" - Строка - имя таблицы, на которую накладывается блокировка.
//									Например: "АвансовыйОтчет"
//								Необязательные свойства:
//								"ТипТаблицы" - Строка - тип таблицы, на которую накладывается блокировка.
//									Пространство блокировки состоит из типа таблицы и имени таблицы.
//									Например: "Документ"
//									Значение по умолчанию: "РегистрНакопления"
//								"РежимБлокировки" - РежимБлокировкиДанных - режим накладываемой блокировки.
//									Значение по умолчанию: РежимБлокировкиДанных.Исключительный
//								"ИсточникДанных" - источник данных для блокировки.
//									Может передаваться значение любого типа, поддерживаемого свойством ИсточникДанных элемента блокировки,
//									а также типа "Менеджер временных таблиц".
//									Если в структуре нет этого свойства - блокировки через ИспользоватьИзИсточникаДанных() не накладываются.
//								"ИмяВременнойТаблицы" - Строка - имя временной таблицы менеджера временных таблиц, которая служит источником данных для блокировки.
//									Обязательно должно указываться, если в качестве источника данных процедуре передан менеджер временных таблиц.
//  КоллекцияЗначенийБлокировки	- Структура, Соответствие - описывает значения блокировки, накладываемые с помощью УстановитьЗначение().
//									Ключ - поле блокировки - <Строка или (только для соответствия) ПланыВидовХарактеристикСсылка>,
//										ПланыВидовХарактеристикСсылка используется для блокировки регистра бухгалтерии по виду субконто.
//									Значение - блокируемое значение - <Произвольный тип>.
//									Если передано Неопределено или если коллекция не содержит ни одного элемента -
//									блокировки методом УстановитьЗначение() не накладываются.
//  КоллекцияОписанияИсточника	- Структура, Соответствие - описывает значения блокировки, накладываемые с помощью ИспользоватьИзИсточникаДанных().
//									Ключ - поле блокировки - <Строка или (только для соответствия) ПланыВидовХарактеристикСсылка>,
//										ПланыВидовХарактеристикСсылка используется для блокировки регистра бухгалтерии по виду субконто.
//									Значение - поле таблицы источника данных - <Строка>.
//									Если передано Неопределено или если коллекция не содержит ни одного элемента -
//									блокировки методом ИспользоватьИзИсточникаДанных() не накладываются.
//
Процедура УстановитьУправляемуюБлокировку(СтруктураПараметров, КоллекцияЗначенийБлокировки = Неопределено, КоллекцияОписанияИсточника = Неопределено) Экспорт

	Если НЕ ТипЗнч(СтруктураПараметров) = Тип("Структура") Тогда
		Возврат;
	КонецЕсли;

	ИспользоватьЗначенияБлокировки = КоллекцияЗначенийБлокировки <> Неопределено
		И (ТипЗнч(КоллекцияЗначенийБлокировки) = Тип("Структура")
			ИЛИ ТипЗнч(КоллекцияЗначенийБлокировки) = Тип("Соответствие"))
		И КоллекцияЗначенийБлокировки.Количество() > 0;

	ИспользоватьИсточникДанных     = КоллекцияОписанияИсточника <> Неопределено
		И (ТипЗнч(КоллекцияОписанияИсточника) = Тип("Структура")
			ИЛИ ТипЗнч(КоллекцияОписанияИсточника) = Тип("Соответствие"))
		И КоллекцияОписанияИсточника.Количество() > 0
		И СтруктураПараметров.Свойство("ИсточникДанных");

	Если НЕ ИспользоватьЗначенияБлокировки И НЕ ИспользоватьИсточникДанных Тогда
		Возврат;
	КонецЕсли;

	Блокировка = Новый БлокировкаДанных;

	ТипТаблицы = ?(СтруктураПараметров.Свойство("ТипТаблицы"), СтруктураПараметров.ТипТаблицы, "РегистрНакопления");
	ИмяТаблицы = СтруктураПараметров.ИмяТаблицы;
	ПространствоБлокировки = ТипТаблицы  + "." + ИмяТаблицы;
	ЭлементБлокировки = Блокировка.Добавить(ПространствоБлокировки);

	РежимБлокировки = ?(СтруктураПараметров.Свойство("РежимБлокировки"), СтруктураПараметров.РежимБлокировки, РежимБлокировкиДанных.Исключительный);
	ЭлементБлокировки.Режим = РежимБлокировки;

	Если ИспользоватьЗначенияБлокировки Тогда

		Для каждого ЭлементКоллекции Из КоллекцияЗначенийБлокировки Цикл

			ЭлементБлокировки.УстановитьЗначение(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);

		КонецЦикла;

	КонецЕсли;

	Если ИспользоватьИсточникДанных Тогда

		ИсточникДанных = СтруктураПараметров.ИсточникДанных;

		Если ТипЗнч(ИсточникДанных) = Тип("МенеджерВременныхТаблиц") Тогда

			Запрос = Новый Запрос;
			Запрос.МенеджерВременныхТаблиц = ИсточникДанных;
			ТекстЗапроса = "";
			Для каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл
				ТекстЗапроса = ТекстЗапроса + ",
				|	Таб." + ЭлементКоллекции.Значение;
			КонецЦикла;
			ТекстЗапроса = Сред(ТекстЗапроса, 2);
			Запрос.Текст = 
			"ВЫБРАТЬ РАЗЛИЧНЫЕ
			|	&ТекстЗапроса
			|ИЗ
			|	&ИмяВременнойТаблицы КАК Таб";
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ТекстЗапроса", ТекстЗапроса);
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяВременнойТаблицы", СтруктураПараметров.ИмяВременнойТаблицы);
			
			Результат    = Запрос.Выполнить();

			ЭлементБлокировки.ИсточникДанных = Результат;

		Иначе

			ЭлементБлокировки.ИсточникДанных = ИсточникДанных;

		КонецЕсли;

		Для каждого ЭлементКоллекции Из КоллекцияОписанияИсточника Цикл

			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);

		КонецЦикла;

	КонецЕсли;
	
	Блокировка.Заблокировать(); //@skip-warning вызов этой процедуры обернут попыткой

КонецПроцедуры

// Сравнивает построчно указанные таблицы.
//
// Параметры:
//	Таблица1 			   - ТаблицаЗначений - таблица №1
//	Таблица2 			   - ТаблицаЗначений - таблица №2
//	КолонкиДолжныСовпадать - Булево - если Истина, то колонки должны быть идентичны.
//
// Возвращаемое значение:
//	Строка 			- если КолонкиДолжныСовпадать = Истина и колонки таблиц отличаются; возвращается описание отличий в колонках
//	ТаблицаЗначений - во всех остальных случаях; содержит только отличающиеся строки таблиц №1 и №2
//		состав колонок таблицы - общие колонки таблиц №1 и №2
//		служебная колонка "СчетчикСтрокСравниваемыхТаблиц" содержит число отличное от 0:
//			если счетчик > 0, то строка встречается в таблице №1 на указанное количество раз больше
//			если счетчик < 0, то строка встречается в таблице №2 на указанное количество раз больше.
//
Функция СравнитьТаблицыЗначений(Таблица1, Таблица2, КолонкиДолжныСовпадать = Истина) Экспорт
	
	ОписаниеОтличийВКолонках = Новый Массив;
	ОбщиеКолонки = Новый Массив;
	
	// Проверим колонки Таблица1 в Таблица2
	Для Каждого ТекущаяКолонка Из Таблица1.Колонки Цикл
		
		Если Таблица2.Колонки.Найти(ТекущаяКолонка.Имя) = Неопределено Тогда
			
			// Колонка только в Таблица1
			ОписаниеОтличийВКолонках.Добавить(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Колонка присутствует только в таблице №1: ""%1""'"),
					ТекущаяКолонка.Имя));
			
		Иначе
			
			// Общая колонка
			ОбщиеКолонки.Добавить(ТекущаяКолонка.Имя);
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Проверим колонки Таблица2 в Таблица1
	Для Каждого ТекущаяКолонка Из Таблица2.Колонки Цикл
		
		Если Таблица1.Колонки.Найти(ТекущаяКолонка.Имя) = Неопределено Тогда
			
			// Колонка только в Таблица2
			ОписаниеОтличийВКолонках.Добавить(
				СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Колонка присутствует только в таблице №2: ""%1""'"),
					ТекущаяКолонка.Имя));
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если КолонкиДолжныСовпадать И ОписаниеОтличийВКолонках.Количество() > 0 Тогда
		Возврат СтрСоединить(ОписаниеОтличийВКолонках, Символы.ПС);
	КонецЕсли;
	
	СтрокаОбщиеКолонки = СтрСоединить(ОбщиеКолонки, ", ");
	
	// Объединим таблицы 1 и 2.
	// При этом в служебную колонку "СчетчикСтрокСравниваемыхТаблиц" запишем число 1 для 1й и -1 для 2й таблицы.
	ТаблицаОтличий = Таблица1.Скопировать(, СтрокаОбщиеКолонки);
	
	ТаблицаОтличий.Колонки.Добавить("СчетчикСтрокСравниваемыхТаблиц", Новый ОписаниеТипов("Число"));
	ТаблицаОтличий.ЗаполнитьЗначения(1, "СчетчикСтрокСравниваемыхТаблиц");
	
	Для Каждого СтрокаТаблицы Из Таблица2 Цикл
		
		НоваяСтрока = ТаблицаОтличий.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
		
		НоваяСтрока.СчетчикСтрокСравниваемыхТаблиц = -1;
		
	КонецЦикла;
	
	// Свернем строки объединенной таблицы.
	// Строки, в которых СчетчикСтрокСравниваемыхТаблиц <> 0, являются различиями таблиц 1 и 2.
	// Вернем только отличающиеся строки.
	
	ТаблицаОтличий.Свернуть(СтрокаОбщиеКолонки, "СчетчикСтрокСравниваемыхТаблиц");
	
	НайтиИУдалитьСтрокиТаблицыЗначений(
		ТаблицаОтличий,
		Новый Структура("СчетчикСтрокСравниваемыхТаблиц", 0));
	
	Возврат ТаблицаОтличий;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПроцедурыИФункцииУстановкиСтатусовДляМассиваДокументов

// Возвращает соответствие массивов документов по типам
//
// Параметры:
// 		МассивСсылок - Массив из ДокументСсылка - Массив ссылок.
//
// Возвращаемое значение:
// 		Соответствие - Ключ - Тип документа, Значение - Массив ссылок на документы.
//
Функция РазложитьМассивСсылокПоТипам(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Счетчик = 0 По МассивСсылок.Количество() -1 Цикл
		
		ТипСсылки = ТипЗнч(МассивСсылок[Счетчик]);
		Массив = СоответствиеТипов[ТипСсылки];
		Если Массив = Неопределено Тогда
			Массив = Новый Массив;
			СоответствиеТипов.Вставить(ТипСсылки, Массив);
		КонецЕсли;
		Массив.Добавить(МассивСсылок[Счетчик]);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции // РазложитьМассивСсылокПоТипам

#КонецОбласти

#Область МетодыРаботыСРеквизитамиОбъектов

// Позволяет определить есть ли среди реквизитов табличной части объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - Строковое имя искомого реквизита.
//  МетаданныеОбъекта - ОбъектМетаданных - описание метаданных объекта, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - Строка - Строковое имя табличной части объекта, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево - Истина, нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиОбъекта(ИмяРеквизита, МетаданныеОбъекта, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // нет такой таб. части
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
КонецФункции

#КонецОбласти

#Область ЗаменаСсылокПоИнформационнойБазе

// Заменяет ссылки по информационной базе.
//
// Параметры:
//	ПарыЗамен - Соответствие - ключи содержат замещаемых, значения содержат заменители
//	Исключения - Массив - необязателен, значения типа ОбъектМетаданных, в экземплярах которых замены проводить нельзя.
//
Процедура ЗаменитьСсылки(ПарыЗамен, Исключения = Неопределено) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	Английский = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский;
	ДвиженияССубконтоИмя = ?(Метаданные.ВариантВстроенногоЯзыка = Английский, ".RecordsWithExtDimensions", ".ДвиженияССубконто");
	
	Если Исключения = Неопределено Тогда
		Исключения = Новый Массив;
	КонецЕсли;
	
	// [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[]).
	ИндексЗамены = ИндексЗамены(ПарыЗамен);
	КешПолей = Новый Соответствие;
	// Обходим индекс и в каждом ключе-объекта полностью замещаем все ссылки, подлежащие замене.
	Для Каждого УзелЗамены Из ИндексЗамены Цикл
		Ссылка = УзелЗамены.Ключ;
		МетаданныеУзла = УзелЗамены.Значение.Метаданные; // ОбъектМетаданных - 
		Замены = УзелЗамены.Значение.Замены;
		ТипыЗамещаемых = УзелЗамены.Значение.ТипыЗамещаемых;
		
		Если Исключения.Найти(МетаданныеУзла) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ЭтоСсылочныйОбъектМетаданных(МетаданныеУзла) Тогда
			// любой ссылочный объект
			ОбъектДанных = Ссылка.ПолучитьОбъект();
			Если ОбъектДанных <> Неопределено Тогда
				ПолноеИмя = МетаданныеУзла.ПолноеИмя();
				ИменаПолей = ИменаПолейСТипами(КешПолей, ПолноеИмя, ТипыЗамещаемых, "Ссылка, Ref");
				ЗаменитьЗначения(ОбъектДанных, ИменаПолей, Замены);
				// табчасти объекта
				ЗаменитьВТабчастях(
					КешПолей, МетаданныеУзла.ТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
				// стандартные табчасти планов
				Если Метаданные.ПланыСчетов.Содержит(МетаданныеУзла) Или Метаданные.ПланыВидовРасчета.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВТабчастях(
						КешПолей, МетаданныеУзла.СтандартныеТабличныеЧасти, ОбъектДанных, ПолноеИмя, Замены, ТипыЗамещаемых, Исключения);
				КонецЕсли;
				// пишем сам объект
				ЗаписатьДанные(ОбъектДанных);
				ОбъектДанных = Неопределено;
			КонецЕсли;
		ИначеЕсли Метаданные.Константы.Содержит(МетаданныеУзла) Тогда
			// значения в константах
			Константа = Константы[МетаданныеУзла.Имя];
			Константа.Установить(НовоеЗначение(Константа.Получить(), Замены));
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(МетаданныеУзла) Тогда
			// необъектные таблицы
			ИменаПолей = ИменаПолейСТипами(КешПолей, МетаданныеУзла.ПолноеИмя(), ТипыЗамещаемых);
			Отборы = ОтборыРегистраСведений(МетаданныеУзла, Ссылка);
			Набор = НаборЗаписей(РегистрыСведений[МетаданныеУзла.Имя], Отборы);
			
			Таблица = Набор.Выгрузить();
			Набор.Очистить();
			ЗаписатьДанные(Набор);

			ЗаменитьЗначения(Таблица[0], ИменаПолей, Замены);
			Для Каждого ИмяПоля Из ИменаПолей Цикл
				Если Не Отборы.Свойство(ИмяПоля) Тогда
					Продолжить;
				КонецЕсли;
				ЭлементОтбора = Набор.Отбор[ИмяПоля]; // ЭлементОтбора - 
				ЭлементОтбора.Установить(НовоеЗначение(Отборы[ИмяПоля], Замены));
			КонецЦикла;
			Набор.Загрузить(Таблица);
			ЗаписатьДанные(Набор);
		КонецЕсли;
		// обработка движений документа
		Если Метаданные.Документы.Содержит(МетаданныеУзла) Тогда
			Для Каждого Движение Из МетаданныеУзла.Движения Цикл
				ДопТаблица = "";
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
					Регистр = РегистрыНакопления[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
					Регистр = РегистрыСведений[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
					ДопТаблица = ДвиженияССубконтоИмя;
					Регистр = РегистрыБухгалтерии[Движение.Имя];
				ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
					Регистр = РегистрыРасчета[Движение.Имя];
				КонецЕсли;
				ЗаменитьВПодчиненномРегистре(КешПолей, Регистр, Ссылка, Движение.ПолноеИмя() + ДопТаблица, Замены, ТипыЗамещаемых);
			КонецЦикла;
			// обработка последовательностей, включающих документ
			Для Каждого Движение Из Метаданные.Последовательности Цикл
				Если Исключения.Найти(Движение) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				Если Движение.Документы.Содержит(МетаданныеУзла) Тогда
					ЗаменитьВПодчиненномРегистре(
						КешПолей, Последовательности[Движение.Имя], Ссылка, Движение.ПолноеИмя(), Замены, ТипыЗамещаемых);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Строим соответствие вида [ссылающийся объект](.Метаданные, .Замены[(.Замещаемое, .Заменитель)], .ТипыЗамещаемых[])
// в итоге представляем результаты поиска по ссылкам в индексе с ключом-объектом, содержащим замещаемые ссылки.
//
Функция ИндексЗамены(ПарыЗамен)
	
	СписокСсылок = Новый Массив;
	Для Каждого Пара Из ПарыЗамен Цикл
		СписокСсылок.Добавить(Пара.Ключ);
	КонецЦикла;
	РезультатыПоиска = НайтиПоСсылкам(СписокСсылок);
	// (.Ссылка: исходная ссылка; .Данные: ссылающийся объект; .Метаданные: метаданные ссылающегося объекта).
	
	ИндексЗамены = Новый Соответствие;
	Для Каждого Результат Из РезультатыПоиска Цикл
		УзелЗамены = ИндексЗамены[Результат.Данные];
		Если Неопределено = УзелЗамены Тогда
			УзелЗамены =
				Новый Структура("Метаданные, Замены, ТипыЗамещаемых", Результат.Метаданные, Новый Массив, Новый Массив);
			ИндексЗамены.Вставить(Результат.Данные, УзелЗамены);
		КонецЕсли;

		УзелЗамены.Замены.Добавить(
			Новый Структура("Замещаемое, Заменитель", Результат.Ссылка, ПарыЗамен[Результат.Ссылка]));

		ТипЗамещаемого = ТипЗнч(Результат.Ссылка);
		Если Неопределено = УзелЗамены.ТипыЗамещаемых.Найти(ТипЗамещаемого) Тогда
			УзелЗамены.ТипыЗамещаемых.Добавить(ТипЗамещаемого);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИндексЗамены;
КонецФункции

// Параметры:
// 	КешПолей - Соответствие -
// 	ОписанияТабчастей - Массив Из ОбъектМетаданныхТабличнаяЧасть - 
// 	Объект - ДокументОбъект, СправочникОбъект - 
// 	ИмяОсновнойТаблицы - Строка - Описание
// 	Замены - Соответствие -
// 	ТипыЗамещаемых - Массив из Тип -
// 	Исключения - Массив, Неопределено -
Процедура ЗаменитьВТабчастях(КешПолей, ОписанияТабчастей, Объект, ИмяОсновнойТаблицы, Замены, ТипыЗамещаемых, Исключения)
	Для Каждого Описание Из ОписанияТабчастей Цикл
		Если Исключения.Найти(Описание) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяОсновнойТаблицы + "." + Описание.Имя, ТипыЗамещаемых, "Ссылка, Ref");
		Для Каждого Табстрока Из Объект[Описание.Имя] Цикл
			ЗаменитьЗначения(Табстрока, ИменаПолей, Замены);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаменитьВПодчиненномРегистре(КешПолей, МенеджерРегистра, Ссылка, ИмяТаблицыРегистра, Замены, ТипыЗамещаемых)
	ИменаПолей = ИменаПолейСТипами(КешПолей, ИмяТаблицыРегистра, ТипыЗамещаемых, "Регистратор, Recorder");
	Набор = НаборЗаписей(МенеджерРегистра, Новый Структура("Регистратор", Ссылка));
	ЗначениеЗаменено = Ложь;
	Для Каждого Запись Из Набор Цикл
		ЗаменитьЗначения(Запись, ИменаПолей, Замены, ЗначениеЗаменено);
	КонецЦикла;
	ЗаписатьДанные(Набор, ЗначениеЗаменено);
КонецПроцедуры

Функция ИменаПолейСТипами(КешПолейТаблиц, ИмяТаблицы, ТипыДанных, ИменаИсключений = "")
	
	ИменаПолей  = Новый Массив;
	Исключения  = Новый Структура(ИменаИсключений);
	ПоляТаблицы = КешПолейТаблиц.Получить(ИмяТаблицы);
	
	Если ПоляТаблицы = Неопределено Тогда
		
	    ПоляТаблицы = Новый Массив;
		
	    СхемаЗапроса = Новый СхемаЗапроса;
	    СхемаЗапроса.УстановитьТекстЗапроса(
			СтрЗаменить("ВЫБРАТЬ * ИЗ ТаблицаВыборки КАК Т ГДЕ ЛОЖЬ", "ТаблицаВыборки", ИмяТаблицы));
		
		Для Каждого КолонкаЗапроса Из СхемаЗапроса.ПакетЗапросов[0].Колонки Цикл
	        Если ТипЗнч(КолонкаЗапроса) = Тип("КолонкаСхемыЗапроса") Тогда
	            ПоляТаблицы.Добавить(
					Новый Структура("Имя,ТипЗначения", КолонкаЗапроса.Псевдоним, КолонкаЗапроса.ТипЗначения));
	        КонецЕсли; 
	    КонецЦикла;
		
	    КешПолейТаблиц.Вставить(ИмяТаблицы, ПоляТаблицы);
		
	КонецЕсли;
	
	Для Каждого Поле Из ПоляТаблицы Цикл
		
		Если Исключения.Свойство(Поле.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого ТипДанных Из ТипыДанных Цикл
			Если Поле.ТипЗначения.СодержитТип(ТипДанных) И ИменаПолей.Найти(Поле.Имя) = Неопределено Тогда
				ИменаПолей.Добавить(Поле.Имя);
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
    Возврат ИменаПолей;
	
КонецФункции

Процедура ЗаменитьЗначения(Данные, ИменаПолей, Замены, Заменено = Ложь)
	Для Каждого ИмяПоля Из ИменаПолей Цикл
		НовоеЗначение = НовоеЗначение(Данные[ИмяПоля], Замены);
		Если НовоеЗначение <> Данные[ИмяПоля] Тогда;
			Заменено = Истина;
			Данные[ИмяПоля] = НовоеЗначение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Функция НовоеЗначение(СтароеЗначение, Замены)
	Для Каждого Замена Из Замены Цикл
		Если СтароеЗначение = Замена.Замещаемое Тогда
			Возврат Замена.Заменитель;
		КонецЕсли;
	КонецЦикла;
	Возврат СтароеЗначение;
КонецФункции

Процедура ЗаписатьДанные(Данные, Принудительно = Ложь)
	Если Данные.Модифицированность() Или Принудительно Тогда
		Данные.ОбменДанными.Загрузка = Истина;
		Данные.Записать();
	КонецЕсли;
КонецПроцедуры

// Параметры:
// 	МетаданныеРегистра - ОбъектМетаданныхРегистрСведений -
// 	Запись - РегистрСведенийЗаписьИмяРегистраСведений -
// Возвращаемое значение:
// 	Структура - 
//  
Функция ОтборыРегистраСведений(МетаданныеРегистра, Запись)
	Отборы = Новый Структура;
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Отборы.Вставить("Период", Запись.Период);
	КонецЕсли;
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Отборы.Вставить(Измерение.Имя, Запись[Измерение.Имя]);
	КонецЦикла;
	Возврат Отборы;
КонецФункции

// Параметры:
// 	МенеджерРегистра - РегистрСведенийМенеджер - 
// 	                 - РегистрыНакопленияМенеджер - 
// 	Отборы - Структура - Описание:
// 					* Период - Дата -
// Возвращаемое значение:
// 	РегистрСведенийНаборЗаписей, РегистрНакопленияНаборЗаписей -
//
Функция НаборЗаписей(МенеджерРегистра, Отборы)
	
	Набор = МенеджерРегистра.СоздатьНаборЗаписей();
	Для Каждого Отбор Из Отборы Цикл
		ЭлементОтбора = Набор.Отбор[Отбор.Ключ]; // ЭлементОтбора - 
		ЭлементОтбора.Установить(Отбор.Значение);
	КонецЦикла;
	Набор.Прочитать();
	Возврат Набор;
КонецФункции

Функция ЭтоСсылочныйОбъектМетаданных(ОбъектМетаданных)
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Документы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Перечисления.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Задачи.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
КонецФункции

#КонецОбласти

#Область МетодыДляОтладкиИТестирования

// Показать произвольную выборку данных в отладчике
// Пример:
//	ОбщегоНазначенияУТ.ЗапросВыполнитьВыгрузить("выбрать * из Справочник.Валюты где Валюты.Код = &Код", Новый Структура("Код", "810"))
//
// Параметры:
// 	ТекстЗапроса - Строка - 
// 	ПараметрыЗапроса - Структура -
// 	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц -
//
// Возвращаемое значение:
// 	ТаблицаЗначений - 
Функция ЗапросВыполнитьВыгрузить(ТекстЗапроса, ПараметрыЗапроса = Неопределено, МенеджерВременныхТаблиц = Неопределено) Экспорт
	
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для Каждого Параметр Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(Параметр.Ключ, Параметр.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции

// Показать временную таблицу из менеджера временных таблиц.
// Используется для просмотра временных таблиц в отладчике.
// Пример вызова функции:
//	ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(Запрос, "ТаблицаТоваров")
//
// Параметры:
// 	МенеджерВременныхТаблицИлиЗапрос - МенеджерВременныхТаблиц - 
//	                                 - Запрос -
//  ИмяВременнойТаблицы - Строка - 
//
// Возвращаемое значение:
// 	ТаблицаЗначений - Данные временной таблицы
//
Функция ПоказатьВременнуюТаблицу(МенеджерВременныхТаблицИлиЗапрос, ИмяВременнойТаблицы) Экспорт
	
	ЗакрытьМенеджерВременныхТаблиц = Ложь;
	
	Если ТипЗнч(МенеджерВременныхТаблицИлиЗапрос) = Тип("Запрос") Тогда
		Если МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено Тогда
			МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
			ЗакрытьМенеджерВременныхТаблиц = Истина;
			МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц; 
		Иначе
			МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц;
		КонецЕсли;
		МенеджерВременныхТаблицИлиЗапрос.Выполнить();
	Иначе
		МенеджерВременныхТаблиц = МенеджерВременныхТаблицИлиЗапрос;
	КонецЕсли; 
	
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	*
	|ИЗ
	|	&ВременнаяТаблица";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВременнаяТаблица", ИмяВременнойТаблицы);
	
	ДанныеТаблицы = ЗапросВыполнитьВыгрузить(ТекстЗапроса,, МенеджерВременныхТаблиц);
	
	Если ЗакрытьМенеджерВременныхТаблиц Тогда
		МенеджерВременныхТаблиц.Закрыть();
		МенеджерВременныхТаблицИлиЗапрос.МенеджерВременныхТаблиц = Неопределено;
	КонецЕсли; 
	
	Возврат ДанныеТаблицы;
	
КонецФункции


// Описание
// 
// Параметры:
// 	ПолноеИмяФайла	- Строка	- полный путь к файлу
// Возвращаемое значение:
// 	ТипФайлаТабличногоДокумента - тип файла табличного документа, соответствующий переданному значению
Функция ПолучитьТипФайлаТабличногоДокументаПоПолномуИмени(ПолноеИмяФайла) Экспорт
	
	СоответствияРасширенияТипуФайла = Новый Соответствие();
	СоответствияРасширенияТипуФайла.Вставить(".DOCX",	ТипФайлаТабличногоДокумента.DOCX);
	СоответствияРасширенияТипуФайла.Вставить(".HTML",	ТипФайлаТабличногоДокумента.HTML);
	СоответствияРасширенияТипуФайла.Вставить(".ODS",		ТипФайлаТабличногоДокумента.ODS);
	СоответствияРасширенияТипуФайла.Вставить(".PDF",		ТипФайлаТабличногоДокумента.PDF);
	СоответствияРасширенияТипуФайла.Вставить(".TXT",		ТипФайлаТабличногоДокумента.TXT);
	СоответствияРасширенияТипуФайла.Вставить(".XLS",		ТипФайлаТабличногоДокумента.XLS);
	СоответствияРасширенияТипуФайла.Вставить(".XLSX",	ТипФайлаТабличногоДокумента.XLSX);
	
	Файл = Новый Файл(ПолноеИмяФайла);
	ТипФайла = СоответствияРасширенияТипуФайла.Получить(ВРег(Файл.Расширение));
	
	Возврат ?(ТипФайла = Неопределено, ТипФайлаТабличногоДокумента.MXL, ТипФайла);

КонецФункции

// Преобразует таблицу значений в табличный документ и сохраняет его в файл.
//
// Параметры:
//  Таблица									 - ТаблицаЗначений	 - произвольная таблица значений
//  ПолноеИмяФайла							 - Строка			 - полное имя сохраняемого файла, с расширением.
//  Оформить								 - Булево			 - см. описание параметра в функции ОбщегоНазначенияУТ.ТабличныйДокументИзТаблицыЗначений
//  МетаданныеТабличнойЧастиДляЗаголовков	 - ОбъектМетаданныхТабличнаяЧасть, Неопределено - см. описание
//																		параметра в функции ОбщегоНазначенияУТ.ТабличныйДокументИзТаблицыЗначений
// 
// Возвращаемое значение:
//  Строка - текст сообщения об ошибке или пустая строка, если запись выполнена успешно.
//
// Примеры:
// 	ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(Таблица, "c:\temp\таблица.mxl")
//  ОбщегоНазначенияУТ.СохранитьТаблицуЗначенийВФайл(ОбщегоНазначенияУТ.ПоказатьВременнуюТаблицу(МВТ, "Таблица"), "c:\temp\таблица.mxl")
//
Функция СохранитьТаблицуЗначенийВФайл(Таблица, ПолноеИмяФайла, Оформить = Ложь, МетаданныеТабличнойЧастиДляЗаголовков = Неопределено) Экспорт
	
	ВыгрузкаТаблицы = ТабличныйДокументИзТаблицыЗначений(Таблица, Оформить, МетаданныеТабличнойЧастиДляЗаголовков);
	
	// Сохраним табличный документ в файл
	ТекстОшибки = "";
	Попытка
		ВыгрузкаТаблицы.Записать(ПолноеИмяФайла, ПолучитьТипФайлаТабличногоДокументаПоПолномуИмени(ПолноеИмяФайла));
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	
	Возврат ТекстОшибки;
	
КонецФункции

// Возвращает представление таблицы значений в виде табличного документа
//
// Параметры:
//  Таблица	- ТаблицаЗначений -
//  Оформить - Булево - если передано ИСТИНА, то
//							добавляется пустая строка перед шапкой,
//							шапка выделяется цветом фона, иначе - жирным шрифтом,
//							ширина колонки устанавливается по ширине заголовка, иначе ширина по умолчанию,
//							устанавливаются свойства табличного документа ТолькоПросмотр = Истина,ОтображатьСетку = Ложь, ОтображатьЗаголовки = Ложь.
//  МетаданныеТабличнойЧастиДляЗаголовков - ОбъектМетаданныхТабличнаяЧасть -
//	                                      - Неопределено -
//  											если переданы метаданные, то в шапке таблицы выводятся синонимы полей из метаданных
//                                              если колонка таблицы значений не найдена - она не выводится в табличный документ
//                                              если метаданные не переданы, то в шапке показываются заголовки колонок из таблицы значений,
//                                              	если заголовков нет - показываются имена колонок.
// 
// Возвращаемое значение:
//   ТабличныйДокумент -
//
Функция ТабличныйДокументИзТаблицыЗначений(Таблица, Оформить = Ложь, МетаданныеТабличнойЧастиДляЗаголовков = Неопределено) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	Если Оформить Тогда
		НомерСтроки  = 2;
	Иначе
		НомерСтроки  = 1;
	КонецЕсли;	
		
	НомерКолонки = 0;
	
	// Сформируем шапку табличного документа - выведем имена колонок таблицы значений
	Для Каждого ТекКолонка Из Таблица.Колонки Цикл
		
		НомерКолонки = НомерКолонки + 1;
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		Если МетаданныеТабличнойЧастиДляЗаголовков = Неопределено Тогда 
			Область.Текст = ?(ЗначениеЗаполнено(ТекКолонка.Заголовок), ТекКолонка.Заголовок, ТекКолонка.Имя);
		Иначе
			Реквизит = МетаданныеТабличнойЧастиДляЗаголовков.Реквизиты.Найти(ТекКолонка.Имя);
			Если Реквизит = Неопределено Тогда
				Область.ШиринаКолонки = 1;
				Продолжить;
			Иначе
				Область.Текст = Реквизит.Синоним;
			КонецЕсли;
		КонецЕсли;
		Область.ГраницаСнизу  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСверху = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСлева  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		Область.ГраницаСправа = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
		
		Если Оформить Тогда
			Область.ЦветФона = ЦветаСтиля.ИтогиФонГруппы;	
			Область.ШиринаКолонки = СтрДлина(Область.Текст);
		Иначе
			Область.Шрифт    = Новый Шрифт(Область.Шрифт,,, Истина); 
		КонецЕсли;
		
	КонецЦикла;
	
	// Выведем строки таблицы значений
	Для Каждого ТекСтр Из Таблица Цикл
		
		НомерСтроки = НомерСтроки + 1;
		НомерКолонки = 0;
		
		Для Каждого ТекКолонка Из Таблица.Колонки Цикл
			НомерКолонки = НомерКолонки + 1;
			
			Если МетаданныеТабличнойЧастиДляЗаголовков <> Неопределено Тогда 
				Реквизит = МетаданныеТабличнойЧастиДляЗаголовков.Реквизиты.Найти(ТекКолонка.Имя);
				Если Реквизит = Неопределено Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;	
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			Область.Текст         = Строка(ТекСтр[ТекКолонка.Имя]);
			Область.ГраницаСнизу  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСверху = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСлева  = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			Область.ГраницаСправа = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная, 1);
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВыгрузкаТаблицы.ФиксацияСверху = 1;
	ВыгрузкаТаблицы.ФиксацияСлева  = 1;
	
	Если Оформить Тогда
		
		ВыгрузкаТаблицы.ТолькоПросмотр      = Истина;
		ВыгрузкаТаблицы.ОтображатьСетку     = Ложь;
		ВыгрузкаТаблицы.ОтображатьЗаголовки = Ложь;
		
	КонецЕсли;
	
	Возврат ВыгрузкаТаблицы;
	
КонецФункции

// Считывает таблицу значений из табличного документа.
// Помещение таблицы значений в текстовый документ можно выполнить функцией СохранитьТаблицуЗначенийВФайл().
// В первой строке таблицы должны быть указаны имена колонок таблицы значений,
// в остальных строках - значения в соответствующих ячейках таблицы значений.
// Пример вызова функции:
// 	ОбщегоНазначенияУТ.ПолучитьТаблицуЗначенийИзФайла("c:\temp\таблица.mxl").
//
// Параметры:
//	ПолноеИмяФайла - Строка - полное имя считываемого файла, с расширением.
//
// Возвращаемое значение:
//	Строка 			- если при чтении файла произошла ошибка, то возвращается текст сообщения об ошибке;
//	ТаблицаЗначений - если ошибок не было, то возвращается считанная таблица значений.
//
Функция ПолучитьТаблицуЗначенийИзФайла(ПолноеИмяФайла) Экспорт
	
	ВыгрузкаТаблицы = Новый ТабличныйДокумент; // преобразованная в mxl таблица значений
	
	// Прочитаем файл.
	Попытка
		ВыгрузкаТаблицы.Прочитать(ПолноеИмяФайла);
	Исключение
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Невозможно прочитать таблицу значений из файла ""%1"":
				|%2'"),
			ПолноеИмяФайла,
			ИнформацияОбОшибке());
		
		Возврат ТекстОшибки;
		
	КонецПопытки;
	
	Таблица = Новый ТаблицаЗначений;
	
	Если ВыгрузкаТаблицы.ВысотаТаблицы = 0 ИЛИ ВыгрузкаТаблицы.ШиринаТаблицы = 0 Тогда
		Возврат Таблица;
	КонецЕсли;
	
	// Создадим колонки таблицы значений.
	НомерСтроки = 1;
	
	// В первой строке таблицы должны быть перечислены имена колонок.
	// Если в ячейке первой строки указан текст, не подходящий для имени колонки таблицы значений, то вернем сообщение об ошибке.
	Для НомерКолонки = 1 По ВыгрузкаТаблицы.ШиринаТаблицы Цикл
		
		Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
		ТекстЯчейки = СокрЛП(Область.Текст);
		
		Попытка
			Таблица.Колонки.Добавить(ТекстЯчейки, Новый ОписаниеТипов("Строка"));
		Исключение
			
			ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Невозможно прочитать таблицу значений из файла ""%1"":
					|недопустимое имя колонки таблицы значений: ""%2""'"),
				ПолноеИмяФайла,
				ТекстЯчейки);
			
			Возврат ТекстОшибки;
			
		КонецПопытки;
		
	КонецЦикла;
	
	Для НомерСтроки = 2 По ВыгрузкаТаблицы.ВысотаТаблицы Цикл
		
		НоваяСтрока = Таблица.Добавить();
		
		Для НомерКолонки = 1 По ВыгрузкаТаблицы.ШиринаТаблицы Цикл
			
			Область = ВыгрузкаТаблицы.Область(НомерСтроки, НомерКолонки, НомерСтроки, НомерКолонки);
			ТекстЯчейки = СокрЛП(Область.Текст);
			
			НоваяСтрока[Таблица.Колонки[НомерКолонки - 1].Имя] = ТекстЯчейки;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Таблица;
	
КонецФункции

#КонецОбласти

#Область СистемныеОпределяютПоведениеКонфигурации

// Проверяет соблюдение условий открытия базовой версии конфигурации в режиме Предприятие.
//
// Возвращаемое значение:
// 	Булево - Если текущая версия конфигурации не является базовой, то возвращается значение Истина.
//           Если текущая версия конфигурации является базовой, то возвращается значение Истина.
//	         В случае, если ИБ развернута в файловом варианте и запускается в однопользовательском режиме.
//
Функция ВозможенЗапускБазовойВерсии() Экспорт
	
	Если НЕ СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации() Тогда
		Возврат Истина; // ОК: это не базовая версия
	КонецЕсли;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая(СтрокаСоединенияИнформационнойБазы()) Тогда
		Возврат Ложь; // не файловая ИБ
	КонецЕсли;
	
	СеансыИнформационнойБазы = ПолучитьСеансыИнформационнойБазы();
	НомерТекущегоСеанса		 = НомерСеансаИнформационнойБазы();
	ЗапрещенныеПриложения	 = ",1CV8,1CV8C,WebClient,WSConnection,COMConnection,";
	
	Для Каждого СеансИБ Из СеансыИнформационнойБазы Цикл
		
		Если СеансИБ.НомерСеанса = НомерТекущегоСеанса Тогда
			Продолжить;
		ИначеЕсли СтрНайти(ЗапрещенныеПриложения, "," + СеансИБ.ИмяПриложения + ",") > 0 Тогда
			Возврат Ложь; // открыты другие сеансы 1С:Предприятия
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина; // ОК: это файловая ИБ в однопользовательском режиме
	
КонецФункции

#КонецОбласти

#Область Версионирование

// Возвращает признак использования версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//
// Возвращаемое значение:
//  Булево -
//
Функция ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Экспорт
	
 	Идентификатор = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ПолноеИмяОбъекта);	
	Возврат ПолучитьФункциональнуюОпцию("ИспользоватьВерсионированиеОбъекта",
		Новый Структура("ТипВерсионируемогоОбъекта", Идентификатор));
		
КонецФункции	

// Включает версионирования для указанного объекта метаданных.
//
// Параметры:
//  ПолноеИмяОбъекта - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//	ВариантВерсионирования - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если для указанного объекта было включено версионирование.
//
Функция ВключитьВерсионированиеОбъекта(ПолноеИмяОбъекта, ВариантВерсионирования = "ВерсионироватьПриЗаписи")
	
	ВерсионированиеВключено = Ложь;
	
	ПеречислениеВариантВерсионирования = Перечисления.ВариантыВерсионированияОбъектов[ВариантВерсионирования];
	
	Если НЕ ИспользоватьВерсионированиеОбъекта(ПолноеИмяОбъекта) Тогда
		
		ВерсионированиеОбъектов.ЗаписатьНастройкуВерсионированияПоОбъекту(ПолноеИмяОбъекта, ПеречислениеВариантВерсионирования);
		ВерсионированиеВключено = Истина;
		
	КонецЕсли;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

// Включает версионирования для указанных объектов метаданных.
//
// Параметры:
//	Объекты - Соответствие
//  	Ключ 	 - Строка - полный путь к объекту метаданных. Например, "Справочник.Номенклатура".
//		Значение - Строка - имя значения перечисления ВариантыВерсионированияОбъектов.
//
// Возвращаемое значение:
//  Булево - Истина, если хотя бы для одного из указанных объектов было включено версионирование.
//
Функция ВключитьВерсионированиеОбъектов(Объекты) Экспорт
	
	ВерсионированиеВключено = Ложь;
	
	Для Каждого КлючИЗначение Из Объекты Цикл
		ВерсионированиеВключено =
			ВключитьВерсионированиеОбъекта(КлючИЗначение.Ключ, КлючИЗначение.Значение)
			ИЛИ ВерсионированиеВключено;
	КонецЦикла;
	
	Возврат ВерсионированиеВключено;
	
КонецФункции

#КонецОбласти

#Область Константы

// Возвращает состав набор констант.
//
// Параметры:
//	Набор - КонстантыНабор -
//
// Возвращаемое значение:
//  Структура -
//		Ключ - имя константы из набора.
//
Функция ПолучитьСтруктуруНабораКонстант(Набор) Экспорт
	
	Результат = Новый Структура;
	
	Для Каждого МетаКонстанта Из Метаданные.Константы Цикл
		Если ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(Набор, МетаКонстанта.Имя) Тогда
			Результат.Вставить(МетаКонстанта.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Перечисления

// Получает список выбора для указанного перечисления.
//
// Параметры:
//	ИмяПеречисления 	- Строка - имя перечисления как оно задано в конфигураторе.
//	ДанныеВыбора 		- СписокЗначений - сформированный список выбора перечисления.
//	Параметры 			- Структура - подробнее см. ОбработкаПолученияДанныхВыбора
//	ИсключаемыеЗначения - Массив - значения перечисления, не включаемые в список выбора.
//
Процедура ДоступныеДляВыбораЗначенияПеречисления(ИмяПеречисления, ДанныеВыбора, Параметры = Неопределено, ИсключаемыеЗначения = Неопределено) Экспорт
	
	Если Параметры = Неопределено Тогда
		Параметры = Новый Структура;
		Параметры.Вставить("Отбор", Новый Структура);
		Параметры.Вставить("СтрокаПоиска", "");
	КонецЕсли;
	
	ДанныеВыбора = Новый СписокЗначений; // результат
	
	Запрос = Новый Запрос;
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ЗначенияПеречисления.Ссылка КАК Ссылка,
	|	ПРЕДСТАВЛЕНИЕ(ЗначенияПеречисления.Ссылка) КАК Представление
	|ИЗ
	|	&Таблица КАК ЗначенияПеречисления
	|ГДЕ
	|	НЕ ЗначенияПеречисления.Ссылка В (&ИсключаемыеЗначения)
	|	И &ОтборПоСсылке
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗначенияПеречисления.Порядок";
	
	Если ИсключаемыеЗначения = Неопределено Тогда
		Запрос.УстановитьПараметр("ИсключаемыеЗначения", Новый Массив);
	Иначе
		Запрос.УстановитьПараметр("ИсключаемыеЗначения", ИсключаемыеЗначения);
	КонецЕсли;
	
	Если Параметры.Отбор.Свойство("Ссылка") Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборПоСсылке", "ЗначенияПеречисления.Ссылка В (&ОтборПоСсылке)");
		Запрос.УстановитьПараметр("ОтборПоСсылке", Параметры.Отбор.Ссылка);
	Иначе
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборПоСсылке", "ИСТИНА");
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(ТекстЗапроса, "&Таблица", "Перечисление." + ИмяПеречисления);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если НЕ ЗначениеЗаполнено(Параметры.СтрокаПоиска)
		 ИЛИ СтрНайти(НРег(Выборка.Представление), НРег(Параметры.СтрокаПоиска)) = 1 Тогда
			ДанныеВыбора.Добавить(Выборка.Ссылка);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область КонтактнаяИнформация

// Актуализирует значения полей КИ из ее представления.
//
//  Параметры:
//		Представление - Строка - представление КИ
//		ЗначенияПолей - Строка - служебная информация, значения полей КИ
//		ТипКИ - ПеречислениеСсылка.ТипыКонтактнойИнформации - тип контактной информации
//
Процедура ЗаполнитьЗначенияПолейКИПоПредставлению(Представление, ЗначенияПолей, ТипКИ = Неопределено) Экспорт
	
	Если ТипКИ = Неопределено Тогда
		ТипКИ = Перечисления.ТипыКонтактнойИнформации.Адрес;
	КонецЕсли;
	
	Если УправлениеКонтактнойИнформацией.ПредставлениеКонтактнойИнформации(ЗначенияПолей) = Представление Тогда
		Возврат;
	КонецЕсли;
	
	// Сохраним комментарий из старых значений полей.
	Комментарий = СокрЛП(УправлениеКонтактнойИнформацией.КомментарийКонтактнойИнформации(ЗначенияПолей));
	
	// Сформируем значения полей КИ по представлению.
	ЗначенияПолей = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияПоПредставлению(Представление,	ТипКИ);
	
	Если ЗначениеЗаполнено(Комментарий) Тогда
		// Вернем комментарий обратно.
		УправлениеКонтактнойИнформацией.УстановитьКомментарийКонтактнойИнформации(ЗначенияПолей, Комментарий);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ДополнительныеРеквизитыИСведения

// Служебная. Возвращает наборы доп. реквизитов и сведений, доступных при данных настройках конфигурации.
//
// Возвращаемое значение:
//	Массив Из СправочникСсылка.НаборыДополнительныхРеквизитовИСведений -
//
Функция ДоступныеДопРеквизитыИСведения() Экспорт
	
	ДоступныеСвойства = Новый Массив;
	
	СвязиСвойствИФО = ОбщегоНазначенияУТПовтИсп.СвязиДопРеквизитовИФункциональныхОпций();
	
	Для Каждого КлючИЗначение Из СвязиСвойствИФО Цикл
		
		Если НЕ ЗначениеЗаполнено(КлючИЗначение.Значение) Тогда
			
			// Этот набор доп. свойств не зависит от ФО
			ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
			
		Иначе
			
			РодительскиеФО = Новый Структура(КлючИЗначение.Значение);
			
			Для Каждого ТекущаяФО Из РодительскиеФО Цикл
				Если ПолучитьФункциональнуюОпцию(ТекущаяФО.Ключ) Тогда
					// Включена хотя бы одна ФО, от которой зависит этот набор доп. свойств
					ДоступныеСвойства.Добавить(КлючИЗначение.Ключ);
					Прервать;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДоступныеСвойства;
	
КонецФункции

#КонецОбласти

#Область Подсистемы

// Добавляет подсистему в коллекцию.
//
// Параметры:
//	Коллекция - Массив - 
//	          - СписокЗначений - коллекция, куда добавляется подсистема из метаданных
//	ИмяПодсистемы - Строка - имя подсистемы. Подчиненные подсистемы разделяются ".", служебные слова "Подсистема" или "Подсистемы" указывать не нужно.
//	Представление - Строка - представление подсистемы (для списка значений).
//
Процедура ДобавитьПодсистемуВКоллекцию(Коллекция, ИмяПодсистемы, Представление = "") Экспорт
	
	Подсистема = ПодсистемаПоИмени(ИмяПодсистемы);
	Если Подсистема = Неопределено Тогда
		Возврат; // нет такой подсистемы в метаданных
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Представление) Тогда
		Коллекция.Добавить(Подсистема, Представление);
	Иначе
		Коллекция.Добавить(Подсистема);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает метаданные подсистемы по ее имени.
//
// Параметры:
//	ИмяПодсистемы - Строка - имя подсистемы
//		подчиненные подсистемы разделяются ".",	служебные слова "Подсистема" или "Подсистемы" указывать не нужно.
//
// Возвращаемое значение:
//	ОбъектМетаданных - метаданные подсистемы или Неопределено, если подсистемы с таким именем не существует.
//
Функция ПодсистемаПоИмени(ИмяПодсистемы) Экспорт
	
	ПолноеИмяПодсистемы = Сред(СтрЗаменить("." + ИмяПодсистемы, ".", ".Подсистема."), 2);;
	
	Возврат Метаданные.НайтиПоПолномуИмени(ПолноеИмяПодсистемы);
	
КонецФункции

#КонецОбласти

#Область ГлобальныйПоиск

Процедура ОбъединитьДатуИВремя(Слова)
	
	ПоследнееСлово = Слова.Получить(Слова.ВГраница()); 
	Если СтрДлина(ПоследнееСлово) = 8 И Сред(ПоследнееСлово, 3, 1) = ":" И Сред(ПоследнееСлово, 6, 1) = ":" Тогда
		Слова[Слова.ВГраница() - 1] = Слова[Слова.ВГраница() - 1] + " " + Слова.Получить(Слова.ВГраница());
		Слова.Удалить(Слова.ВГраница());
	КонецЕсли;

КонецПроцедуры

Процедура НайтиДокументВРеестреПоНаименованиюИНомеру(Слова, РезультатПоиска)
	
	СловаНазвания = Новый Массив;
	Для Индекс = 0 По Слова.ВГраница() - 1 Цикл
		СловаНазвания.Добавить(Слова.Получить(Индекс));
	КонецЦикла;
	НомерДокумента = Слова.Получить(Слова.ВГраница());
	Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(СтрСоединить(СловаНазвания))
		Или Не СтрокаСодержитЦифру(НомерДокумента) Тогда
		Возврат;
	КонецЕсли;
	
	НаименованиеДокумента = СтрСоединить(СловаНазвания, " ");
	Для Каждого ОбъектМетаданных Из Метаданные.Документы Цикл
		Если ВРег(ОбъектМетаданных.Синоним) = ВРег(НаименованиеДокумента) Тогда
			ТипСсылки = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Документ." + ОбъектМетаданных.Имя);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	ВыбратьДокументыИзРеестра(РезультатПоиска, НомерДокумента, ТипСсылки, НаименованиеДокумента);
	
КонецПроцедуры

Функция СтрокаСодержитЦифру(Строка)
	
	Если СтрНайти(Строка, "0") > 0 Или СтрНайти(Строка, "1") > 0 Или СтрНайти(Строка, "2") > 0
		Или СтрНайти(Строка, "3") > 0 Или СтрНайти(Строка, "4") > 0 Или СтрНайти(Строка, "5") > 0
		Или СтрНайти(Строка, "6") > 0 Или СтрНайти(Строка, "7") > 0 Или СтрНайти(Строка, "8") > 0
		Или СтрНайти(Строка, "9") > 0 Тогда
			Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
	
КонецФункции

Процедура ВыбратьДокументыИзРеестра(РезультатПоиска, Номер, Тип=Неопределено, Наименование=Неопределено,
	Дата=Неопределено)

	Запрос = Новый Запрос;
	ТекстЗапросаВнутреннийДокумент = "ВЫБРАТЬ ПЕРВЫЕ 10 РАЗРЕШЕННЫЕ
	|	РеестрДокументов.Ссылка,
	|	РеестрДокументов.ДатаДокументаИБ
	|ИЗ
	|	РегистрСведений.РеестрДокументов КАК РеестрДокументов
	|ГДЕ
	|	&УсловиеТип
	|	И &УсловиеДатаДокумента
	|	И РеестрДокументов.НомерДокументаИБ = &НомерДокумента";

	ТекстЗапросаВнешнийДокумент = "ВЫБРАТЬ ПЕРВЫЕ 10
	|	РеестрДокументов.Ссылка,
	|	РеестрДокументов.ДатаДокументаИБ 
	|ИЗ
	|	РегистрСведений.РеестрДокументов КАК РеестрДокументов
	|ГДЕ
	|	&УсловиеНаименование
	|	И &УсловиеДатаВнешнегоДокумента
	|	И РеестрДокументов.НомерПервичногоДокумента = &НомерДокумента";
	
	Если ЗначениеЗаполнено(Тип) Тогда
		Запрос.Текст = ТекстЗапросаВнутреннийДокумент;
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеТип", "РеестрДокументов.ТипСсылки = &ТипСсылки");
		Запрос.УстановитьПараметр("ТипСсылки", Тип);
	Иначе
		Если ЗначениеЗаполнено(Наименование) Тогда
			Запрос.Текст = ТекстЗапросаВнешнийДокумент;
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "10" , "10 РАЗРЕШЕННЫЕ")
		Иначе
			Запрос.Текст = ТекстЗапросаВнутреннийДокумент + РазделительЗапросовВОбъединении()
							+ ТекстЗапросаВнешнийДокумент;
		КонецЕсли;
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеТип", "ИСТИНА");
	КонецЕсли;
	Запрос.Текст = Запрос.Текст + "
		|УПОРЯДОЧИТЬ ПО
		|	РеестрДокументов.ДатаДокументаИБ УБЫВ";
	Запрос.УстановитьПараметр("НомерДокумента", Номер);
	Если ЗначениеЗаполнено(Наименование) Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеНаименование",
			"РеестрДокументов.НаименованиеПервичногоДокумента ПОДОБНО &НаименованиеДокумента"); // @Query-part-1
		Запрос.УстановитьПараметр("НаименованиеДокумента", Наименование);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеНаименование", "ИСТИНА");
	КонецЕсли;
	Если ЗначениеЗаполнено(Дата) Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеДатаДокумента",
			"РеестрДокументов.ДатаДокументаИБ >= НАЧАЛОПЕРИОДА(&ДатаДокумента, ДЕНЬ)
		|	И РеестрДокументов.ДатаДокументаИБ <= КОНЕЦПЕРИОДА(&ДатаДокумента, ДЕНЬ)");
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеДатаВнешнегоДокумента",
			"РеестрДокументов.ДатаПервичногоДокумента >= НАЧАЛОПЕРИОДА(&ДатаДокумента, ДЕНЬ)
		|	И РеестрДокументов.ДатаПервичногоДокумента <= КОНЕЦПЕРИОДА(&ДатаДокумента, ДЕНЬ)");
		Запрос.УстановитьПараметр("ДатаДокумента", Дата);
	Иначе
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеДатаДокумента", "ИСТИНА");
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловиеДатаВнешнегоДокумента", "ИСТИНА");
	КонецЕсли;
	Если ЗначениеЗаполнено(Тип) И ЗначениеЗаполнено(Номер) И ЗначениеЗаполнено(Дата) Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "10", "1");
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.Следующий() Цикл
		НовыйЭлемент = Новый ЭлементРезультатаГлобальногоПоиска(
			Выборка.Ссылка, Строка(Выборка.Ссылка), БиблиотекаКартинок.ПоискДанных);
		РезультатПоиска.Добавить(НовыйЭлемент);
	КонецЦикла;
	
КонецПроцедуры

Функция ДатаИзСтроки(Строка)
	
	Если СтрДлина(Строка) <= 10 Тогда // нет времени
		Строка = Строка + " 00:00:00"
	КонецЕсли;
	
	Попытка
		Возврат Дата(Строка);
	Исключение
		Возврат Неопределено
	КонецПопытки;
	
КонецФункции

// Определяет является ли строка в виде строки Нстр
// 
// Параметры:
//  ПроверяемаяСтрока - Строка - Проверяемая строка
// 
// Возвращаемое значение:
//  Булево - Строка в виде н стр
//
Функция СтрокаВВидеНСтр(Знач ПроверяемаяСтрока) Экспорт
	
	ПроверяемаяСтрока = СтрЗаменить(ПроверяемаяСтрока, " ", "");
	
	ВариантыСовпадений = Новый Массив;
	Для каждого Язык Из Метаданные.Языки Цикл
		ВариантыСовпадений.Добавить(Язык.КодЯзыка + "=");
	КонецЦикла;
	
	Для каждого ВариантСовпадения Из ВариантыСовпадений Цикл
		Если СтрНайти(ПроверяемаяСтрока, ВариантСовпадения) > 0 Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#КонецОбласти

#Область Прочее

Процедура ОбработатьВложенныеПоля(ЭлементыФормы, ЭлементФормы, МассивЭлементов, Структура, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы") Тогда
			ИмяЭлемента = ЭлементФормы.Имя;
			Структура.Вставить(ИмяЭлемента, Новый Массив);
			ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, Структура[ИмяЭлемента], ПоляИсключения);
		КонецЕсли;
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			Имя = Элемент.Имя;
			ПодчиненныйЭлемент = ЭлементыФормы[Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Имя) <> Неопределено
					Или ПоляИсключения.Найти(Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьВложенныеПоля(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, Структура, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьПоляТаблицыФормы(ЭлементыФормы, ЭлементФормы, МассивЭлементов, ПоляИсключения)
	
	ТипЗнчЭлементФормы = ТипЗнч(ЭлементФормы);
	
	Если ТипЗнчЭлементФормы = Тип("ТаблицаФормы")
		ИЛИ ТипЗнчЭлементФормы = Тип("ГруппаФормы") Тогда
		Для Каждого Элемент Из ЭлементФормы.ПодчиненныеЭлементы Цикл
			ПодчиненныйЭлемент = ЭлементыФормы[Элемент.Имя];
			ТипЗнчПодчиненныйЭлемент = ТипЗнч(ПодчиненныйЭлемент);
			Если ТипЗнчПодчиненныйЭлемент = Тип("ПолеФормы") Тогда
				Если МассивЭлементов.Найти(Элемент.Имя) <> Неопределено
					Или ПоляИсключения.Найти(Элемент.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				МассивЭлементов.Добавить(Элемент.Имя);
			ИначеЕсли ТипЗнчПодчиненныйЭлемент = Тип("ГруппаФормы") Тогда
				ОбработатьПоляТаблицыФормы(ЭлементыФормы, ПодчиненныйЭлемент, МассивЭлементов, ПоляИсключения);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает идентификатор конфигурации.
// Длина идентификатора не должна превышать 8 символов.
//
// Возвращаемое значение:
// 	Строка -
Функция ИДКонфигурации() Экспорт
	

	Возврат "УТ11" + ?(СтандартныеПодсистемыСервер.ЭтоБазоваяВерсияКонфигурации(), "Базовая", ""); // в конфигурации УТ11
	
КонецФункции

Функция ПолучитьПрефиксДляУИП(Ссылка)

	Соответствие = Новый Соответствие();
	Соответствие.Вставить("ДоговорыКонтрагентов",				НСтр("ru = 'ДОГ'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("АктВыполненныхРабот",				НСтр("ru = 'АКТ'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ВозвратТоваровПоставщику",			НСтр("ru = 'НКВ'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ВыкупВозвратнойТарыКлиентом",		НСтр("ru = 'НК'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ЗаказКлиента",						НСтр("ru = 'ЗК'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ЗаявкаНаВозвратТоваровОтКлиента",	НСтр("ru = 'ЗКВ'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ОтчетКомиссионера",					НСтр("ru = 'ОК'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ОтчетКомиссионераОСписании",			НСтр("ru = 'ОКС'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ОтчетКомитенту",						НСтр("ru = 'ОКТ'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ОтчетПоКомиссииМеждуОрганизациями",	НСтр("ru = 'ОКО'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("РеализацияТоваровУслуг",				НСтр("ru = 'НК'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("РеализацияУслугПрочихАктивов",		НСтр("ru = 'НК'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("ПередачаТоваровМеждуОрганизациями",	НСтр("ru = 'НК'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("СчетНаОплатуКлиенту",				НСтр("ru = 'СЧ'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("СчетФактураВыданный",				НСтр("ru = 'СФ'", ОбщегоНазначения.КодОсновногоЯзыка()));
	Соответствие.Вставить("СписаниеБезналичныхДенежныхСредств",	НСтр("ru = 'ПП'", ОбщегоНазначения.КодОсновногоЯзыка()));
	
	Возврат Соответствие[Ссылка.Метаданные().Имя];
	
КонецФункции

Функция ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код,Сдвиг = Неопределено)
	
	Если Сдвиг = Неопределено Тогда
		Сдвиг = 0;
	КонецЕсли;
	
	СтруктураСоответствий = СтруктураСоответствийБуквИЦифр();
	
	СтрокаЦифр = "0123456789";	
	ВесРазряда = 1+Сдвиг;
	Результат = 0;
	// Замена служебных символов в коде.
	СтрокаБукв = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЩЭЮЯЪЫЬABCDEFGHIJKLMNOPQRSTUVWXYZ";
	НовКод = "";
	Для Инд = 1 По СтрДлина(Код) Цикл
		Попытка
			СимволКода = ВРЕГ(Сред(Код,Инд,1));
		Исключение
			СимволКода = Сред(Код,Инд,1);
		КонецПопытки;
		Если СтрНайти(СтрокаЦифр,СимволКода)=0 И СтрНайти(СтрокаБукв,СимволКода)=0 Тогда
			НовКод = НовКод + "0";
		Иначе
			НовКод = НовКод + СимволКода;
		КонецЕсли;
	КонецЦикла;
	Код = НовКод;
	//Конец замены
	Если СтрДлина(Код)<19 Тогда
		СтрокаКода = СтроковыеФункцииКлиентСервер.ДополнитьСтроку(Код,19,"0","Справа");
	Иначе
		СтрокаКода = Лев(Код,19);
	КонецЕсли;
	
	Для Инд = 1 По 19 Цикл 
		СимволКода = Сред(СтрокаКода,Инд,1);
		Если СтрНайти(СтрокаЦифр,СимволКода)>0 Тогда
			Значение = Число(СимволКода);
		ИначеЕсли СтруктураСоответствий.Свойство(ВРег(СимволКода)) Тогда
			Значение = СтруктураСоответствий[СимволКода]%10;			
		КонецЕсли;		
		Результат = Результат + ВесРазряда*Значение;
		
		ВесРазряда = ВесРазряда + 1;
		Если ВесРазряда = 11 Тогда
			ВесРазряда = 1;
		КонецЕсли;
	КонецЦикла;
	
	КонтрольныйРазряд = Результат % 11;
	
	Если КонтрольныйРазряд = 10 Тогда
		Если Сдвиг = 0 Тогда
			Возврат ПолучитьУникальныйИдентификаторПлатежаСКонтрольнымРазрядом(Код,2);
		Иначе
			КонтрольныйРазряд = 0;
		КонецЕсли;
	КонецЕсли;
	
	ПолныйКод = СтрокаКода+Строка(КонтрольныйРазряд);
	
	Возврат ПолныйКод;
	
КонецФункции

Функция СтруктураСоответствийБуквИЦифр()
	
	СтруктураСоответствий = Новый Структура();
	
	СтруктураСоответствий.Вставить("А", 1);   //@NON-NLS
	СтруктураСоответствий.Вставить("Б", 2);   //@NON-NLS
	СтруктураСоответствий.Вставить("В", 3);   //@NON-NLS
	СтруктураСоответствий.Вставить("Г", 4);   //@NON-NLS
	СтруктураСоответствий.Вставить("Д", 5);   //@NON-NLS
	СтруктураСоответствий.Вставить("Е", 6);   //@NON-NLS
	СтруктураСоответствий.Вставить("Ж", 7);   //@NON-NLS
	СтруктураСоответствий.Вставить("З", 8);   //@NON-NLS
	СтруктураСоответствий.Вставить("И", 9);   //@NON-NLS
	СтруктураСоответствий.Вставить("К", 10);  //@NON-NLS
	СтруктураСоответствий.Вставить("Л", 11);  //@NON-NLS
	СтруктураСоответствий.Вставить("М", 12);  //@NON-NLS
	СтруктураСоответствий.Вставить("Н", 13);  //@NON-NLS
	СтруктураСоответствий.Вставить("О", 14);  //@NON-NLS
	СтруктураСоответствий.Вставить("П", 15);  //@NON-NLS
	СтруктураСоответствий.Вставить("Р", 16);  //@NON-NLS
	СтруктураСоответствий.Вставить("С", 17);  //@NON-NLS
	СтруктураСоответствий.Вставить("Т", 18);  //@NON-NLS
	СтруктураСоответствий.Вставить("У", 19);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ф", 20);  //@NON-NLS
	СтруктураСоответствий.Вставить("Х", 21);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ц", 22);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ч", 23);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ш", 24);  //@NON-NLS
	СтруктураСоответствий.Вставить("Щ", 25);  //@NON-NLS
	СтруктураСоответствий.Вставить("Э", 26);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ю", 27);  //@NON-NLS
	СтруктураСоответствий.Вставить("Я", 28);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ъ", 33);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ы", 36);  //@NON-NLS
	СтруктураСоответствий.Вставить("Ь", 46);  //@NON-NLS
	СтруктураСоответствий.Вставить("A", 1);   //@NON-NLS
	СтруктураСоответствий.Вставить("B", 3);   //@NON-NLS
	СтруктураСоответствий.Вставить("C", 17);  //@NON-NLS
	СтруктураСоответствий.Вставить("D", 29);  //@NON-NLS
	СтруктураСоответствий.Вставить("E", 6);   //@NON-NLS
	СтруктураСоответствий.Вставить("F", 30);  //@NON-NLS
	СтруктураСоответствий.Вставить("G", 31);  //@NON-NLS
	СтруктураСоответствий.Вставить("H", 13);  //@NON-NLS
	СтруктураСоответствий.Вставить("I", 32);  //@NON-NLS
	СтруктураСоответствий.Вставить("J", 33);  //@NON-NLS
	СтруктураСоответствий.Вставить("K", 10);  //@NON-NLS
	СтруктураСоответствий.Вставить("L", 34);  //@NON-NLS
	СтруктураСоответствий.Вставить("M", 12);  //@NON-NLS
	СтруктураСоответствий.Вставить("N", 35);  //@NON-NLS
	СтруктураСоответствий.Вставить("O", 14);  //@NON-NLS
	СтруктураСоответствий.Вставить("P", 16);  //@NON-NLS
	СтруктураСоответствий.Вставить("Q", 36);  //@NON-NLS
	СтруктураСоответствий.Вставить("R", 37);  //@NON-NLS
	СтруктураСоответствий.Вставить("S", 38);  //@NON-NLS
	СтруктураСоответствий.Вставить("T", 18);  //@NON-NLS
	СтруктураСоответствий.Вставить("U", 39);  //@NON-NLS
	СтруктураСоответствий.Вставить("V", 40);  //@NON-NLS
	СтруктураСоответствий.Вставить("W", 41);  //@NON-NLS
	СтруктураСоответствий.Вставить("X", 21);  //@NON-NLS
	СтруктураСоответствий.Вставить("Y", 19);  //@NON-NLS
	СтруктураСоответствий.Вставить("Z", 42);  //@NON-NLS
	
	Возврат СтруктураСоответствий;
	
КонецФункции

// Возвращает свернутую копию таблицы
//
// Параметры:
//  Таблица					 - ТаблицаЗначений - Исходная таблица
//  КолонкиГруппировок		 - Строка - Имена колонок, по которым необходимо группировать строки.
//  ДополнительныеАналитики	 - Строка - Имена колонок, по которым необходимо группировать строки, если они есть в исходной таблице.
//  КолонкиСуммирования		 - Строка - Имена колонок, по которым необходимо суммировать значения.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - свернутая копия таблицы значений
//
Функция СвернутаяКопияТаблицы(Таблица, Знач КолонкиГруппировок, Знач ДополнительныеАналитики = Неопределено, Знач КолонкиСуммирования = Неопределено) Экспорт
	
	Если ДополнительныеАналитики <> Неопределено Тогда
		
		СоставДопАналитик = СтрРазделить(ДополнительныеАналитики, ",", Ложь);
		
		Для Индекс = -СоставДопАналитик.ВГраница() По 0 Цикл
			ИмяКолонки = СокрЛП(СоставДопАналитик[-Индекс]);
			Если Таблица.Колонки.Найти(ИмяКолонки) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			СоставДопАналитик.Удалить(-Индекс);
		КонецЦикла;
		
		Если СоставДопАналитик.Количество() <> 0 Тогда
			КолонкиГруппировок = КолонкиГруппировок + "," + СтрСоединить(СоставДопАналитик, ",");
		КонецЕсли;
		
	КонецЕсли;
	
	Если КолонкиСуммирования <> Неопределено Тогда
		НовыйСоставКолонок = КолонкиГруппировок + "," + КолонкиСуммирования;
	Иначе
		НовыйСоставКолонок = КолонкиГруппировок;
	КонецЕсли;
	
	Если ТипЗнч(Таблица) <> Тип("ТаблицаЗначений") Тогда
		ВременнаяТаблица = Таблица.Выгрузить(, НовыйСоставКолонок);
	Иначе
		ВременнаяТаблица = Таблица.Скопировать(, НовыйСоставКолонок);
	КонецЕсли;
	
	ВременнаяТаблица.Свернуть(КолонкиГруппировок, КолонкиСуммирования);
	
	Возврат ВременнаяТаблица;
	
КонецФункции

// Возвращает таблицу значений с данными дерева значений
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений - дерево с данными
//  Уровень		 - Число - уровень дерева, на котором расположены искомые данные (нумерация с 0). Если не передано, то 
//						   будут возвращенные данные со всех последних уровней веток.
//
// Возвращаемое значение:
//  ТаблицаЗначений - содержит данные дерева.
//
Функция ДанныеДерева(ДеревоДанных, Уровень = Неопределено) Экспорт
	
	ТаблицаВозврата = Новый ТаблицаЗначений;
	Для Каждого Колонка Из ДеревоДанных.Колонки Цикл
		ТаблицаВозврата.Колонки.Добавить(Колонка.Имя, Колонка.ТипЗначения);
	КонецЦикла;
	
	СтрокиДерева = ДеревоДанных.Строки;
	
	ЗаполнитьТаблицуРекурсивно(ТаблицаВозврата, СтрокиДерева, Уровень, 0);
	
	Возврат ТаблицаВозврата;

КонецФункции

Процедура ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, СтрокиДерева, ИскомыйУровень, ТекущийУровень)
	
	Для Каждого Строка Из СтрокиДерева Цикл

		Если ТипЗнч(СтрокиДерева) = Тип("КоллекцияСтрокДереваЗначений") Тогда
			Подстроки = Строка.Строки;
		ИначеЕсли ТипЗнч(СтрокиДерева) = Тип("ДанныеФормыКоллекцияЭлементовДерева") Тогда
			Подстроки = Строка.ПолучитьЭлементы();
		КонецЕсли;
		
		Если ИскомыйУровень = ТекущийУровень 
			Или (ИскомыйУровень = Неопределено И Подстроки.Количество() = 0) Тогда
			НовСтрока = ТаблицаЗначений.Добавить();
			ЗаполнитьЗначенияСвойств(НовСтрока, Строка);
		Иначе
			ЗаполнитьТаблицуРекурсивно(ТаблицаЗначений, Подстроки, ИскомыйУровень, ТекущийУровень + 1);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает свойства последнего задания.
//
// Параметры:
//  Задание - РегламентноеЗадание - строка уникального идентификатора РегламентногоЗадания.
//          - Структура - Содержит ключ:
//          	* Идентификатор - СправочникСсылка.ОчередьЗаданий - 
//
// Возвращаемое значение:
//  Структура - Ключи:
//	      * ДатаНачала - Дата -
//	      * ДатаЗавершения - Дата -
//	      * ДатаПлан - Дата -
// 	      * Состояние - СостояниеФоновогоЗадания -
//
Функция ПолучитьСостояниеПоследнегоЗадания(Задание) Экспорт
	
	СвойстваЗадания = Новый Структура("ДатаНачала, ДатаЗавершения, ДатаПлан, Состояние");
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		
		ЭлементСправочника = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Задание.Идентификатор, "ДатаНачалаПоследнегоЗапуска, ДатаЗавершенияПоследнегоЗапуска, ЗапланированныйМоментЗапуска, СостояниеЗадания");
		
		СвойстваЗадания.ДатаНачала = ЭлементСправочника.ДатаНачалаПоследнегоЗапуска;
		СвойстваЗадания.ДатаЗавершения = ЭлементСправочника.ДатаЗавершенияПоследнегоЗапуска;
		СвойстваЗадания.ДатаПлан = ЭлементСправочника.ЗапланированныйМоментЗапуска;
		СвойстваЗадания.Состояние = ЭлементСправочника.СостояниеЗадания;
		
	Иначе
		
		РегламентныеЗаданияСлужебный.ВызватьИсключениеЕслиНетПраваАдминистрирования();
		УстановитьПривилегированныйРежим(Истина);
		
		ИдентификаторРегламентногоЗадания = ?(ТипЗнч(Задание) = Тип("РегламентноеЗадание"), Строка(Задание.УникальныйИдентификатор), Задание);
		Отбор = Новый Структура;
		Отбор.Вставить("ИдентификаторРегламентногоЗадания", ИдентификаторРегламентногоЗадания);
		Отбор.Вставить("ПолучитьПоследнееФоновоеЗаданиеРегламентногоЗадания");
		ТаблицаСвойствФоновыхЗаданий = РегламентныеЗаданияСлужебный.СвойстваФоновыхЗаданий(Отбор);
		ТаблицаСвойствФоновыхЗаданий.Сортировать("Конец Возр");
		
		Если ТаблицаСвойствФоновыхЗаданий.Количество() = 0 Тогда
			СвойстваРегЗадания = Неопределено;
		ИначеЕсли НЕ ЗначениеЗаполнено(ТаблицаСвойствФоновыхЗаданий[0].Конец) Тогда
			СвойстваРегЗадания = ТаблицаСвойствФоновыхЗаданий[0];
		Иначе
			СвойстваРегЗадания = ТаблицаСвойствФоновыхЗаданий[ТаблицаСвойствФоновыхЗаданий.Количество()-1];
		КонецЕсли;
		
		Если СвойстваРегЗадания <> Неопределено Тогда
		
			СвойстваЗадания.ДатаНачала = СвойстваРегЗадания.Начало;
			СвойстваЗадания.ДатаЗавершения = СвойстваРегЗадания.Конец;
			СвойстваЗадания.Состояние = СвойстваРегЗадания.Состояние;
		
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СвойстваЗадания;
	
КонецФункции

Функция СвойствоМетаданных(МетаданныеОбъекта, ЧастиИмени, Индекс = 0)
	
	Имя = ЧастиИмени[Индекс];
	Свойство = МетаданныеОбъекта[Имя];
	Если Индекс < ЧастиИмени.ВГраница() Тогда
		Свойство = СвойствоМетаданных(Свойство, ЧастиИмени, Индекс+1);
	КонецЕсли;
	Возврат Свойство;
	
КонецФункции

// Проверяет, что переданный тип - примитивный
//
// Параметры:
//  ПроверяемыйТип - Тип - 
// 
// Возвращаемое значение:
//  Булево -
//
Функция ЭтоПримитивныйТип(ПроверяемыйТип) Экспорт
	
	Если ПроверяемыйТип = Тип("Неопределено")
		Или ПроверяемыйТип = Тип("Булево")
		Или ПроверяемыйТип = Тип("Строка")
		Или ПроверяемыйТип = Тип("Число")
		Или ПроверяемыйТип = Тип("Дата")
		Или ПроверяемыйТип = Тип("УникальныйИдентификатор") Тогда
		
		Возврат Истина;
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли;
	
КонецФункции

// Представление объекта по метаданным
//
// Параметры:
//  МетаданныеОбъекта - ОбъектМетаданных -
// 
// Возвращаемое значение:
//  Строка -
//
Функция ПредставлениеОбъектаПоМетаданным(МетаданныеОбъекта) Экспорт
		
	Если Не ПустаяСтрока(МетаданныеОбъекта.ПредставлениеОбъекта) Тогда
		Возврат МетаданныеОбъекта.ПредставлениеОбъекта;
	Иначе
		Возврат МетаданныеОбъекта.Синоним;
	КонецЕсли;
	
КонецФункции

// Получает склад который можно использовать по умолчанию
// Если склад не удалось определить и не используется несколько складов то пользователю выдается сообщение.
// 
// Возвращаемое значение:
//   СправочникСсылка.Склады - 
//
Функция ПолучитьПроверитьСкладПоУмолчанию() Экспорт

	СкладПоУмолчанию = ЗначениеНастроекПовтИсп.ПолучитьСкладПоУмолчанию();
	
	Если Не ЗначениеЗаполнено(СкладПоУмолчанию)
		И Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоСкладов") Тогда
		
		Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2
		|	Склады.Ссылка
		|ИЗ
		|	Справочник.Склады КАК Склады");
		
		Если Запрос.Выполнить().Выбрать().Количество() = 2 Тогда
			ВызватьИсключение НСтр("ru = 'Не удалось определить склад, т.к. в информационной базе введено несколько складов,
			|Включите опцию ""НСИ и администрирование""-""Склад и доставка""-""Несколько складов""!'");
		Иначе
			ВызватьИсключение НСтр("ru = 'Не удалось определить склад. Возможно, в информационной базе не введено ни одного склада
			|Для настройки необходимо перейти в раздел ""НСИ и администрирование""-""Сведения о предприятии""-""Настройка складского учета"".'");
		КонецЕсли;
		
	КонецЕсли;

	Возврат СкладПоУмолчанию
	
КонецФункции

// Устанавливаем условное оформление для поля формы "ВариантОформления" в документе ТаможеннаяДекларация
//    в зависимости от его значения.
//
// Параметры:
// 		Список - ФормаКлиентскогоПриложения - Содержит данную форму.
//
Процедура УстановитьУсловноеОформлениеВариантОформленияГТД(Список) Экспорт
	
	УсловноеОформление = Список.УсловноеОформление;
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ВариантОформления");

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВариантОформления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Перечисления.ХозяйственныеОперации.ОформлениеГТДБрокером;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Брокером'"));
	
	//
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ВариантОформления");

	ОтборЭлемента = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ВариантОформления");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = Перечисления.ХозяйственныеОперации.ОформлениеГТДСамостоятельно;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'Самостоятельно'"));
	
КонецПроцедуры

// Параметры:
// 	Ссылка - ДокументСсылка - 
// 	Регистры - См. ОбщегоНазначенияУТПовтИсп.РегистрыСведенийПоМетаданнымИзмерений
Функция ЭтоЗаписьВедомогоРегистраСведений(Ссылка, Регистры)
	
	Для Каждого Элемент Из Регистры Цикл
		Если ТипЗнч(Ссылка) = Тип("РегистрСведенийКлючЗаписи." + Элемент.Имя) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция ЭтоЗаписьИсключаемогоОбъекта(Ссылка, Объекты)
	
	Для Каждого Элемент Из Объекты Цикл
		ПолноеИмя = Элемент.ПолноеИмя();
		
		ВидМетаданных = "";
		Если СтрНайти(ПолноеИмя, "Справочник.") Тогда
			ВидМетаданных = "СправочникСсылка";
		ИначеЕсли СтрНайти(ПолноеИмя, "Документ.") Тогда
			ВидМетаданных = "ДокументСсылка";
		ИначеЕсли СтрНайти(ПолноеИмя, "РегистрСведений.") Тогда
			ВидМетаданных = "РегистрСведенийКлючЗаписи";
		Иначе
			Возврат Ложь;
		КонецЕсли;
		
		Если ТипЗнч(Ссылка) = Тип(ВидМетаданных + "." + Элемент.Имя) Тогда
			Возврат Истина;
		Иначе
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
КонецФункции

Функция НазначенияЗаказов(МассивЗаказов)
	
	Запрос = Новый Запрос();
	Запрос.Текст =
		"ВЫБРАТЬ
		|	Таблица.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.Назначения КАК Таблица
		|ГДЕ
		|	Таблица.Заказ В(&МассивЗаказов)";
	Запрос.УстановитьПараметр("МассивЗаказов", МассивЗаказов);
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Ссылка");
	
КонецФункции

// Переносит файл от прежнего владельца к новому
//
// Параметры:
//	ВладелецФайла - ЛюбаяСсылка - ссылка на новый объект-владелец файла
//	РеквизитПриемник - СправочникСсылка -
//	                 - СправочникСсылка.ПартнерыПрисоединенныеФайлы - Значение переменной-приемника ссылки на новый файл
//	РеквизитИсточник - СправочникСсылка -
//	                 - СправочникСсылка.ПартнерыПрисоединенныеФайлы - Значение переменной-источника ссылки на новый файл
//	ФормироватьНовуюСсылкуНаФайл - Булево - указывает создавать ли файл с новой ссылкой или использовать текущую.
//
Процедура СкопироватьПрисоединенныйФайл(ВладелецФайла, РеквизитПриемник, РеквизитИсточник, ФормироватьНовуюСсылкуНаФайл = Истина) Экспорт
	ФайлИсточник = РаботаСФайлами.ДанныеФайла(РеквизитИсточник, Новый УникальныйИдентификатор, Истина);
	
	Параметры = Новый Структура;
	Параметры.Вставить("Автор", Пользователи.ТекущийПользователь());
	Параметры.Вставить("ВладелецФайлов", ВладелецФайла);
	Параметры.Вставить("ИмяБезРасширения", ФайлИсточник.Наименование);
	Параметры.Вставить("РасширениеБезТочки", ФайлИсточник.Расширение);
	Параметры.Вставить("ВремяИзмененияУниверсальное", ФайлИсточник.ДатаМодификацииУниверсальная);
	
	ИмяСправочника = РаботаСФайламиСлужебный.ИмяСправочникаХраненияФайлов(ВладелецФайла,, Неопределено);
	
	РеквизитПриемник = РаботаСФайлами.ДобавитьФайл(
		Параметры,
		ФайлИсточник.СсылкаНаДвоичныеДанныеФайла,,
		ОбщегоНазначения.ЗначениеРеквизитаОбъекта(РеквизитИсточник, "Описание"),
		?(ФормироватьНовуюСсылкуНаФайл, 
			Неопределено, 
			Справочники[ИмяСправочника].ПолучитьСсылку(РеквизитИсточник.УникальныйИдентификатор())
		)
	);
КонецПроцедуры

// Возвращает хеш сумму переданного объекта
//
// Параметры:
//	СериализуемыйОбъект - Произвольный - объект, который может быть сериализован. В противном случае будет выдано исключение.
//	ТипХешФункции - ХешФункция - один из типов хеш-функции CRC32, MD5, SHA1, SHA256.
//
// Возвращаемое значение:
//  Строка - хеш-сумма в виде строки.
//
Функция ХешСуммаСериализуемогоОбъекта(СериализуемыйОбъект, ТипХешФункции) Экспорт
	СериализованнаяСтрока = ОбщегоНазначения.ЗначениеВСтрокуXML(СериализуемыйОбъект);
	
	ХешированиеДанных = Новый ХешированиеДанных(ТипХешФункции);
	ХешированиеДанных.Добавить(СериализованнаяСтрока);
	ХешСумма = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	Возврат ХешСумма;
КонецФункции

// Возвращает хеш сумму переданного объекта
//
// Параметры:
//	ИсходнаяСтрока - Строка - строка, по которой будет строится хеш. В противном случае будет выдано исключение.
//	ТипХешФункции - ХешФункция - один из типов хеш-функции CRC32, MD5, SHA1, SHA256.
//
// Возвращаемое значение:
//  Строка - хеш-сумма в виде строки.
//
Функция ХешСуммаСтроки(ИсходнаяСтрока, ТипХешФункции) Экспорт
	Если Не ТипЗнч(ИсходнаяСтрока) = Тип("Строка") Тогда
		ВызватьИсключение НСтр("ru = 'Недопустимый тип источника получения данных.'");
	КонецЕсли;
	
	ХешированиеДанных = Новый ХешированиеДанных(ТипХешФункции);
	ХешированиеДанных.Добавить(ИсходнаяСтрока);
	ХешСумма = СтрЗаменить(ХешированиеДанных.ХешСумма, " ", "");
	
	Возврат ХешСумма;
КонецФункции

Процедура ПроверитьИспользованиеРеквизитаПолучитьПустоеЗначение(Объект, МетаданныеОбъекта, ИмяРеквизита, ПустыеЗначенияРеквизитов)
	
	Если ПустыеЗначенияРеквизитов.Свойство(ИмяРеквизита) Тогда
		Возврат;
	КонецЕсли;
	
	МетаданныеРеквизита = МетаданныеОбъекта.Реквизиты.Найти(ИмяРеквизита);
	
	Если МетаданныеРеквизита = Неопределено Тогда
		
		Для Каждого СтандартныйРеквизит Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
			Если СтандартныйРеквизит.Имя = ИмяРеквизита Тогда
				МетаданныеРеквизита = СтандартныйРеквизит;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если МетаданныеРеквизита = Неопределено Тогда
			ТекстИсключения = НСтр("ru = 'Реквизит %ИмяРеквизита% не найден в %ИмяОъекта%. Ошибка в описании параметров синхронизации с ключами.'");
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяРеквизита%", ИмяРеквизита);
			ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ИмяОъекта%", МетаданныеОбъекта.ПолноеИмя());
			ВызватьИсключение ТекстИсключения;
		КонецЕсли;
		
	Иначе
		
		Если (ОбщегоНазначения.ЭтоСправочник(МетаданныеОбъекта)
			Или ОбщегоНазначения.ЭтоПланВидовХарактеристик(МетаданныеОбъекта))
			И (МетаданныеОбъекта.Иерархический
			И МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов) Тогда
			
			Если МетаданныеРеквизита.Использование <> Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппыИЭлемента Тогда
				
				Если (Объект.ЭтоГруппа
					И МетаданныеРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
					Или (Не Объект.ЭтоГруппа
					И МетаданныеРеквизита.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы) Тогда
					
					ПустыеЗначенияРеквизитов.Вставить(ИмяРеквизита, "Неиспользуется");
					Возврат;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	ПустыеЗначенияРеквизитов.Вставить(ИмяРеквизита,	МетаданныеРеквизита.Тип.ПривестиЗначение()); 
		
КонецПроцедуры

// Выполняет свертку набора записей регистра.
//
// Параметры:
// 	Набор - РегистрНакопленияНаборЗаписей, РегистрСведенийНаборЗаписей - 
// 	ТребуетсяСортировка - Булево - Требуется ли сортировать набор перед записью по измерениям.
//
Процедура СвернутьНаборЗаписей(Набор, ТребуетсяСортировка = Ложь) Экспорт
	
	ЗаписиРегистра = Набор.Выгрузить();
	
	ВсеКолонки = Новый Массив();
	Для Каждого Колонка Из ЗаписиРегистра.Колонки Цикл
		ВсеКолонки.Добавить(Колонка.Имя);
	КонецЦикла;
	
	Ресурсы = Новый Массив();
	ОтборПустыхРесурсов = Новый Структура();
	Для Каждого Ресурс Из Набор.Метаданные().Ресурсы Цикл
		Ресурсы.Добавить(Ресурс.Имя);
		ОтборПустыхРесурсов.Вставить(Ресурс.Имя, 0);
	КонецЦикла;
	
	КолонкиГруппировки = ОбщегоНазначенияУТКлиентСервер.РазличияМассивов(ВсеКолонки, Ресурсы);
	КолонкиГруппировки.Удалить(КолонкиГруппировки.Найти("НомерСтроки"));
	
	КолонкиГруппировкиСтрокой = СтрСоединить(КолонкиГруппировки, ", ");
	КолонкиСуммированияСтрокой = СтрСоединить(Ресурсы, ", ");
	
	ЗаписиРегистра.Свернуть(КолонкиГруппировкиСтрокой, КолонкиСуммированияСтрокой);
	
	Для Каждого ЗаписьСПустымиРесурсами Из ЗаписиРегистра.НайтиСтроки(ОтборПустыхРесурсов) Цикл
		ЗаписиРегистра.Удалить(ЗаписьСПустымиРесурсами);
	КонецЦикла;
	
	Если ТребуетсяСортировка Тогда
		ОбъектСравнения = Новый СравнениеЗначений;
		ЗаписиРегистра.Сортировать(КолонкиГруппировкиСтрокой, ОбъектСравнения);
	КонецЕсли;
	Набор.Загрузить(ЗаписиРегистра);
	
КонецПроцедуры

#КонецОбласти

#Область РаботаСЖурналамиДокументов 

// Массив менеджеров документов, используемых в переданном массиве хозяйственных операций.
//
// Параметры:
//  ДоступныеХозяйственныеОперацииИДокументы - Массив - 
// 
// Возвращаемое значение:
//  Массив -
//
Функция ИспользуемыеМенеджерыДокументов(ДоступныеХозяйственныеОперацииИДокументы) Экспорт 
	
	ТаблицаОперацииНакладные = ВыделенныеХозяйственныеОперацииИДокументы(ДоступныеХозяйственныеОперацииИДокументы);
	
	МетаданныеДокументов = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ОбъектМетаданныхДокумента"); // Массив Из ОбъектМетаданных -
	
	МассивМенеджеров = Новый Массив();
	
	Для Каждого Строка Из МетаданныеДокументов Цикл
		Имя = Строка.Имя;
		МенеджерДокумента = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(Имя);
		МассивМенеджеров.Добавить(МенеджерДокумента);
	КонецЦикла;
	
	МассивМенеджеров = ОбщегоНазначенияКлиентСервер.СвернутьМассив(МассивМенеджеров);
	
	Возврат МассивМенеджеров;
	
КонецФункции

// Массив типов документов, используемых в переданном массиве хозяйственных операций.
//
// Параметры:
//  ХозяйственныеОперацииИДокументы - Массив - 
//  Отбор 						- Структура - Структура отбора по таблице ОписаниеМетаданныхНакладных.
// 
// Возвращаемое значение:
//   Массив Из Строка -
//
Функция ИспользуемыеПолныеИменаДокументов(ХозяйственныеОперацииИДокументы, Отбор = Неопределено) Экспорт 
	
	ПолныеИменаДокументов = Новый Массив();
	
	ТаблицаОперацииНакладные = ВыделенныеХозяйственныеОперацииИДокументы(ХозяйственныеОперацииИДокументы);
		
	Если Отбор <> Неопределено Тогда
		НайденныеСтроки = ТаблицаОперацииНакладные.НайтиСтроки(Отбор);
		
		Для Каждого Строка Из НайденныеСтроки Цикл
			ПолныеИменаДокументов.Добавить(Строка.ПолноеИмяДокумента);
		КонецЦикла;
	Иначе
		
		ПолныеИменаДокументов = ТаблицаОперацииНакладные.ВыгрузитьКолонку("ПолноеИмяДокумента");
		
	КонецЕсли;
	
	ПолныеИменаДокументов = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ПолныеИменаДокументов);
	
	Возврат ПолныеИменаДокументов;
	
КонецФункции

// Возвращает таблицу с выделенными отборами по хоз. операциям и документам
//
// Параметры:
//  ДоступныеХозяйственныеОперацииИДокументы - ТаблицаЗначений	 - выгрузка таблицы из реквизита формы ХозяйственныеОперацииИДокументы.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - 
//
Функция ВыделенныеХозяйственныеОперацииИДокументы(ДоступныеХозяйственныеОперацииИДокументы) Экспорт  
	
	ОтобраннаяТаблица = ДоступныеХозяйственныеОперацииИДокументы.СкопироватьКолонки();
	
	Отбор = Новый Структура();
	Отбор.Вставить("Отбор", Истина);
	
	НайденныеСтроки = ДоступныеХозяйственныеОперацииИДокументы.НайтиСтроки(Отбор);
	
	Для Каждого НайденнаяСтрока Из НайденныеСтроки Цикл
		Строка = ОтобраннаяТаблица.Добавить();
		ЗаполнитьЗначенияСвойств(Строка, НайденнаяСтрока);
	КонецЦикла;
	
	Возврат ОтобраннаяТаблица;
	
КонецФункции

// Выделенные хозяйственные операции
//
// Параметры:
//  ХозяйственныеОперацииИДокументы	 - ДанныеФормыКоллекция - Список значений формы с доступными хоз. операциями.
// 
// Возвращаемое значение:
//  Массив - 
//
Функция ВыделенныеХозяйственныеОперации(ХозяйственныеОперацииИДокументы) Экспорт 
	
	МассивХозОпераций = Новый Массив();
	
	МассивВыделенныхСтрок = ХозяйственныеОперацииИДокументы.НайтиСтроки(Новый Структура("Отбор", Истина));	
	
	Для Каждого Строка Из МассивВыделенныхСтрок Цикл
		МассивХозОпераций.Добавить(Строка.ХозяйственнаяОперация);
	КонецЦикла;
	
	// Пустой массив означает отсутствие отбора. Отсутствие отбора равнозначно всем выбранным элементам.
	Если МассивХозОпераций.Количество() = 0 Тогда
		МассивХозОпераций = ХозяйственныеОперацииИДокументы.ВыгрузитьКолонку("ХозяйственнаяОперация");
	КонецЕсли;
	
	Возврат МассивХозОпераций;
	
КонецФункции

// Процедура - Удалить подчиненные элементы элемента формы
//
// Параметры:
//  Форма			 - ФормаКлиентскогоПриложения - форма, с которой удаляются элементы
//  ЭлементФормы	 - ТаблицаФормы, ГруппаФормы - элемент формы, подчиненные элементы которого нужно удалить
//  УдалятьКоманды	 - Булево - 
//
Процедура УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, ЭлементФормы, УдалятьКоманды = Ложь) Экспорт 
	
	ЭлементыНаУдаление = Новый Массив();
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ЭлементыНаУдаление, ЭлементФормы.ПодчиненныеЭлементы);
	Для ИндексЭлемента = 0 По ЭлементыНаУдаление.Количество() - 1 Цикл
		
		Элемент = ЭлементыНаУдаление[ИндексЭлемента];
		
		Если ТипЗнч(Элемент) = Тип("ГруппаФормы") Тогда
			УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, Элемент, УдалятьКоманды);
		ИначеЕсли ТипЗнч(Элемент) = Тип("КнопкаФормы")
			И УдалятьКоманды Тогда			
			КомандаКУдалению = Форма.Команды.Найти(Элемент.ИмяКоманды);
			Если КомандаКУдалению <> Неопределено Тогда
				Форма.Команды.Удалить(КомандаКУдалению);
			КонецЕсли;
		КонецЕсли;
		
		Форма.Элементы.Удалить(Элемент);
		
	КонецЦикла;
	
КонецПроцедуры

// Добавляет кнопки изменения статусов в группу формы
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - 
//  СписокУстановитьСтатус - ГруппаФормы - Группа формы, куда должны быть помещены кнопки изменения статусов.
//
Процедура УстановитьСписокСтатусов(Форма, СписокУстановитьСтатус) Экспорт
		
	// Очистка элементов в случае переинициализации списка статусов
	УдалитьПодчиненныеЭлементыЭлементаФормы(Форма, СписокУстановитьСтатус);
	
	Форма.СоответствиеКомандСтатусам.Очистить();
	
	СтатусыДокументов = Новый ТаблицаЗначений();
	СтатусыДокументов.Колонки.Добавить("ИмяДокумента", 			Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СинонимДокумента", 		Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СтатусПредставление", 	Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("СтатусИмяЗначения", 	Новый ОписаниеТипов("Строка"));
	СтатусыДокументов.Колонки.Добавить("Статус");
	
	СоответствияОпераций = ВыделенныеХозяйственныеОперацииИДокументы(Форма.ХозяйственныеОперацииИДокументы.Выгрузить());
		
	СоответствияОпераций.Свернуть("ПолноеИмяДокумента, ИспользуютсяСтатусы, ПравоДоступаИзменение");
	
	Для Каждого СтрокаСоответствия Из СоответствияОпераций Цикл
		
		Если СтрокаСоответствия.ИспользуютсяСтатусы И СтрокаСоответствия.ПравоДоступаИзменение Тогда
			МенеджерДокумента = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(СтрокаСоответствия.ПолноеИмяДокумента);
			СтатусыДокумента = МенеджерДокумента.СтатусыДокументаИзменяемыеИзСписка();
			МетаданныеОбъекта = МетаданныеОбъектаПоПолномуИмени(СтрокаСоответствия.ПолноеИмяДокумента);
			Для Каждого СтрокаСтатус Из СтатусыДокумента Цикл
				СтрокаСтатусаДокумента = СтатусыДокументов.Добавить();
				СтрокаСтатусаДокумента.ИмяДокумента = МетаданныеОбъекта.Имя;
				СтрокаСтатусаДокумента.СинонимДокумента = МетаданныеОбъекта.Синоним;
				СтрокаСтатусаДокумента.Статус = СтрокаСтатус.Статус;
				СтрокаСтатусаДокумента.СтатусПредставление = СтрокаСтатус.СтатусПредставление;
				СтрокаСтатусаДокумента.СтатусИмяЗначения = ОбщегоНазначения.ИмяЗначенияПеречисления(СтрокаСтатус.Статус);
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Для Индекс = 0 По СтатусыДокументов.Количество() - 1 Цикл
		
		СтрокаСтатусаДокумента = СтатусыДокументов[Индекс];
		
		УникальноеИмяКнопки = СтрокаСтатусаДокумента.ИмяДокумента + Индекс;
		
		Если Форма.Команды.Найти(УникальноеИмяКнопки) = Неопределено Тогда
			Команда = Форма.Команды.Добавить(УникальноеИмяКнопки);
			Команда.Действие = "Подключаемый_УстановитьСтатус";
		КонецЕсли;
		
		Кнопка = Форма.Элементы.Добавить(УникальноеИмяКнопки, Тип("КнопкаФормы"), СписокУстановитьСтатус);
		Кнопка.Заголовок = СтрокаСтатусаДокумента.СинонимДокумента + ": " + СтрокаСтатусаДокумента.СтатусПредставление;
		Кнопка.ИмяКоманды = УникальноеИмяКнопки;
		
		СтрокаСоответствияКоманд = Форма.СоответствиеКомандСтатусам.Добавить();
		СтрокаСоответствияКоманд.ИмяКоманды = УникальноеИмяКнопки;
		СтрокаСоответствияКоманд.Статус = СтрокаСтатусаДокумента.Статус;
		СтрокаСоответствияКоманд.СтатусПредставление = СтрокаСтатусаДокумента.СтатусПредставление;
		СтрокаСоответствияКоманд.СтатусИмяЗначения = СтрокаСтатусаДокумента.СтатусИмяЗначения;
		СтрокаСоответствияКоманд.ДокументСтрока = СтрокаСтатусаДокумента.ИмяДокумента;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает шаблон таблицы для помещения в нее описаний статусов для журналов документов.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица с колонками:
//		*Статус - ПеречислениеСсылка - ссылка на статус документа
//		*СтатусПредставление - Строка - представление статуса; указывается, если нужно переопределить синоним статуса.
//
Функция ТаблицаСтатусовИзменяемыхИзСписка() Экспорт 
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Статус");
	Таблица.Колонки.Добавить("СтатусПредставление", Новый ОписаниеТипов("Строка"));
	
	Возврат Таблица;
	
КонецФункции

// Добавляет строку в ранее созданную таблицу
//
// Параметры:
//  Таблица				 - см. ТаблицаСтатусовИзменяемыхИзСписка
//  Статус				 - ПеречислениеСсылка	 - см. ТаблицаСтатусовИзменяемыхИзСписка.
//  СтатусПредставление	 - Строка				 - см. ТаблицаСтатусовИзменяемыхИзСписка.
//
Процедура ДобавитьСтрокуВТаблицуСтатусовИзменяемыхИзСписка(Таблица, Статус, Знач СтатусПредставление = "") Экспорт
	
	НоваяСтрока = Таблица.Добавить();
	НоваяСтрока.Статус = Статус;
	Если Не ЗначениеЗаполнено(СтатусПредставление) Тогда 
		СтатусПредставление = Строка(Статус);
	КонецЕсли;
	НоваяСтрока.СтатусПредставление = СтатусПредставление;
		
КонецПроцедуры

// Возвращает массив объектов метаданных по таблице ХозяйственныеОперацииИДокументы
//
// Параметры:
//  ХозяйственныеОперацииИДокументы - ТаблицаЗначений -
//	                                - ДанныеФормыКоллекция - таблица колонками "ПолноеИмяДокумента" и "Отбор"
//  Отбор							- Структура - структура дополнительных отборов, ключи которых должны быть колонками в таблице ХозяйственныеОперацииИДокументы.
// 
// Возвращаемое значение:
//  Массив - массив объектов метаданных.
//
Функция ОбъектыМетаданныхИзХозяйственныхОперацийИДокументов(ХозяйственныеОперацииИДокументы, Отбор = Неопределено) Экспорт
	
	СтруктураОтбора = Новый Структура("Отбор",Истина);
	Если Отбор <> Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(СтруктураОтбора, Отбор);
	КонецЕсли;
	НайденныеСтроки = ХозяйственныеОперацииИДокументы.НайтиСтроки(СтруктураОтбора);
	ОбработанныеИмена = Новый Соответствие;
	ОбъектыМетаданных = Новый Массив;
	Для Каждого Стр Из НайденныеСтроки Цикл
		Если ОбработанныеИмена.Получить(Стр.ПолноеИмяДокумента) = Неопределено Тогда
			ОбработанныеИмена.Вставить(Стр.ПолноеИмяДокумента, Стр.ПолноеИмяДокумента);
			МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(Стр.ПолноеИмяДокумента);
			ОбъектыМетаданных.Добавить(МетаданныеОбъекта);
		КонецЕсли;
	КонецЦикла;
	Возврат ОбъектыМетаданных;
	
КонецФункции

Функция СформироватьГиперссылкуКОформлению(ХозяйственныеОперацииИДокументы, ПараметрыФормирования, Заголовок = "") Экспорт
	
	МассивСтрок = Новый Массив;
	МассивСтрок.Добавить(?(ПустаяСтрока(Заголовок), НСтр("ru = 'К оформлению:'"), Заголовок) + " ");
	
	СтруктураОтбора = Новый Структура("Отбор", Истина);
	МенеджерыРасчетаГиперссылок = ХозяйственныеОперацииИДокументы.Скопировать(СтруктураОтбора, "МенеджерРасчетаГиперссылкиКОформлению");
	
	МенеджерыРасчетаГиперссылок.Свернуть("МенеджерРасчетаГиперссылкиКОформлению");
	МенеджерыРасчетаГиперссылок = МенеджерыРасчетаГиперссылок.ВыгрузитьКолонку("МенеджерРасчетаГиперссылкиКОформлению");
	
	Для Каждого МенеджерРасчетаГиперссылок Из МенеджерыРасчетаГиперссылок Цикл
		Если МенеджерРасчетаГиперссылок = "" Тогда
			Продолжить;
		КонецЕсли;
		
		ПараметрыФормирования.Вставить("ХозяйственныеОперацииИДокументы",ХозяйственныеОперацииИДокументы);
		МенеджерОбъекта = ?(Метаданные.ОбщиеМодули.Найти(МенеджерРасчетаГиперссылок) <> Неопределено,
							ОбщегоНазначения.ОбщийМодуль(МенеджерРасчетаГиперссылок),
							ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МенеджерРасчетаГиперссылок));
		Гиперссылка = МенеджерОбъекта.СформироватьГиперссылкуКОформлению(ПараметрыФормирования);
		
		Если ЗначениеЗаполнено(Гиперссылка) Тогда
			Если МассивСтрок.Количество()>1 Тогда
				МассивСтрок.Добавить("; ");
			КонецЕсли;
			МассивСтрок.Добавить(Гиперссылка);
		КонецЕсли;
	КонецЦикла;
	
	Если МассивСтрок.Количество() = 1 Тогда
		Возврат Неопределено
	Иначе
		Возврат Новый ФорматированнаяСтрока(МассивСтрок)
	КонецЕсли;
	
КонецФункции

Функция СформироватьГиперссылкуСмТакжеВРаботе(МассивМенеджеровРасчетаСмТакжеВРаботе, ПараметрыФормирования, Заголовок = "") Экспорт
	
	ЗаглавнаяСтрока = ?(ПустаяСтрока(Заголовок),
		НСтр("ru = 'См. также:'"),
		Заголовок) + " ";
	
	МассивСтрок = Новый Массив;
	МассивСтрок.Добавить(ЗаглавнаяСтрока);
		
	Для Каждого МенеджерРасчетаСмТакжеВРаботе Из МассивМенеджеровРасчетаСмТакжеВРаботе Цикл
		Если МенеджерРасчетаСмТакжеВРаботе = "" Тогда
			Продолжить;
		КонецЕсли;
		
		Гиперссылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МенеджерРасчетаСмТакжеВРаботе).СформироватьГиперссылкуСмТакжеВРаботе(ПараметрыФормирования);
		
		Если ЗначениеЗаполнено(Гиперссылка) Тогда
			Если МассивСтрок.Количество()>1 Тогда
				МассивСтрок.Добавить("; ");
			КонецЕсли;
			МассивСтрок.Добавить(Гиперссылка);
		КонецЕсли;
	КонецЦикла;
	
	Если МассивСтрок.Количество() = 1 Тогда
		Возврат Неопределено
	Иначе
		Возврат Новый ФорматированнаяСтрока(МассивСтрок)
	КонецЕсли;
	
КонецФункции

// Возвращает массив хозяйственных операций переданных типов документов,
// которые отражаются в реестре документов и не отключены по ФО.
//
// Параметры:
//  ТипыДокументов - Массив из Тип - массив типов.
// 
// Возвращаемое значение:
//  Массив Из ПеречислениеСсылка.ХозяйственныеОперации - 
//
Функция ХозяйственныеОперацииДокументовОтраженныеВРеестре(ТипыДокументов) Экспорт
	
	МассивИдентификаторов = Новый Массив;
	МассивХозяйственныхОпераций = Новый Массив;
	
	Для Каждого СтрМас Из ТипыДокументов Цикл
		Если ОбщегоНазначения.ЭтоСсылка(СтрМас) Тогда
			ОбъектМетаданных = Метаданные.НайтиПоТипу(СтрМас);
			Если ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
				МассивИдентификаторов.Добавить(ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ОбъектМетаданных));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ЕСТЬNULL(НастройкиХозяйственныхОперацийФункциональныеОпции.ИмяФункциональнойОпции, """") КАК ИмяФункциональнойОпции,
	|	НастройкиХозяйственныхОперацийДокументы.Ссылка.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|ИЗ
	|	Справочник.НастройкиХозяйственныхОпераций.Документы КАК НастройкиХозяйственныхОперацийДокументы
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.НастройкиХозяйственныхОпераций.ФункциональныеОпции КАК НастройкиХозяйственныхОперацийФункциональныеОпции
	|		ПО НастройкиХозяйственныхОперацийФункциональныеОпции.Ссылка = НастройкиХозяйственныхОперацийДокументы.Ссылка
	|ГДЕ
	|	НастройкиХозяйственныхОперацийДокументы.ИдентификаторОбъектаМетаданных В(&МассивИдентификаторов)
	|	И НастройкиХозяйственныхОперацийДокументы.Ссылка.ИспользоватьВРеестреДокументов
	|
	|УПОРЯДОЧИТЬ ПО
	|	ХозяйственнаяОперация";
	
	Запрос.УстановитьПараметр("МассивИдентификаторов", МассивИдентификаторов);
	
	ТекущаяХозяйственнаяОперация = Неопределено;
	ХозОперацияДобавлена = Ложь;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		
		Если ТекущаяХозяйственнаяОперация <> Выборка.ХозяйственнаяОперация Тогда 
			ХозОперацияДобавлена = Ложь;
			ТекущаяХозяйственнаяОперация = Выборка.ХозяйственнаяОперация; 
		КонецЕсли;
		
		ПолноеИмяФО = СтрШаблон("ФункциональнаяОпция.%1", Выборка.ИмяФункциональнойОпции);
		ЕстьФО = Метаданные.НайтиПоПолномуИмени(ПолноеИмяФО) <> Неопределено;
		
		Если Не ХозОперацияДобавлена  
			И (Не ЕстьФО
			Или ПолучитьФункциональнуюОпцию(Выборка.ИмяФункциональнойОпции)) Тогда
			
			ХозОперацияДобавлена = Истина;
			МассивХозяйственныхОпераций.Добавить(Выборка.ХозяйственнаяОперация);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат МассивХозяйственныхОпераций; 
	
КонецФункции

// Устанавливает отбор в динамическом списке по измерениям, в которых хранятся ключи реестра документов.
//
// Параметры:
//  Список			 - ДинамическийСписок - 
//  ИмяОтбора		 - Строка -
//  ЗначенияОтбора	 - СправочникСсылка -
//	                 - СписокЗначений - значения отбора, которые если необходимо,
//						преобразуются в ключи реестра документов.
//
Процедура УстановитьОтборИзмерениюСКлючами(Список, ИмяОтбора, ЗначенияОтбора) Экспорт
	
	ДляПоискаКлючей = Новый ТаблицаЗначений;
	ДляПоискаКлючей.Колонки.Добавить("Ссылка", Метаданные.Справочники.КлючиРеестраДокументов.Реквизиты.Ключ.Тип);
	
	ЗначенияОтбораДляУстановки = Новый СписокЗначений;
	
	Если ТипЗнч(ЗначенияОтбора) = Тип("СписокЗначений") Тогда
		Для каждого ЭлементСписка Из ЗначенияОтбора Цикл
			Если ЗначениеЗаполнено(ЭлементСписка.Значение) Тогда
				Если ТипЗнч(ЭлементСписка.Значение) = Тип("СправочникСсылка.КлючиРеестраДокументов") Тогда
					ЗначенияОтбораДляУстановки.Добавить(ЭлементСписка.Значение);
				Иначе
					НоваяСтрока = ДляПоискаКлючей.Добавить();
					НоваяСтрока.Ссылка = ЭлементСписка.Значение;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ЗначениеЗаполнено(ЗначенияОтбора) Тогда
		Если ТипЗнч(ЗначенияОтбора) = Тип("СправочникСсылка.КлючиРеестраДокументов") Тогда
			ЗначенияОтбораДляУстановки.Добавить(ЗначенияОтбора);
		Иначе
			НоваяСтрока = ДляПоискаКлючей.Добавить();
			НоваяСтрока.Ссылка = ЗначенияОтбора;
		КонецЕсли;
	КонецЕсли;
	
	Если ДляПоискаКлючей.Количество() > 0  Тогда
		Запрос = Новый Запрос;
		Запрос.Текст =
		"ВЫБРАТЬ
		|	Ключи.Ссылка КАК Ссылка
		|ПОМЕСТИТЬ ВТКлючи
		|ИЗ
		|	&Ключи КАК Ключи
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВТКлючи.Ссылка КАК ЗначениеСсылка,
		|	КлючиРеестраДокументов.Ссылка КАК КлючСсылка
		|ИЗ
		|	ВТКлючи КАК ВТКлючи
		|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.КлючиРеестраДокументов КАК КлючиРеестраДокументов
		|		ПО ВТКлючи.Ссылка = КлючиРеестраДокументов.Ключ";
				
		Запрос.УстановитьПараметр("Ключи", ДляПоискаКлючей);
		
		Выборка = Запрос.Выполнить().Выбрать();
		
		Пока Выборка.Следующий() Цикл
			
			Если ЗначениеЗаполнено(Выборка.КлючСсылка) Тогда
				ЗначенияОтбораДляУстановки.Добавить(Выборка.КлючСсылка);
			ИначеЕсли ОбщегоНазначения.ЭтоПодчиненныйУзелРИБ() Тогда
				
				ТекстСообщения = НСтр("ru = 'Для значения ""%Значение%"" не найден ключ реестра документов. Обратитесь к администратору.'");
				ТекстСообщения = СтрЗаменить(ТекстСообщения, "%Значение%", Выборка.ЗначениеСсылка);
				
				ВызватьИсключение ТекстСообщения;
			Иначе
				
				Справочники.КлючиРеестраДокументов.СоздатьОбновитьКлючиРеестра(,Выборка.ЗначениеСсылка);
				
				Запрос = Новый Запрос;
				Запрос.Текст =
				"ВЫБРАТЬ
				|	КлючиРеестраДокументов.Ссылка КАК КлючСсылка
				|ИЗ
				|	Справочник.КлючиРеестраДокументов КАК КлючиРеестраДокументов
				|ГДЕ
				|	КлючиРеестраДокументов.Ключ = &Ключ";
				Запрос.УстановитьПараметр("Ключ", Выборка.ЗначениеСсылка); 
				
				ВыборкаПоОдномуКлючу = Запрос.Выполнить().Выбрать();
				ВыборкаПоОдномуКлючу.Следующий();
				
				ЗначенияОтбораДляУстановки.Добавить(ВыборкаПоОдномуКлючу.КлючСсылка);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(
		Список,
		ИмяОтбора,
		ЗначенияОтбораДляУстановки,
		ВидСравненияКомпоновкиДанных.ВСписке,
		,
		ЗначенияОтбораДляУстановки.Количество() > 0);
	
КонецПроцедуры

// Шаблон таблицы для описания документов создаваемых из рабочих мест
// 
// Возвращаемое значение:
// 	ТаблицаЗначений - Описание:
// * ХозяйственнаяОперация - ПеречислениеСсылка.ХозяйственныеОперации -
// * ИдентификаторОбъектаМетаданных - СправочникСсылка.ИдентификаторыОбъектовМетаданных -
// * Отбор - Булево -
// * ДокументПредставление - Строка -
// * ПолноеИмяДокумента - Строка -
// * ИспользуютсяСтатусы - Булево -
// * КлючНазначенияИспользования - Строка -
// * ПравоДоступаДобавление - Булево -
// * ПравоДоступаИзменение - Булево -
// * ЗаголовокРабочегоМеста - Строка -
// * ИменаЭлементовРабочегоМеста - Строка -
// * МенеджерРасчетаГиперссылкиКОформлению - Строка -
// * ДобавитьКнопкуСоздать - Булево -
// * ТипДокумента - Тип -
Функция НоваяТаблицаХозяйственныеОперацииИДокументы() Экспорт

	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("ХозяйственнаяОперация", Новый ОписаниеТипов("ПеречислениеСсылка.ХозяйственныеОперации"));
	Результат.Колонки.Добавить("ИдентификаторОбъектаМетаданных", Новый ОписаниеТипов("СправочникСсылка.ИдентификаторыОбъектовМетаданных"));
	Результат.Колонки.Добавить("Отбор", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ДокументПредставление", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ПолноеИмяДокумента", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ИспользуютсяСтатусы", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("КлючНазначенияИспользования", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ПравоДоступаДобавление", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ПравоДоступаИзменение", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЗаголовокРабочегоМеста", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ИменаЭлементовРабочегоМеста", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("МенеджерРасчетаГиперссылкиКОформлению", Новый ОписаниеТипов("Строка",,,,Новый КвалификаторыСтроки(0)));
	Результат.Колонки.Добавить("ДобавитьКнопкуСоздать", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ТипДокумента", Новый ОписаниеТипов("Тип"));
	
	Возврат Результат;
	
КонецФункции

// Обработчик подписки ПодготовитьДанныеДляСинхронизацииКлючейПередЗаписью
//
// Параметры:
// 	Объект - СправочникОбъект - 
//  Отказ - Булево - 
//	
Процедура ПодготовитьДанныеДляСинхронизацииКлючейПередЗаписью(Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	Параметры = Новый Соответствие;
	
	Если ТипЗнч(Объект) = Тип("СправочникОбъект.ФизическиеЛица") Тогда
		Параметры.Вставить("Справочник.КлючиРеестраДокументов", "ПометкаУдаления,Наименование,ИНН");
	Иначе
		ТекстИсключения = НСтр("ru = 'Для объекта %ТипОбъекта% не описаны параметры синхронизации с ключами.'");
		ТекстИсключения = СтрЗаменить(ТекстИсключения, "%ТипОбъекта%", Метаданные.НайтиПоТипу(Объект).ПолноеИмя());
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
	ПодготовитьДанныеДляСинхронизацииКлючей(Объект, Параметры);
	
КонецПроцедуры

// Обработчик подписки СинхронизироватьКлючиПриЗаписиСправочника
// 
// Параметры:
// 	Объект - СправочникОбъект - 
//  Отказ - Булево - 
//	
Процедура СинхронизироватьКлючиПриЗаписиСправочника(Объект, Отказ) Экспорт
	
	Если Объект.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	СинхронизироватьКлючи(Объект);
	
КонецПроцедуры

// Возвращает значения хозяйственных операций доступных пользователю по группе доступа для объекта информационной базы.
//
// Параметры:
//	ИмяТаблицы - Строка - полное имя объекта информационной базы, например, "РегистрСведений.РеестрДокументов".
//
// Возвращаемое значение:
//	Массив из ПеречислениеСсылка.ХозяйственныеОперации - 
//
Функция ДоступныеХозяйственныеОперации(ИмяТаблицы) Экспорт
	
	Возврат ОбщегоНазначенияУТПовтИсп.ДоступныеХозяйственныеОперации(ИмяТаблицы);
	
КонецФункции

// Возвращает значения хозяйственных операций недоступных пользователю по группе доступа для объекта информационной базы.
//
// Параметры:
//	ИмяТаблицы - Строка - полное имя объекта информационной базы, например, "РегистрСведений.РеестрДокументов".
//
// Возвращаемое значение:
//	Массив из ПеречислениеСсылка.ХозяйственныеОперации - 
//
Функция НеДоступныеХозяйственныеОперации(ИмяТаблицы)
	
	НеДоступныеХозяйственныеОперации = Новый Массив;
	ДоступныеХозяйственныеОперации   = ДоступныеХозяйственныеОперации(ИмяТаблицы);
	
	Если ДоступныеХозяйственныеОперации <> Неопределено Тогда
		Запрос = Новый Запрос;
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	НастройкиХозяйственныхОпераций.ХозяйственнаяОперация КАК ХозяйственнаяОперация
		|ИЗ
		|	Справочник.НастройкиХозяйственныхОпераций КАК НастройкиХозяйственныхОпераций
		|ГДЕ
		|	НЕ НастройкиХозяйственныхОпераций.ЭтоГруппа
		|	И НЕ НастройкиХозяйственныхОпераций.ПометкаУдаления
		|	И НастройкиХозяйственныхОпераций.ИспользоватьДляОграниченийДоступа
		|	И НЕ НастройкиХозяйственныхОпераций.ХозяйственнаяОперация В(&РазрешенныеХозяйственныеОперации)";
		
		Запрос.УстановитьПараметр("РазрешенныеХозяйственныеОперации", ДоступныеХозяйственныеОперации);
		
		РезультатЗапроса = Запрос.Выполнить();
		НеДоступныеХозяйственныеОперации = РезультатЗапроса.Выгрузить().ВыгрузитьКолонку("ХозяйственнаяОперация");
	КонецЕсли;
	
	Возврат НеДоступныеХозяйственныеОперации;
	
КонецФункции

// Заменяет источник поля Ссылка в тексте запроса динамического списка, построенного на регистре сведений Реестр документов
// подставляет конструкцию ВЫРАЗИТЬ, в которой указаны передаваемые в параметр ТипыДокументов типы документов.
// 
// Параметры:
//  ЭлементФормыСписок - ДанныеФормыКоллекция - Элемент формы, связанный с динамическим списком.
//  ТипыДокументов - ДанныеФормыКоллекция, Массив из Строка, Строка - Типы документов
//  ПсевдонимРеестраДокументов - Строка - Псевдоним таблицы регистра сведений РеестрДокументов в запросе динамического списка  
Процедура ЗаменитьПолеСсылкаКонструкциейВыразитьПоТипамДокументов(ЭлементФормыСписок, ТипыДокументов, ПсевдонимРеестраДокументов = Неопределено) Экспорт
	
	СвойстваСписка 					= ОбщегоНазначения.СтруктураСвойствДинамическогоСписка();
	Если ТипЗнч(ТипыДокументов) = Тип("ДанныеФормыКоллекция") Тогда
		ПолныеИменаДокументов 		= ИспользуемыеПолныеИменаДокументов(ТипыДокументов.Выгрузить());
	ИначеЕсли ТипЗнч(ТипыДокументов) = Тип("Строка") Тогда
		ПолныеИменаДокументов		= ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ТипыДокументов);
	Иначе
		ПолныеИменаДокументов 		= ТипыДокументов;
	КонецЕсли;
	ПолныеИменаДокументов.Добавить("Документ.Сторно");
	
	Если Не ЗначениеЗаполнено(ПсевдонимРеестраДокументов) Тогда
		ПсевдонимРеестраДокументов 		= ?(СтрНайти(СвойстваСписка.ТекстЗапроса, "КАК РеестрДокументовПереопределяемый"),
											"РеестрДокументовПереопределяемый", "РеестрДокументов");
	КонецЕсли;

	Форма 							= ЭлементФормыСписок.Родитель;
	ТипФормаКлиентскогоПриложения	= Тип("ФормаКлиентскогоПриложения");
	
	Пока ТипЗнч(Форма) <> ТипФормаКлиентскогоПриложения Цикл
		Форма = Форма.Родитель;
	КонецЦикла;
	
	ДинамическийСписок 				= Форма[ЭлементФормыСписок.ПутьКДанным];
	ЗаполнитьЗначенияСвойств(СвойстваСписка, ДинамическийСписок);
	ДополнительныеСвойства 			= ДинамическийСписок.КомпоновщикНастроек.Настройки.ДополнительныеСвойства;
	РазыменовываниеДобавлено 		= ДополнительныеСвойства.Свойство("РазыменовываниеСсылки");
	БлокЗамены 						= ?(РазыменовываниеДобавлено, 
										ДополнительныеСвойства.РазыменовываниеСсылки, ПсевдонимРеестраДокументов + ".Ссылка");
	ШаблонКонструкции 				= "ВЫБРАТЬ ВЫБОР КОГДА &ПолеСсылка ССЫЛКА ДокументСсылка.ЗаказКлиента"; // @query-part-1
	ШаблонКонструкции 				= СтрЗаменить(ШаблонКонструкции, "ВЫБРАТЬ ВЫБОР ", ""); // @Query-part-1
	РазыменовываниеВыразить 		= Новый Массив();
	
	Для каждого ТипДокументов Из ПолныеИменаДокументов Цикл
		РазыменовываниеВыразить.Добавить(СтрЗаменить(ШаблонКонструкции, "ДокументСсылка.ЗаказКлиента", ТипДокументов) + Символы.ПС
			+ " ТОГДА ВЫРАЗИТЬ(&ПолеСсылка КАК " + ТипДокументов + ") "); // @query-part-1
	КонецЦикла;
	
	ТипыДокументовРазыменовываени 	= СтрСоединить(РазыменовываниеВыразить, Символы.ПС);
	Разыменовывание 				= "(ВЫБОР " + ТипыДокументовРазыменовываени + " КОНЕЦ)"; 

	СвойстваСписка.ТекстЗапроса 	= СтрЗаменить(СвойстваСписка.ТекстЗапроса, 
										БлокЗамены + " КАК Ссылка,", 
										Разыменовывание + " КАК Ссылка,");
		
	СвойстваСписка.ТекстЗапроса 	= СтрЗаменить(СвойстваСписка.ТекстЗапроса, 
										БлокЗамены + ".* КАК Ссылка,", 
										Разыменовывание + ".* КАК Ссылка,");
	
	СвойстваСписка.ТекстЗапроса 	= СтрЗаменить(СвойстваСписка.ТекстЗапроса,
										"&ПолеСсылка", 
										ПсевдонимРеестраДокументов + ".Ссылка");
	
	ОбщегоНазначения.УстановитьСвойстваДинамическогоСписка(ЭлементФормыСписок, СвойстваСписка);
	
	ДополнительныеСвойства.Вставить("РазыменовываниеСсылки", 
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Разыменовывание, ПсевдонимРеестраДокументов));
	
КонецПроцедуры

#КонецОбласти

#Область ДобавлениеУдалениеКнопокСозданияВЖурналахДокументов

Процедура СформироватьКомандыСоздания(СтруктураПараметров) 
	
	Форма = СтруктураПараметров.Форма;
	
	СтруктураИменГрупп = Новый Структура;
	СтруктураИменГрупп.Вставить(СтруктураПараметров.ИмяГруппыСоздать, Ложь); // Ложь, т.к. группа не контекстная
	Если ЗначениеЗаполнено(СтруктураПараметров.ИмяГруппыСоздатьКонтекст) Тогда
		СтруктураИменГрупп.Вставить(СтруктураПараметров.ИмяГруппыСоздатьКонтекст, Истина); // Истина, т.к. контекстная группа
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Таблица.Порядок КАК ЧИСЛО(10, 0)) КАК Порядок,
	|	ВЫРАЗИТЬ(Таблица.ИдентификаторОбъектаМетаданных КАК Справочник.ИдентификаторыОбъектовМетаданных) КАК ИдентификаторОбъектаМетаданных,
	|	ВЫРАЗИТЬ(Таблица.ХозяйственнаяОперация КАК Перечисление.ХозяйственныеОперации) КАК ХозяйственнаяОперация,
	|	ВЫРАЗИТЬ(Таблица.ДокументПредставление КАК СТРОКА(250)) КАК ДокументПредставление,
	|	ВЫРАЗИТЬ(Таблица.ГруппаКнопок КАК СТРОКА(100)) КАК ГруппаКнопок,
	|	ВЫРАЗИТЬ(Таблица.РазместитьВПодменю КАК БУЛЕВО) КАК РазместитьВПодменю
	|ПОМЕСТИТЬ Таблица
	|ИЗ
	|	&Таблица КАК Таблица
	|ГДЕ
	|	Таблица.Отбор
	|	И Таблица.ДобавитьКнопкуСоздать
	|	И Таблица.ПравоДоступаДобавление
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.Порядок 								КАК Порядок,
	|	Таблица.ИдентификаторОбъектаМетаданных 			КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация 					КАК ХозяйственнаяОперация,
	|	ПРЕДСТАВЛЕНИЕ(Таблица.ХозяйственнаяОперация) 	КАК ХозОперацияСиноним,
	|	Таблица.ДокументПредставление 					КАК ДокументПредставление,
	|	Таблица.ГруппаКнопок 							КАК ГруппаКнопок,
	|	Таблица.РазместитьВПодменю 						КАК РазместитьВПодменю
	|ИЗ
	|	Таблица КАК Таблица";
	
	ТаблицаХозОперацийИДокументов = Форма[СтруктураПараметров.ИмяТаблицыХозяйственныхОперацийИДокументов].Выгрузить(); // ТаблицаЗначений - 
	
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("Порядок") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("Порядок",
			Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(10, 0)));
	КонецЕсли;
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("ГруппаКнопок") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("ГруппаКнопок",
			Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(100)));
	КонецЕсли;
	Если ТаблицаХозОперацийИДокументов.Колонки.Найти("РазместитьВПодменю") = Неопределено Тогда
		ТаблицаХозОперацийИДокументов.Колонки.Добавить("РазместитьВПодменю",
			Новый ОписаниеТипов("Булево"));
		ТаблицаХозОперацийИДокументов.ЗаполнитьЗначения(Истина, "РазместитьВПодменю");
	КонецЕсли;
	
	Запрос.УстановитьПараметр("Таблица", ТаблицаХозОперацийИДокументов);
	
	ТаблицаДокументов = Запрос.Выполнить().Выгрузить();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ВЫРАЗИТЬ(Таблица.ИдентификаторОбъектаМетаданных КАК Справочник.ИдентификаторыОбъектовМетаданных) КАК ИдентификаторОбъектаМетаданных,
	|	ВЫРАЗИТЬ(Таблица.ХозяйственнаяОперация КАК Перечисление.ХозяйственныеОперации) КАК ХозяйственнаяОперация,
	|	ВЫРАЗИТЬ(Таблица.ДокументПредставление КАК СТРОКА(250)) КАК ДокументПредставление,
	|	ВЫРАЗИТЬ(Таблица.ХозОперацияСиноним КАК СТРОКА(500)) КАК ХозОперацияСиноним,
	|	ВЫРАЗИТЬ(Таблица.ГруппаКнопок КАК СТРОКА(100)) КАК ГруппаКнопок,
	|	ВЫРАЗИТЬ(Таблица.РазместитьВПодменю КАК БУЛЕВО) КАК РазместитьВПодменю,
	|	ВЫРАЗИТЬ(Таблица.Порядок КАК ЧИСЛО(10, 0)) КАК Порядок
	|ПОМЕСТИТЬ Таблица
	|ИЗ
	|	&Таблица КАК Таблица
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КоличествоДокументов.ИдентификаторОбъектаМетаданных) КАК Количество
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных
	|	ИЗ
	|		Таблица КАК Таблица) КАК КоличествоДокументов
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КОЛИЧЕСТВО(КоличествоХозяйственныхОпераций.ХозяйственнаяОперация) КАК Количество
	|ИЗ
	|	(ВЫБРАТЬ РАЗЛИЧНЫЕ
	|		Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация
	|	ИЗ
	|		Таблица КАК Таблица) КАК КоличествоХозяйственныхОпераций
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	Таблица.ИдентификаторОбъектаМетаданных.Синоним КАК Синоним,
	|	ВЫБОР 
	|		КОГДА Таблица.ДокументПредставление <> """"
	|			ТОГДА Таблица.ДокументПредставление
	|		ИНАЧЕ Таблица.ИдентификаторОбъектаМетаданных.Синоним
	|	КОНЕЦ КАК ДокументПредставление,
	|	Таблица.ИдентификаторОбъектаМетаданных.Имя КАК Имя,
	|	Таблица.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмяДокумента,
	|	Таблица.ГруппаКнопок КАК ГруппаКнопок,
	|	Таблица.РазместитьВПодменю КАК РазместитьВПодменю
	|ИЗ
	|	Таблица КАК Таблица
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок,
	|	Синоним,
	|	ХозОперацияСиноним
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Таблица.ИдентификаторОбъектаМетаданных КАК ИдентификаторОбъектаМетаданных,
	|	Таблица.ХозяйственнаяОперация КАК ХозяйственнаяОперация,
	|	Таблица.Порядок КАК Порядок,
	|	Таблица.ИдентификаторОбъектаМетаданных.Синоним КАК Синоним,
	|	ВЫБОР 
	|		КОГДА Таблица.ДокументПредставление <> """"
	|			ТОГДА Таблица.ДокументПредставление
	|		ИНАЧЕ Таблица.ИдентификаторОбъектаМетаданных.Синоним
	|	КОНЕЦ КАК ДокументПредставление,
	|	Таблица.ИдентификаторОбъектаМетаданных.Имя КАК ИмяДокумента,
	|	Таблица.ИдентификаторОбъектаМетаданных.ПолноеИмя КАК ПолноеИмяДокумента,
	|	Таблица.ГруппаКнопок КАК ГруппаКнопок,
	|	Таблица.РазместитьВПодменю КАК РазместитьВПодменю
	|ИЗ
	|	Таблица КАК Таблица
	|
	|УПОРЯДОЧИТЬ ПО
	|	Порядок,
	|	Синоним,
	|	ХозОперацияСиноним
	|
	|ИТОГИ 
	|	МАКСИМУМ(Синоним),
	|	МАКСИМУМ(ДокументПредставление),
	|	МАКСИМУМ(ГруппаКнопок),
	|	МАКСИМУМ(Порядок),
	|	МАКСИМУМ(РазместитьВПодменю)
	|ПО
	|	ИдентификаторОбъектаМетаданных";
	
	Запрос.УстановитьПараметр("Таблица", ТаблицаДокументов);
	МассивРезультатов = Запрос.ВыполнитьПакет();
	
	КоличествоДокументов = 0;
	ВыборкаКоличествоДокументов = МассивРезультатов[1].Выбрать();
	Если ВыборкаКоличествоДокументов.Следующий() Тогда 
		КоличествоДокументов = ВыборкаКоличествоДокументов.Количество;
	КонецЕсли;
	
	КоличествоХозОпераций = 0;
	ВыборкаКоличествоХозОпераций = МассивРезультатов[2].Выбрать();
	Если ВыборкаКоличествоХозОпераций.Следующий() Тогда 
		КоличествоХозОпераций = ВыборкаКоличествоХозОпераций.Количество;
	КонецЕсли;
	
	Для Каждого ИмяКонтекстГруппы Из СтруктураИменГрупп Цикл
		
		ИмяГруппыСоздать 			= ИмяКонтекстГруппы.Ключ;
		ДобавлениеВКонтекстноеМеню 	= ИмяКонтекстГруппы.Значение;
		
		Префикс = СтруктураПараметров.ПрефиксЭлементов + ?(ДобавлениеВКонтекстноеМеню, "Контекст", "");
		
		ГруппаСоздать = Форма.Элементы[ИмяГруппыСоздать];
	
		УдалитьКомандыСоздания(Форма, ГруппаСоздать, ИмяГруппыСоздать);
		
		СоответствиеГруппКоманды = Новый Соответствие;
		СоответствиеГруппКоманды.Вставить("", ГруппаСоздать);
		
		Если КоличествоДокументов = 1 И КоличествоХозОпераций = 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Если Выборка.Следующий() Тогда   
				МестоРазмещенияКнопки = МестоРазмещенияКнопки("", Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, НСтр("ru = 'Создать'"), Выборка, Префикс, ГруппаСоздать.ПодчиненныеЭлементы.Количество() = 0);
			КонецЕсли;
					
		ИначеЕсли КоличествоДокументов = 1 И КоличествоХозОпераций > 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Пока Выборка.Следующий() Цикл
				МестоРазмещенияКнопки = МестоРазмещенияКнопки(Выборка.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, Выборка.ХозяйственнаяОперация, Выборка, Префикс);			
			КонецЦикла;
			
		ИначеЕсли КоличествоДокументов <= СтруктураПараметров.МаксимальноеКоличествоКомандВПодменю
		 	И КоличествоХозОпераций = 1 Тогда
			
			Выборка = МассивРезультатов[3].Выбрать();
			Пока Выборка.Следующий() Цикл
				МестоРазмещенияКнопки = МестоРазмещенияКнопки(Выборка.ГруппаКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды);
				ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, МестоРазмещенияКнопки, Выборка.ДокументПредставление, Выборка, Префикс);
			КонецЦикла;
			
		ИначеЕсли КоличествоДокументов <= СтруктураПараметров.МаксимальноеКоличествоКомандВПодменю
		 	И КоличествоХозОпераций > 1 Тогда
			
			Дерево = МассивРезультатов[4].Выгрузить(ОбходРезультатаЗапроса.ПоГруппировкамСИерархией);
			
			Для Каждого СтрокаДокумент Из Дерево.Строки Цикл
				
				Если СтрокаДокумент.Строки.Количество() = 1 Тогда
					
					МестоРазмещенияКнопки = МестоРазмещенияКнопки(
						СтрокаДокумент.ГруппаКнопок, 
						Форма, 
						ИмяГруппыСоздать, 
						Префикс, 
						СоответствиеГруппКоманды);
					
					ДобавитьКомандуСКнопкой(
						Форма, 
						ИмяГруппыСоздать, 
						МестоРазмещенияКнопки, 
						СтрокаДокумент.ДокументПредставление, 
						СтрокаДокумент.Строки[0], 
						Префикс);
					
				Иначе
					
					Если СтрокаДокумент.РазместитьВПодменю Тогда
						
						МестоРазмещенияКнопки = ДобавитьГруппуКнопок(
							Форма, 
							ИмяГруппыСоздать, 
							СтрокаДокумент.ИмяДокумента, 
							СтрокаДокумент.ДокументПредставление, 
							Префикс);
					Иначе
						
						МестоРазмещенияКнопки = МестоРазмещенияКнопки(
							СтрокаДокумент.ГруппаКнопок, 
							Форма, 
							ИмяГруппыСоздать, 
							Префикс, 
							СоответствиеГруппКоманды);
							
					КонецЕсли;
					
					Для Каждого Строка Из СтрокаДокумент.Строки Цикл
						
						ДобавитьКомандуСКнопкой(
							Форма, 
							ИмяГруппыСоздать, 
							МестоРазмещенияКнопки, 
							?(Строка.РазместитьВПодменю, Строка.ХозяйственнаяОперация, Строка.ДокументПредставление), 
							Строка, 
							Префикс);
							
					КонецЦикла;
					
				КонецЕсли;
				
			КонецЦикла;
			
		ИначеЕсли Форма.ОтборТипыДокументов.Количество() > СтруктураПараметров.МаксимальноеКоличествоКомандВПодменю Тогда
			
			ДобавитьКомандуСКнопкойДляОткрытияФормыВыбора(Форма, ИмяГруппыСоздать, Префикс);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, ИмяНовойГруппы, ЗаголовокНовойГруппы, Префикс)
	
	Элемент = Форма.Элементы.Добавить(Префикс + "Группа" + "Создать_" + СокрЛП(ИмяНовойГруппы), Тип("ГруппаФормы"), Форма.Элементы[ИмяГруппыСоздать]);
	Элемент.Заголовок = СокрЛП(ЗаголовокНовойГруппы);
	Возврат Элемент;
	
КонецФункции

Функция ДобавитьКомандуСКнопкой(Форма, ИмяГруппыСоздать, Родитель, ЗаголовокКнопки, ТекущаяСтрокаТаблицы, Префикс, ОднаКнопка = Ложь)
	
	МетаданныеДокумента = Метаданные.НайтиПоПолномуИмени(ТекущаяСтрокаТаблицы.ПолноеИмяДокумента);
	
	ИмяЗначенияПеречисления = XMLСтрока(ТекущаяСтрокаТаблицы.ХозяйственнаяОперация);
	ИмяМетаданныхДокумента = МетаданныеДокумента.Имя;
	
	Если ОднаКнопка Тогда
		Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.ГруппаКнопок;
	Иначе
		Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.Подменю;
		Форма.Элементы[ИмяГруппыСоздать].Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	КонецЕсли;
	
	ИмяКоманды = Префикс + "Создать___" + ИмяЗначенияПеречисления + "___" + ИмяМетаданныхДокумента;
	Команда = Форма.Команды.Добавить(ИмяКоманды);
	Команда.Действие = "Подключаемый_СоздатьДокумент";
	Команда.Заголовок = СокрЛП(ЗаголовокКнопки);
	Если ОднаКнопка Тогда 
		Команда.Отображение = ОтображениеКнопки.КартинкаИТекст;
		Команда.Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	КонецЕсли;
	
	Элемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), Родитель);
	Элемент.ИмяКоманды = ИмяКоманды;
	Возврат Элемент;
	
КонецФункции

Функция ДобавитьКомандуСКнопкойДляОткрытияФормыВыбора(Форма, ИмяГруппыСоздать, Префикс)
	
	Форма.Элементы[ИмяГруппыСоздать].Вид = ВидГруппыФормы.ГруппаКнопок;
	
	ИмяКоманды = Префикс + "Создать_" + "ДокументЧерезФормуВыбора";
	Команда = Форма.Команды.Добавить(ИмяКоманды);
	Команда.Действие = "Подключаемый_СоздатьДокументЧерезФормуВыбора";
	Команда.Заголовок = НСтр("ru = 'Создать...'");
	Команда.Отображение = ОтображениеКнопки.КартинкаИТекст;
	Команда.Картинка = БиблиотекаКартинок.СоздатьЭлементСписка;
	
	Элемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), Форма.Элементы[ИмяГруппыСоздать]);
	Элемент.ИмяКоманды = ИмяКоманды;
	Возврат Элемент;
	
КонецФункции

Процедура УдалитьКомандыСоздания(Форма, Родитель, ИмяГруппыСоздать)
	
	// Если родитель - не корневая группа и он не создан программно, то удалять ничего не нужно.
	Если Родитель <> Форма.Элементы[ИмяГруппыСоздать] 
		И СтрНайти(Родитель.Имя, "Создать_") = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Родитель) = Тип("ГруппаФормы") Тогда 
		
		Количество = Родитель.ПодчиненныеЭлементы.Количество();
		
		Для Индекс = 1 По Количество Цикл
			УдалитьКомандыСоздания(Форма, Родитель.ПодчиненныеЭлементы.Получить(0), ИмяГруппыСоздать);
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Родитель) = Тип("КнопкаФормы") Тогда 
		Форма.Команды.Удалить(Форма.Команды.Найти(Родитель.Имя));
	КонецЕсли;
	
	Если СтрНайти(Родитель.Имя, "Создать_") <> 0 Тогда 
		Форма.Элементы.Удалить(Родитель);
	КонецЕсли;
	
КонецПроцедуры

Функция МестоРазмещенияКнопки(ИмяГруппыКнопок, Форма, ИмяГруппыСоздать, Префикс, СоответствиеГруппКоманды)
	
	ГруппаКнопок = СоответствиеГруппКоманды.Получить(СокрЛП(ИмяГруппыКнопок));
	Если ГруппаКнопок = Неопределено Тогда
		ГруппаКнопок = ДобавитьГруппуКнопок(Форма, ИмяГруппыСоздать, ИмяГруппыКнопок, ИмяГруппыСоздать, Префикс);	
		ГруппаКнопок.Вид = ВидГруппыФормы.ГруппаКнопок;
		СоответствиеГруппКоманды.Вставить(СокрЛП(ИмяГруппыКнопок), ГруппаКнопок);
	КонецЕсли;
	
	Возврат ГруппаКнопок;
	
КонецФункции

#КонецОбласти

#Область ПоискВТаблице

Функция УпорядочитьПронумерованныеСтроки(Таблица, МассивСтрок)
	
	СтрокиУпорядочены = МассивПронумерованныхСтрокУпорядочен(МассивСтрок);
	
	Если СтрокиУпорядочены Тогда
		
		Результат = МассивСтрок;
		
	Иначе
		
		ТаблицаСортировки = Новый ТаблицаЗначений;
		ТаблицаСортировки.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
		ТаблицаСортировки.Колонки.Добавить("ПорядковыйНомер", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		
		Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
			
			Строка = МассивСтрок[Индекс];
			
			НоваяСтрока = ТаблицаСортировки.Добавить();
			НоваяСтрока.Строка = Строка;
			НоваяСтрока.ПорядковыйНомер = Строка.ПорядковыйНомер;
			
		КонецЦикла;
		
		ТаблицаСортировки.Сортировать("ПорядковыйНомер ВОЗР");
		
		Результат = Новый Массив;
		Для Индекс = 0 По ТаблицаСортировки.Количество()-1 Цикл
			
			Результат.Добавить(ТаблицаСортировки[Индекс].Строка);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция МассивПронумерованныхСтрокУпорядочен(МассивСтрок)
	
	Результат = Истина;
	
	МаксИндекс = МассивСтрок.ВГраница();
	
	ПредыдущаяСтрока = МассивСтрок[МаксИндекс];
	Для Сч = 1 По МаксИндекс Цикл
		
		ТекущаяСтрока = МассивСтрок[МаксИндекс-сч];
		Если ТекущаяСтрока.ПорядковыйНомер > ПредыдущаяСтрока.ПорядковыйНомер Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
		ПредыдущаяСтрока = ТекущаяСтрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция УпорядочитьНеПронумерованныеСтроки(Таблица, МассивСтрок)
	
	ТаблицаИндексов = ИндексыНеПронумерованныхСтрок(Таблица, МассивСтрок);
	СтрокиУпорядочены = ТаблицаИндексовУпорядочена(ТаблицаИндексов);
	
	Если СтрокиУпорядочены Тогда
		
		Результат = МассивСтрок;
		
	Иначе
		
		ТаблицаИндексов.Сортировать("ИндексТаблицы ВОЗР");
		
		Результат = Новый Массив;
		Для Индекс = 0 По ТаблицаИндексов.Количество()-1 Цикл
			
			Результат.Добавить(ТаблицаИндексов[Индекс].Строка);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИндексыНеПронумерованныхСтрок(Таблица, МассивСтрок)
	
	Результат = Новый ТаблицаЗначений;
	Результат.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Результат.Колонки.Добавить("ИндексТаблицы", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	Для Индекс = 0 По МассивСтрок.ВГраница() Цикл
		
		Строка = МассивСтрок[Индекс];
		
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Строка = Строка;
		НоваяСтрока.ИндексТаблицы = Таблица.Индекс(Строка);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ТаблицаИндексовУпорядочена(ТаблицаИндексов)
	
	Результат = Истина;
	
	ПредыдущаяСтрока = ТаблицаИндексов[0];
	Для Индекс = 1 По ТаблицаИндексов.Количество()-1 Цикл
		
		ТекущаяСтрока = ТаблицаИндексов[Индекс];
		Если ТекущаяСтрока.ИндексТаблицы < ПредыдущаяСтрока.ИндексТаблицы Тогда
			Результат = Ложь;
			Прервать;
		КонецЕсли;
		
		ПредыдущаяСтрока = ТекущаяСтрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область КопированиеЭлементовФормы

Функция КопируемыеСвойстваЭлементовФормы()
	
	Результат = Новый Соответствие;
	
	СвойстваПоляФормы = Новый Массив;
	СвойстваПоляФормы.Добавить("Вид");
	СвойстваПоляФормы.Добавить("ВидФлажка");
	СвойстваПоляФормы.Добавить("Заголовок");
	СвойстваПоляФормы.Добавить("ПоложениеЗаголовка");
	СвойстваПоляФормы.Добавить("АвтоМаксимальнаяВысота");
	СвойстваПоляФормы.Добавить("АвтоМаксимальнаяШирина");
	СвойстваПоляФормы.Добавить("АвтоОтметкаНезаполненного");
	СвойстваПоляФормы.Добавить("ВертикальноеПоложение");
	СвойстваПоляФормы.Добавить("ВертикальноеПоложениеВГруппе");
	СвойстваПоляФормы.Добавить("Видимость");
	СвойстваПоляФормы.Добавить("ВыбиратьТип");
	СвойстваПоляФормы.Добавить("ВыборГруппИЭлементов");
	СвойстваПоляФормы.Добавить("ВыделятьОтрицательные");
	СвойстваПоляФормы.Добавить("Высота");
	СвойстваПоляФормы.Добавить("ВысотаЗаголовка");
	СвойстваПоляФормы.Добавить("ВысотаСпискаВыбора");
	СвойстваПоляФормы.Добавить("ГиперссылкаЯчейки");
	СвойстваПоляФормы.Добавить("ГоризонтальноеПоложение");
	СвойстваПоляФормы.Добавить("ГоризонтальноеПоложениеВГруппе");
	СвойстваПоляФормы.Добавить("ГоризонтальноеПоложениеВПодвале");
	СвойстваПоляФормы.Добавить("ГоризонтальноеПоложениеВШапке");
	СвойстваПоляФормы.Добавить("ВертикальноеПоложение");
	СвойстваПоляФормы.Добавить("ВертикальноеПоложениеВГруппе");
	СвойстваПоляФормы.Добавить("РастягиватьПоВертикали");
	СвойстваПоляФормы.Добавить("Доступность");
	СвойстваПоляФормы.Добавить("МногострочныйРежим");
	СвойстваПоляФормы.Добавить("АвтоПереносСтрок");
	СвойстваПоляФормы.Добавить("ТолькоПросмотр");
	СвойстваПоляФормы.Добавить("Ширина");
	СвойстваПоляФормы.Добавить("Шрифт");
	СвойстваПоляФормы.Добавить("ШрифтЗаголовка");
	СвойстваПоляФормы.Добавить("ШрифтПодвала");
	СвойстваПоляФормы.Добавить("Ширина");
	СвойстваПоляФормы.Добавить("ШрифтЗаголовка");
	СвойстваПоляФормы.Добавить("ШрифтПодвала");
	СвойстваПоляФормы.Добавить("ОтображатьВПодвале");
	СвойстваПоляФормы.Добавить("ОтображатьВШапке");
	СвойстваПоляФормы.Добавить("ПутьКДанным");
	СвойстваПоляФормы.Добавить("ПутьКДаннымПодвала");
	СвойстваПоляФормы.Добавить("ПараметрыВыбора");
	СвойстваПоляФормы.Добавить("СвязиПараметровВыбора");
	СвойстваПоляФормы.Добавить("АвтоМаксимальнаяВысота");
	СвойстваПоляФормы.Добавить("МаксимальнаяШирина");
	СвойстваПоляФормы.Добавить("АвтоМаксимальнаяШирина");
	СвойстваПоляФормы.Добавить("МаксимальнаяВысота");
	Результат.Вставить(Тип("ПолеФормы"), СвойстваПоляФормы);
	
	СвойстваГруппыФормы = Новый Массив();
	СвойстваГруппыФормы.Добавить("Вид");
	СвойстваГруппыФормы.Добавить("Заголовок");
	СвойстваГруппыФормы.Добавить("ПутьКДаннымЗаголовка");
	СвойстваГруппыФормы.Добавить("ОтображатьЗаголовок");
	СвойстваГруппыФормы.Добавить("Видимость");
	СвойстваГруппыФормы.Добавить("Доступность");
	СвойстваГруппыФормы.Добавить("ТолькоПросмотр");
	СвойстваГруппыФормы.Добавить("Объединенная");
	СвойстваГруппыФормы.Добавить("Поведение");
	СвойстваГруппыФормы.Добавить("Отображение");
	СвойстваГруппыФормы.Добавить("СквозноеВыравнивание");
	СвойстваГруппыФормы.Добавить("Группировка");
	СвойстваГруппыФормы.Добавить("ОтображатьВШапке");
	СвойстваГруппыФормы.Добавить("ГоризонтальноеПоложениеВГруппе");
	СвойстваГруппыФормы.Добавить("ГоризонтальноеПоложениеВШапке");
	СвойстваГруппыФормы.Добавить("Ширина");
	СвойстваГруппыФормы.Добавить("Высота");
	СвойстваГруппыФормы.Добавить("РастягиватьПоВертикали");
	СвойстваГруппыФормы.Добавить("РастягиватьПоГоризонтали");
	СвойстваГруппыФормы.Добавить("ВыравниваниеЭлементовИЗаголовков");
	СвойстваГруппыФормы.Добавить("Картинка");
	СвойстваГруппыФормы.Добавить("ИсточникКоманд");
	Результат.Вставить(Тип("ГруппаФормы"), СвойстваГруппыФормы);
	
	СвойстваТаблицаФормы = Новый Массив();
	СвойстваТаблицаФормы.Добавить("Заголовок");
	СвойстваТаблицаФормы.Добавить("ПутьКДанным");
	СвойстваТаблицаФормы.Добавить("ПоложениеЗаголовка");
	СвойстваТаблицаФормы.Добавить("Видимость");
	СвойстваТаблицаФормы.Добавить("Доступность");
	СвойстваТаблицаФормы.Добавить("ТолькоПросмотр");
	СвойстваТаблицаФормы.Добавить("АктивизироватьПоУмолчанию");
	СвойстваТаблицаФормы.Добавить("РежимВыбора");
	СвойстваТаблицаФормы.Добавить("МножественныйВыбор");
	СвойстваТаблицаФормы.Добавить("ИзменятьСоставСтрок");
	СвойстваТаблицаФормы.Добавить("ИзменятьПорядокСтрок");
	СвойстваТаблицаФормы.Добавить("Шапка");
	СвойстваТаблицаФормы.Добавить("Подвал");
	СвойстваТаблицаФормы.Добавить("ПутьКДаннымКартинкиСтроки");
	СвойстваТаблицаФормы.Добавить("КартинкаСтрок");
	СвойстваТаблицаФормы.Добавить("Ширина");
	СвойстваТаблицаФормы.Добавить("Высота");
	СвойстваТаблицаФормы.Добавить("АвтоМаксимальнаяВысота");
	СвойстваТаблицаФормы.Добавить("МаксимальнаяШирина");
	СвойстваТаблицаФормы.Добавить("АвтоМаксимальнаяШирина");
	СвойстваТаблицаФормы.Добавить("МаксимальнаяВысота");
	СвойстваТаблицаФормы.Добавить("РастягиватьПоГоризонтали");
	СвойстваТаблицаФормы.Добавить("РастягиватьПоВертикали");
	Результат.Вставить(Тип("ТаблицаФормы"), СвойстваТаблицаФормы);
	
	СвойстваКомандыФормы = Новый Массив();
	СвойстваКомандыФормы.Добавить("Вид");
	СвойстваКомандыФормы.Добавить("Заголовок");
	СвойстваКомандыФормы.Добавить("Видимость");
	СвойстваКомандыФормы.Добавить("Доступность");
	СвойстваКомандыФормы.Добавить("ТолькоВоВсехДействиях");
	СвойстваКомандыФормы.Добавить("Отображение");
	СвойстваКомандыФормы.Добавить("КнопкаПоУмолчанию");
	СвойстваКомандыФормы.Добавить("АктивизироватьПоУмолчанию");
	СвойстваКомандыФормы.Добавить("Пометка");
	СвойстваКомандыФормы.Добавить("Ширина");
	СвойстваКомандыФормы.Добавить("Высота");
	СвойстваКомандыФормы.Добавить("АвтоМаксимальнаяВысота");
	СвойстваКомандыФормы.Добавить("МаксимальнаяШирина");
	СвойстваКомандыФормы.Добавить("АвтоМаксимальнаяШирина");
	СвойстваКомандыФормы.Добавить("МаксимальнаяВысота");
	СвойстваКомандыФормы.Добавить("ГоризонтальноеПоложениеВГруппе");
	СвойстваКомандыФормы.Добавить("ВертикальноеПоложениеВГруппе");
	СвойстваКомандыФормы.Добавить("РастягиватьПоГоризонтали");
	СвойстваКомандыФормы.Добавить("РастягиватьПоВертикали");
	СвойстваКомандыФормы.Добавить("ИмяКоманды");
	СвойстваКомандыФормы.Добавить("КоманднаяПанель");
	Результат.Вставить(Тип("КнопкаФормы"), СвойстваКомандыФормы);
	
	Возврат Результат;
	
КонецФункции

Функция КопируемыеОбработчикиЭлементовФормы()
	
	Результат = Новый Соответствие;
	
	СвойстваПоляФормы = Новый Массив;
	СвойстваПоляФормы.Добавить("ПриИзменении");
	СвойстваПоляФормы.Добавить("НачалоВыбораИзСписка");
	СвойстваПоляФормы.Добавить("Очистка");
	СвойстваПоляФормы.Добавить("Регулирование");
	СвойстваПоляФормы.Добавить("Открытие");
	СвойстваПоляФормы.Добавить("ОбработкаВыбора");
	СвойстваПоляФормы.Добавить("АвтоПодбор");
	СвойстваПоляФормы.Добавить("ОкончаниеВводаТекста");
	СвойстваПоляФормы.Добавить("НачалоВыбора");
	СвойстваПоляФормы.Добавить("ИзменениеТекстаРедактирования");
	СвойстваПоляФормы.Добавить("Создание");
	Результат.Вставить(Тип("ПолеФормы"), СвойстваПоляФормы);
	
	СвойстваГруппыФормы = Новый Массив();
	СвойстваГруппыФормы.Добавить("ПриСменеСтраницы");
	Результат.Вставить(Тип("ГруппаФормы"), СвойстваГруппыФормы);
	
	СвойстваТаблицаФормы = Новый Массив();
	СвойстваТаблицаФормы.Добавить("Выбор");
	СвойстваТаблицаФормы.Добавить("ВыборЗначения");
	СвойстваТаблицаФормы.Добавить("ПриАктивизацииСтроки");
	СвойстваТаблицаФормы.Добавить("ПриАктивизацииПоля");
	СвойстваТаблицаФормы.Добавить("ПриАктивизацииЯчейки");
	СвойстваТаблицаФормы.Добавить("ПередНачаломДобавления");
	СвойстваТаблицаФормы.Добавить("ПередНачаломИзменения");
	СвойстваТаблицаФормы.Добавить("ПередУдалением");
	СвойстваТаблицаФормы.Добавить("ПриНачалеРедактирования");
	СвойстваТаблицаФормы.Добавить("ПередОкончаниемРедактирования");
	СвойстваТаблицаФормы.Добавить("ПриОкончанииРедактирования");
	СвойстваТаблицаФормы.Добавить("ОбработкаВыбора");
	СвойстваТаблицаФормы.Добавить("ПередРазворачиванием");
	СвойстваТаблицаФормы.Добавить("ПередСворачиванием");
	СвойстваТаблицаФормы.Добавить("ПослеУдаления");
	СвойстваТаблицаФормы.Добавить("ПриСменеТекущегоРодителя");
	СвойстваТаблицаФормы.Добавить("ПриИзменении");
	СвойстваТаблицаФормы.Добавить("ОбработкаЗаписиНового");
	СвойстваТаблицаФормы.Добавить("НачалоПеретаскивания");
	СвойстваТаблицаФормы.Добавить("ПроверкаПеретаскивания");
	СвойстваТаблицаФормы.Добавить("ОкончаниеПеретаскивания");
	СвойстваТаблицаФормы.Добавить("Перетаскивание");
	Результат.Вставить(Тип("ТаблицаФормы"), СвойстваТаблицаФормы);
	
	СвойстваКомандыФормы = Новый Массив();
	Результат.Вставить(Тип("КнопкаФормы"), СвойстваКомандыФормы);
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти
