#Область ПрограммныйИнтерфейс

// Включает логирование запросов в текущем сейнсе на время ЗаписыватьСекунд.
// 
// Параметры:
// 	ПараметрыЛогирования - см. НовыеПараметрыЛогированияЗапросов.
// 	ЗаписыватьСекунд - Неопределено, Число - Количество секунд, после которых прекратится запись логов запросов.
// 	НовыйЛог         - Булево              - Добавляет новый слой логирования. Используется для вложенного логирования
// 	                                         Возвращаются параметры логирования с текущим значением идентификатора логов.
// Возвращаемое значение:
// 	см. НовыеПараметрыЛогированияЗапросов.
Функция ВключитьЛогированиеЗапросов(ПараметрыЛогирования, ЗаписыватьСекунд = Неопределено, НовыйЛог = Ложь) Экспорт
	
	Если Не ЗначениеЗаполнено(ПараметрыЛогирования.ТекущийИдентификатор) Тогда
		УстановитьНовыйЛог(ПараметрыЛогирования);
	КонецЕсли;
	
	Если НовыйЛог Тогда
		ПараметрыСтека                      = НовыеПараметрыЛогированияЗапросов();
		ПараметрыСтека.ТекущийИдентификатор = ПараметрыЛогирования.ТекущийИдентификатор;
		ПараметрыСтека.Включено             = ПараметрыЛогирования.Включено;
		ПараметрыСтека.ОкончаниеЗаписи      = ПараметрыЛогирования.ОкончаниеЗаписи;
		ПараметрыЛогирования.СтекПараметров.Добавить(ПараметрыСтека);
		УстановитьНовыйЛог(ПараметрыЛогирования);
	КонецЕсли;
	
	ПараметрыЛогирования.Включено = Истина;
	
	Если ЗаписыватьСекунд <> Неопределено Тогда
		Если ЗаписыватьСекунд > 0 Тогда
			ПараметрыЛогирования.ОкончаниеЗаписи = ТекущаяУниверсальнаяДатаВМиллисекундах() + (ЗаписыватьСекунд * 1000);
		Иначе
			ПараметрыЛогирования.ОкончаниеЗаписи = 0
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПараметрыЛогирования;
	
КонецФункции

// Очищает файл лога основного слоя.
// 
// Параметры:
// 	ПараметрыЛогирования - см. НовыеПараметрыЛогированияЗапросов.
Процедура ОчиститьЛогЗапросов(ПараметрыЛогирования) Экспорт
	
	ИмяФайлаЛога  = ПараметрыЛогирования.ФайлыЛогирования.Получить(ПараметрыЛогирования.ТекущийИдентификатор);
	
	Если ИмяФайлаЛога <> Неопределено Тогда
		Файл = Новый Файл(ИмяФайлаЛога);
		Если Файл.Существует() Тогда
			УдалитьФайлы(ИмяФайлаЛога);
		КонецЕсли;
	КонецЕсли;
	
	Если Не ПараметрыЛогирования.Включено Тогда
		ПараметрыЛогирования.ОкончаниеЗаписи = Неопределено;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Получает текущие параметры логирования.
// 
// Параметры:
//  ИмяПараметраСеанса - Строка - Имя параметра сеанса для хранения параметров
// Возвращаемое значение:
// 	см. НовыеПараметрыЛогированияЗапросов
Функция ПараметрыЛогированияЗапросов(ИмяПараметраСеанса) Экспорт
	
	//@skip-check constructor-function-return-section
	Возврат ОбщегоНазначения.СкопироватьРекурсивно(ПараметрыСеанса[ИмяПараметраСеанса], Ложь);
	
КонецФункции

// Создает новую структуру данных для передачи в метод см. Вывести.
// 
// Возвращаемое значение:
// 	Структура - Описание:
// * HTTPЗапросОтвет           - Неопределено, HTTPЗапрос, HTTPОтвет - Запрос или ответ.
// * АдресРесурса              - Неопределено, Структура             - Параметры отправки запроса.
// * HTTPМетод                 - Строка, Неопределено                - HTTP-метод отправки запроса.
// * Штрихкод                  - Строка, Неопределено                - Сканируемый штрихкод
// * РезультатРазбораШтрихКода - Структура, Неопределено             - Структура разбора запроса, см. ШтрихкодированиеОбщегоНазначенияИС.ОбработатьШтрихкоды()
// * ТекстОшибки               - Строка, Неопределено                - Текст ошибки отправки запроса.
Функция НоваяСтруктураДанныхЗаписи() Экспорт
	
	ПараметрыЗаписиЛога = Новый Структура();
	ПараметрыЗаписиЛога.Вставить("HTTPЗапросОтвет",           Неопределено);
	ПараметрыЗаписиЛога.Вставить("АдресРесурса",              Неопределено);
	ПараметрыЗаписиЛога.Вставить("HTTPМетод",                 Неопределено);
	ПараметрыЗаписиЛога.Вставить("Штрихкод",                  Неопределено);
	ПараметрыЗаписиЛога.Вставить("РезультатРазбораШтрихКода", Неопределено);
	ПараметрыЗаписиЛога.Вставить("ТекстОшибки",               Неопределено);
	
	Возврат ПараметрыЗаписиЛога;
	
КонецФункции

// Выполняет запись HTTP запроса / ответа в файл логирования, если запись лога включена.
// 
// Параметры:
// 	ДанныеЗаписи - см. НоваяСтруктураДанныхЗаписи.
// ПараметрыЛогирования - см. ПараметрыЛогированияЗапросов
Процедура Вывести(ДанныеЗаписи, ПараметрыЛогирования) Экспорт
	
	HTTPЗапросОтвет           = ДанныеЗаписи.HTTPЗапросОтвет;
	АдресРесурса              = ДанныеЗаписи.АдресРесурса;
	Штрихкод                  = ДанныеЗаписи.Штрихкод;
	РезультатРазбораШтрихКода = ДанныеЗаписи.РезультатРазбораШтрихКода;
	ТекстОшибки               = ДанныеЗаписи.ТекстОшибки;
	
	Если Не ВыполняетсяЛогированиеЗапросов(ПараметрыЛогирования) Тогда
		Возврат;
	КонецЕсли;
	
	ИмяФайла = ПараметрыЛогирования.ФайлыЛогирования.Получить(ПараметрыЛогирования.ТекущийИдентификатор);
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, КодировкаТекста.UTF8,, Истина);
	
	НастройкиСериализации                        = Новый НастройкиСериализацииJSON();
	НастройкиСериализации.ВариантЗаписиДаты      = ВариантЗаписиДатыJSON.ЛокальнаяДата;
	НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.ISO;
	
	Если HTTPЗапросОтвет <> Неопределено Тогда
		
		Если ТипЗнч(HTTPЗапросОтвет) = Тип("HTTPЗапрос") Тогда
			ЗаписьТекста.ЗаписатьСтроку("");
			ЗаписьТекста.ЗаписатьСтроку(АдресРесурса);
		ИначеЕсли ТипЗнч(HTTPЗапросОтвет) = Тип("HTTPОтвет") Тогда
			ЗаписьТекста.ЗаписатьСтроку("");
			ЗаписьТекста.ЗаписатьСтроку(СтрШаблон("Код состояния: %1", HTTPЗапросОтвет.КодСостояния));
		ИначеЕсли ТипЗнч(HTTPЗапросОтвет) = Тип("Структура") Тогда
			ЗаписьТекста.ЗаписатьСтроку("");
			ЗаписьТекста.ЗаписатьСтроку(НСтр("ru = 'Запрос проксирован через сервис интернет-поддержки'"));
		КонецЕсли;
		
		Для Каждого КлючИЗначение Из HTTPЗапросОтвет.Заголовки Цикл			
			ЗначениеЗаголовка = КлючИЗначение.Значение;
			ЗаписьТекста.ЗаписатьСтроку(СтрШаблон("%1: %2", КлючИЗначение.Ключ, ЗначениеЗаголовка));
		КонецЦикла;
		
		Если ТипЗнч(HTTPЗапросОтвет) = Тип("Структура") Тогда
			Тело = HTTPЗапросОтвет.Тело;
		Иначе
			Тело = HTTPЗапросОтвет.ПолучитьТелоКакСтроку();
			Если СтрНачинаетсяС(Тело, "<soap:Envelope") Тогда
				Тело = СтрЗаменить(Тело, Символы.ПС, "");
			КонецЕсли;
		КонецЕсли;
		
		Если Не ПустаяСтрока(Тело) Тогда
			ЗаписьТекста.ЗаписатьСтроку(Тело);
		КонецЕсли;

	ИначеЕсли Штрихкод <> Неопределено Тогда

		ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(Штрихкод);

		ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет);
		ЗаписьJSON = Новый ЗаписьJSON();
	
		ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписи);
		ЗаписатьJSON(ЗаписьJSON, Штрихкод, НастройкиСериализации, "ПреобразоватьВФорматДляЗаписиJSON", ЛогированиеЗапросовИС);

		СтрокаJSON = ЗаписьJSON.Закрыть();
	
		ЗаписьТекста.ЗаписатьСтроку("");
		ЗаписьТекста.ЗаписатьСтроку(НСтр("ru = 'Входящие данные с торгового оборудования:'"));
		ЗаписьТекста.ЗаписатьСтроку(СтрокаJSON);

	ИначеЕсли РезультатРазбораШтрихКода <> Неопределено Тогда

		ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(РезультатРазбораШтрихКода);

		ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет);
		ЗаписьJSON = Новый ЗаписьJSON();

		ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписи);
		ЗаписатьJSON(ЗаписьJSON, РезультатРазбораШтрихКода, НастройкиСериализации, "ПреобразоватьВФорматДляЗаписиJSON", ЛогированиеЗапросовИС);

		СтрокаJSON = ЗаписьJSON.Закрыть();

		ЗаписьТекста.ЗаписатьСтроку("");
		ЗаписьТекста.ЗаписатьСтроку(НСтр("ru = 'Результаты разбора штрихкодов:'") + Символы.ПС);
		ЗаписьТекста.ЗаписатьСтроку(СтрокаJSON);

	ИначеЕсли ЗначениеЗаполнено(ТекстОшибки) Тогда
		ЗаписьТекста.ЗаписатьСтроку(ТекстОшибки);
	КонецЕсли;

	ЗаписьТекста.Закрыть();

КонецПроцедуры

// Функция преобразовывает значение свойства в сериализуемое значение JSON
// 
// Параметры:
//  Свойство - Строка - Имя свойства
//  Значение - Произвольный - Исходное значение для преобразования
//  ДополнительныеПараметры - Структура - дополнительные параметры, которые указаны в вызове метода 
//  Отказ - Булево - отказ от записи свойства
// 
// Возвращаемое значение:
// 	Неопределено, Строка, Массив из Произвольный - результат преобразования
Функция ПреобразоватьВФорматДляЗаписиJSON(Свойство, Значение, ДополнительныеПараметры, Отказ) Экспорт
	
	Если Отказ Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоСсылка(ТипЗнч(Значение))
		ИЛИ СтроковыеФункцииКлиентСервер.ЭтоУникальныйИдентификатор(Значение)
		Или ТипЗнч(Значение) = Тип("ДвоичныеДанные") Тогда
		Возврат XMLСтрока(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("ТаблицаЗначений") Тогда
		МассивСтруктур = ОбщегоНазначения.ТаблицаЗначенийВМассив(Значение);
		Возврат МассивСтруктур;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("ДеревоЗначений") Тогда
		Возврат ПреобразоватьДеревоЗначенийВМассивСтруктур(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("СтрокаТаблицыЗначений") Тогда
		СтруктураДанных = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(Значение);
		Возврат СтруктураДанных;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("СтрокаДереваЗначений") Тогда
		СтруктураДанных = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(Значение);
		Возврат СтруктураДанных;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("ФорматированнаяСтрока") Тогда
		СтруктураДанных = Строка(Значение);
		Возврат СтруктураДанных;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Тип") Или ТипЗнч(Значение) = Тип("Null") Тогда
		Возврат Строка(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("ДанныеФормыКоллекция") Или ТипЗнч(Значение) = Тип("Картинка") Или ТипЗнч(Значение) = Тип("ОписаниеТипов") Тогда
		Возврат "";
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
		Возврат ЗначениеВСтрокуВнутр(Значение);
	КонецЕсли;
	
КонецФункции

// Выполняет установку параметров сеанса. Вызывается из модуля сеанса.
//
// Параметры:
//  ИмяПараметра			 - Строка - имя параметра сеанса.
//  УстановленныеПараметры	 - Массив из Строка - все установленные параметры сеанса.
//
Процедура УстановитьПараметрыСеанса(ИмяПараметра, УстановленныеПараметры) Экспорт
	
	Если СтрНачинаетсяС(ИмяПараметра, "ПараметрыЛогированияЗапросов") Тогда
		ПараметрыЛогированияЗапросов  = НовыеПараметрыЛогированияЗапросов();
		ПараметрыСеанса[ИмяПараметра] = ОбщегоНазначения.ФиксированныеДанные(ПараметрыЛогированияЗапросов);
		Если ТипЗнч(УстановленныеПараметры) = Тип("Массив") Тогда
			УстановленныеПараметры.Добавить(ИмяПараметра);
		ИначеЕсли ТипЗнч(УстановленныеПараметры) = Тип("Структура") Тогда
			УстановленныеПараметры.Вставить(ИмяПараметра);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Проверят необходимость записи логов запросов протокола обмена по флагу.
// 
// Параметры:
// 	ПараметрыЛогирования - см. НовыеПараметрыЛогированияЗапросов.
// Возвращаемое значение:
// 	Булево - Призак записи логов запросов.
Функция ВыполняетсяЛогированиеЗапросовДляПротоколаОбмена(ПараметрыЛогирования) Экспорт
	
	Если Не ПараметрыЛогирования.ВключеноПротоколОбмена Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Включает уровень логирования запросов при исполнение в фоновом задании на сервере в клиент-серверном варианте.
// Параметры:
// 	ПараметрыЛогирования - см. НовыеПараметрыЛогированияЗапросов.
Процедура НастроитьПараметрыЛогированияВФоновомЗадании(ПараметрыЛогирования) Экспорт
	
	Если ОбщегоНазначенияИСВызовСервера.ЭтоФоновоеЗаданиеНаСервере() Тогда
		Если ВыполняетсяЛогированиеЗапросов(ПараметрыЛогирования) Тогда
			Если ТипЗнч(ПараметрыЛогирования) = Тип("ФиксированнаяСтруктура") Тогда
				ПараметрыЛогирования = ОбщегоНазначения.СкопироватьРекурсивно(ПараметрыЛогирования, Ложь);
			КонецЕсли;
			ВключитьЛогированиеЗапросов(ПараметрыЛогирования,, Истина);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Получает содержимое лога запроса по идентификатору уровня лога или содержание осноного уровня
// 
// Параметры:
// 	ПараметрыЛогирования - см. НовыеПараметрыЛогированияЗапросов.
// 	ИдентификаторЗаписи - Неопределено, Строка - Идентификатор уровня логирования.
// Возвращаемое значение:
// 	Неопределено, Строка - Записанные данные запросов
Функция СодержаниеЛогаЗапросов(ПараметрыЛогирования, ИдентификаторЗаписи = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(ИдентификаторЗаписи) Тогда
		ИмяФайлаЛога = ПараметрыЛогирования.ФайлыЛогирования.Получить(ИдентификаторЗаписи);
	Иначе
		ИмяФайлаЛога = ПараметрыЛогирования.ФайлыЛогирования.Получить(ПараметрыЛогирования.ТекущийИдентификатор);
	КонецЕсли;
	
	Если ИмяФайлаЛога = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Файл = Новый Файл(ИмяФайлаЛога);
	Если Не Файл.Существует() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайлаЛога, КодировкаТекста.UTF8);
	Данные = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	
	Возврат Данные;
	
КонецФункции

// Возвращает текствое описание текущего окружения и параметров.
// 
// Параметры:
//  ДанныеОкружения - Строка - Элемент описания окружения шапки
Процедура ДополнитьИнформациюОбОкруженииШапка(ДанныеОкружения) Экспорт
	
	ИнформацияОСистеме = Новый СистемнаяИнформация();
	ДанныеОкружения.Добавить(
		СтрШаблон(
			НСтр("ru = 'Конфигурация: %1 (%2)'"),
			Метаданные.Синоним,
			Метаданные.Версия));
	ДанныеОкружения.Добавить(
		СтрШаблон(
			НСтр("ru = 'Версия платформы: %1 (%2)'"),
			ИнформацияОСистеме.ВерсияПриложения,
			ИнформацияОСистеме.ТипПлатформы));
	
	Для Каждого ОписаниеПодсистемы Из ОбщегоНазначения.ОписанияПодсистем() Цикл
		Если НРег(ОписаниеПодсистемы.Имя) = НРег("БиблиотекаИнтеграцииГосИС") Тогда
			ДанныеОкружения.Добавить(
				СтрШаблон(
					НСтр("ru = 'Версия библиотеки ГосИС: %1'"),
					ОписаниеПодсистемы.Версия));
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает текствое описание текущего окружения и параметров.
// 
// Параметры:
//  ДанныеОкружения - Строка - Элемент описания окружения подвала
Процедура ДополнитьИнформациюОбОкруженииПодвал(ДанныеОкружения) Экспорт
	
	УстановленныеРасширения = Новый Массив();
	Если СтрНайти(Метаданные.РежимСовместимости, "Версия8_2") = 0 Тогда
		Для Каждого Расширение Из РасширенияКонфигурации.Получить() Цикл
			Если Не Расширение.Активно Тогда
				Продолжить;
			КонецЕсли;
			УстановленныеРасширения.Добавить(
				СокрЛП(
					СтрШаблон(
						НСтр("ru = '%1 %2'"),
						Расширение.Имя,
						Расширение.Версия)));
		КонецЦикла;
	КонецЕсли;
	Если УстановленныеРасширения.Количество() Тогда
		ДанныеОкружения.Добавить(
			СтрШаблон(
				НСтр("ru = 'Активные расширения конфигурации: %1'"),
				СтрСоединить(УстановленныеРасширения, ", ")));
	КонецЕсли;
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		РежимЭксплуатации = НСтр("ru = 'Файловая информационная база'");
	Иначе
		РежимЭксплуатации = НСтр("ru = 'Клиент-серверный режим'");
	КонецЕсли;
	
	ДанныеОкружения.Добавить(
		СтрШаблон(
			НСтр("ru = 'Режим эксплуатации: %1'"),
			РежимЭксплуатации));
	
КонецПроцедуры

// Дописывает полученные данные лога запросов в текущий уровень логирования.
// 
// Параметры:
// 	ДанныеДокумента - Структура:
// 	* ДанныеЛогаЗапросов - Строка - Данные для записи в лог запросов
//  ПараметрыЛогирования - см. НовыеПараметрыЛогированияЗапросов
Процедура ДописатьВТекущийЛогДанныеИзФоновогоЗадания(ДанныеДокумента, ПараметрыЛогирования) Экспорт
	
	ДанныеЛогаЗапросов = Неопределено;
	
	Если ТипЗнч(ДанныеДокумента) <> Тип("Структура")
		Или Не ДанныеДокумента.Свойство("ДанныеЛогаЗапросов", ДанныеЛогаЗапросов)
		Или ТипЗнч(ДанныеЛогаЗапросов) <> Тип("Строка") Тогда
		Возврат;
	КонецЕсли;
	
	ИмяФайла = ПараметрыЛогирования.ФайлыЛогирования.Получить(ПараметрыЛогирования.ТекущийИдентификатор);
	
	Если ИмяФайла = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, КодировкаТекста.UTF8,, Истина);
	ЗаписьТекста.ЗаписатьСтроку(ДанныеЛогаЗапросов);
	ЗаписьТекста.Закрыть();
	
КонецПроцедуры

Функция ДанныеЛогаЗапросовПоАдресуВременногоХранилища(АдресДанныхЛогаЗапроса, Очищать = Истина) Экспорт
	
	Если Не ЭтоАдресВременногоХранилища(АдресДанныхЛогаЗапроса) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ДанныеЛогаЗапросов = ПолучитьИзВременногоХранилища(АдресДанныхЛогаЗапроса);
	
	Если Очищать Тогда
		ПоместитьВоВременноеХранилище(Неопределено, АдресДанныхЛогаЗапроса);
	КонецЕсли;
	
	Возврат ДанныеЛогаЗапросов;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Проверят необходимость записи логов запросов по флагу и времени записи.
// 
// Параметры:
// 	ПараметрыЛогирования см. НовыеПараметрыЛогированияЗапросов.
// Возвращаемое значение:
// 	Булево - Призак записи логов запросов.
Функция ВыполняетсяЛогированиеЗапросов(ПараметрыЛогирования) Экспорт
	
	Если Не ПараметрыЛогирования.Включено
		Или (ЗначениеЗаполнено(ПараметрыЛогирования.ОкончаниеЗаписи)
		И ПараметрыЛогирования.ОкончаниеЗаписи <= ТекущаяУниверсальнаяДатаВМиллисекундах()) Тогда
		Возврат Ложь;
	Иначе 
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Параметры логирования запросов.
// Возвращаемое значение:
// 	Структура - Описание:
// * ФайлыЛогирования - Соответствие Из КлючИЗначение:
//  ** Ключ     - Строка - Идентификатор лога.
// 	** Значение - Строка - Имя файла логирования.
// * ОкончаниеЗаписи      - Число, Неопределено  - Универстальная дата окончания записи лога в милисекундах.
// * Включено             - Булево               - Признак записи лога.
// * ТекущийИдентификатор - Строка, Неопределено - Текущий идентификатор логирования.
// * СтекПараметров       - Массив из Строка     - Стек параметров записи лога.
Функция НовыеПараметрыЛогированияЗапросов()
	
	ПараметрыЛогирования = Новый Структура();
	ПараметрыЛогирования.Вставить("Включено",             Ложь);
	ПараметрыЛогирования.Вставить("ОкончаниеЗаписи",      Неопределено);
	ПараметрыЛогирования.Вставить("ФайлыЛогирования",     Новый Соответствие());
	ПараметрыЛогирования.Вставить("ТекущийИдентификатор", Неопределено);
	ПараметрыЛогирования.Вставить("СтекПараметров",       Новый Массив());
	
	ПараметрыЛогирования.Вставить("ТекущийИдентификаторПротоколОбмена", Неопределено);
	ПараметрыЛогирования.Вставить("ВключеноПротоколОбмена",             Ложь);
	ПараметрыЛогирования.Вставить("ФайлыЛогированияПротоколОбмена",     Новый Соответствие());

	Возврат ПараметрыЛогирования;
	
КонецФункции

Процедура ЗаполнитьПараметрыЛогирования(ПараметрыЛогирования) Экспорт
	
	ПараметрыЛогирования.Включено = ВыполняетсяЛогированиеЗапросов(ПараметрыЛогирования);
	
КонецПроцедуры

// Устанавливает в параметры логирования значения для нового уровня логирования.
// 
// Параметры:
// 	ПараметрыЛогирования - см. НовыеПараметрыЛогированияЗапросов.
Процедура УстановитьНовыйЛог(ПараметрыЛогирования)

	ПараметрыЛогирования.ТекущийИдентификатор = Строка(Новый УникальныйИдентификатор());
	//@skip-check missing-temporary-file-deletion
	ПараметрыЛогирования.ФайлыЛогирования.Вставить(
		ПараметрыЛогирования.ТекущийИдентификатор,
		ПолучитьИмяВременногоФайла(".log"));
	
КонецПроцедуры

// Устанавливает в параметры логирования значения для нового уровня логирования.
// 
// Параметры:
// 	ПараметрыЛогирования - см. НовыеПараметрыЛогированияЗапросов.
Процедура УстановитьНовыйЛогПротоколаОбмена(ПараметрыЛогирования) Экспорт

	ПараметрыЛогирования.ТекущийИдентификаторПротоколОбмена = Строка(Новый УникальныйИдентификатор());
	ПараметрыЛогирования.ФайлыЛогированияПротоколОбмена.Вставить(
		ПараметрыЛогирования.ТекущийИдентификаторПротоколОбмена,
		Новый Массив);
	
КонецПроцедуры
	
// Процедура преобразовывает исходную произвольную структуру в структуру, которую можно преобразовать в JSON
// Необходимо преобразовать Соответствие, где ключом является не Строка, ТаблицаЗначений в Массив Структур и СтрокаТаблицыЗначений
// в ключах в Структура
// 
// Параметры:
//  СтруктураДанных - Произвольный, Структура, Неопределено, Массив из Произвольный - Структура данных для преобразования
Процедура ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(СтруктураДанных)
	
	Если ТипЗнч(СтруктураДанных) = Тип("Структура")
		ИЛИ ТипЗнч(СтруктураДанных) = Тип("Соответствие") Тогда

		МассивУдаляемыхКлючей = Новый Массив;

		Для Каждого ЗначениеСтруктуры Из СтруктураДанных Цикл

			ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(ЗначениеСтруктуры.Значение);

			Если ТипЗнч(ЗначениеСтруктуры.Ключ) <> Тип("Строка")
				И (ТипЗнч(ЗначениеСтруктуры.Ключ) = Тип("СтрокаТаблицыЗначений")
				Или ТипЗнч(ЗначениеСтруктуры.Ключ) = Тип("СтрокаДереваЗначений")) Тогда

				СтрокаТаблицыЗначений = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(ЗначениеСтруктуры.Ключ);
				ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(СтрокаТаблицыЗначений);

				ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет);
				ЗаписьJSON = Новый ЗаписьJSON();

				НастройкиСериализации = Новый НастройкиСериализацииJSON();
				НастройкиСериализации.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.ЛокальнаяДата;
				НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.ISO;

				ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписи);
				ЗаписатьJSON(ЗаписьJSON, СтрокаТаблицыЗначений, НастройкиСериализации, "ПреобразоватьВФорматДляЗаписиJSON", ЛогированиеЗапросовИС);

				СтрокаJSON = ЗаписьJSON.Закрыть();

				СтруктураДанных.Вставить(XMLСтрока(СтрокаJSON), ЗначениеСтруктуры.Значение);
				МассивУдаляемыхКлючей.Добавить(ЗначениеСтруктуры.Ключ);

			ИначеЕсли ТипЗнч(ЗначениеСтруктуры.Ключ) <> Тип("Строка") Тогда

				ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет);
				ЗаписьJSON = Новый ЗаписьJSON();

				НастройкиСериализации = Новый НастройкиСериализацииJSON();
				НастройкиСериализации.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.ЛокальнаяДата;
				НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.ISO;

				ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписи);
				ЗаписатьJSON(ЗаписьJSON, СтрокаТаблицыЗначений, НастройкиСериализации, "ПреобразоватьВФорматДляЗаписиJSON", ЛогированиеЗапросовИС);

				СтрокаJSON = ЗаписьJSON.Закрыть();

				СтруктураДанных.Вставить(XMLСтрока(СтрокаJSON), ЗначениеСтруктуры.Значение);
				
				МассивУдаляемыхКлючей.Добавить(ЗначениеСтруктуры.Ключ);

			Иначе
				Продолжить;
			КонецЕсли;

		КонецЦикла;

		Для Каждого УдаляемоеЗначение Из МассивУдаляемыхКлючей Цикл
			СтруктураДанных.Удалить(УдаляемоеЗначение);
		КонецЦикла;

	ИначеЕсли ТипЗнч(СтруктураДанных) = Тип("Массив") Тогда

		Для Каждого СтрокаМассива Из СтруктураДанных Цикл
			ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(СтрокаМассива);
		КонецЦикла;

	ИначеЕсли ТипЗнч(СтруктураДанных) = Тип("ТаблицаЗначений") Тогда

		МассивСтруктур = ОбщегоНазначения.ТаблицаЗначенийВМассив(СтруктураДанных);
		ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(МассивСтруктур);
		
	ИначеЕсли ТипЗнч(СтруктураДанных) = Тип("СтрокаТаблицыЗначений") Тогда
		
		СтрокаТаблицыЗначений = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(СтруктураДанных);
		ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(СтрокаТаблицыЗначений);
	
	ИначеЕсли ТипЗнч(СтруктураДанных) = Тип("СтрокаДереваЗначений") Тогда
		
		СтрокаТаблицыЗначений = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(СтруктураДанных);
		ПреобразоватьРекурсивноСоответствияДляПреобразованияВJSON(СтрокаТаблицыЗначений);

	КонецЕсли;

КонецПроцедуры

// Преобразовать дерево значений в массив структур.
// 
// Параметры:
//  УзелДерева      - ДеревоЗначений, СтрокаДереваЗначений - Узел дерева
//  СтруктураДерева - Неопределено, Структура - Структура дерева:
// * Строки         - Массив из Структура
// 
// Возвращаемое значение:
//  Структура - результат преобразования
Функция ПреобразоватьДеревоЗначенийВМассивСтруктур(УзелДерева, СтруктураДерева = Неопределено)
	
	Если СтруктураДерева = Неопределено Тогда
		СтруктураДерева = Новый Структура;
	КонецЕсли;
	
	МассивСтрок  = Новый Массив();
	СтрокиДерева = УзелДерева.Строки;
	
	Для Каждого СтрокаДерева Из СтрокиДерева Цикл
				
		ДанныеСтроки = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(СтрокаДерева);
		ДанныеСтроки.Вставить("Строки", Новый Структура);
		
		ПреобразоватьДеревоЗначенийВМассивСтруктур(СтрокаДерева, ДанныеСтроки);			
		МассивСтрок.Добавить(ДанныеСтроки);
		
	КонецЦикла;
	
	СтруктураДерева.Вставить("Строки", МассивСтрок);
	Возврат СтруктураДерева;
	
КонецФункции

#КонецОбласти
