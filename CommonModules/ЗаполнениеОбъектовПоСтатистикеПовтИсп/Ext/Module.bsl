
#Область СлужебныйПрограммныйИнтерфейс

// Формирует описание структуры реквизитов для заполнения по статистике.
//
// Параметры:
//  ИмяОбъектаМетаданных - Строка - имя объекта метаданных
//  ЗаполняемыеРеквизиты - см. ЗаполнениеОбъектовПоСтатистике.ДобавитьОписаниеЗаполняемыхРеквизитов
//  ОтборПоРеквизитуРодителю - Строка - имя реквизита объекта, подчиненные реквизиты которого надо заполнить по статистике.
//
// Возвращаемое значение:
//  Структура - Свойства:
//  	* РеквизитыОбъекта - Структура из КлючИЗначение - Свойства:
//  		* Ключ - Строка - имя реквизита объекта, заполняемого по статистике
//  		* Значение - Структура из КлючИЗначение  - Описание "реквизитов-родителей":
//  			* Ключ - Строка - имя "реквизита-родителя"
//  			* Значение - Число - тип "родителя", его влияние на сбор статистики:
//  				1 - "Родитель", который обязательно должен быть заполнен.
//  					Если хоть один из родителей этого типа не заполнен - не имеет смысла собирать статистику "подчиненного" реквизита.
//  				2 - "Родитель", который не должен быть заполнен.
//  					Если хоть один из родителей этого типа заполнен - не нужно собирать статистику "подчиненного" реквизита.
//  				3 - "Родитель", который участвуют в отборе статистики всегда, независимо от его заполненности.
//  					Заполнен или нет реквизит этого типа, он все равно участвует в отборе статистики "подчиненного" реквизита.
//  				4 - "Родитель", который участвуют в отборе статистики только если они заполнены.
//  					Если реквизит этого типа не заполнен, то по нему не выполняется отбор статистики "подчиненного" реквизита.
//  	* ПорядокЗаполненияРеквизитов - Массив - определяет последовательность заполнения реквизитов объекта.
//  		Заполнение выполняется начиная с реквизитов, не имеющих "родителей" и заканчивается реквизитами, не имеющими "подчиненных".
//  		Элементами массива является структуры, ключи которых содержат имена реквизитов, которые надо заполнить на данном шаге.
//  	* КэшЗначенияРеквизитов - Структура из КлючИЗначение  - кэшируемые значения реквизитов (используется для заполнения их "подчиненных" реквизитов)
//  		* Ключ - Строка - имя реквизита объекта
//  		* Значение - Произвольный - значение реквизита объекта
//  	* ТекстОшибки - Строка - содержит текст ошибки, выявленной при формировании описания структуры реквизитов.
//
Функция ОписаниеРеквизитовОбъекта(ИмяОбъектаМетаданных, ЗаполняемыеРеквизиты, ОтборПоРеквизитуРодителю = "") Экспорт
	
	ОписаниеРеквизитовОбъекта = ШаблонОписанияРеквизитовОбъекта();
	
	ДобавитьВОписаниеРеквизитыОбъекта(ИмяОбъектаМетаданных, ОписаниеРеквизитовОбъекта, ЗаполняемыеРеквизиты);
	
	ОставитьВОписанииТолькоПодчиненныеРеквизитыОбъекта(ОписаниеРеквизитовОбъекта, ОтборПоРеквизитуРодителю);
	
	ОпределитьПорядокЗаполненияРеквизитовОбъекта(ОписаниеРеквизитовОбъекта);
	
	Возврат ОписаниеРеквизитовОбъекта;
	
КонецФункции

// Возвращает реквизиты указанного объекта метаданных, заполняемые из данных заполнения объекта.
//
// Параметры:
//  ИмяОбъектаМетаданных - Строка - имя объекта метаданных.
//
// Возвращаемое значение:
//  Структура - ключами являются имена реквизитов объекта метаданных.
//
Функция РеквизитыЗаполняемыеИзДанныхЗаполнения(ИмяОбъектаМетаданных) Экспорт
	
	СтруктураРеквизитов = Новый Структура;
	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ИмяОбъектаМетаданных);
	
	Для Каждого Реквизит Из МетаданныеОбъекта.Реквизиты Цикл
		Если Реквизит.ЗаполнятьИзДанныхЗаполнения Тогда
			СтруктураРеквизитов.Вставить(Реквизит.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтруктураРеквизитов;
	
КонецФункции

// Определяет значение реквизита, которое согласно статистике является "частотным".
//
// Параметры:
//  СсылкаНаОбъект - ДокументСсылка - ссылка на заполняемый документ. Может быть пустой
//  ИмяОбъектаМетаданных - Строка - имя объекта метаданных первого параметра
//  ИмяРеквизита - Строка - имя заполняемого реквизита объекта
//  ЗначенияРеквизитовРодителей - Соответствие - значения реквизитов отбора:
//		* Ключ - Строка - название реквизита
//		* Значение - Произвольный - значение реквизита  	
//  ЧастотаИспользованияЗначения - Число - минимальное количество значений, которые должны быть одинаковыми.
//  РазмерВыборки - Число - количество последних выбираемых значений.
//
//  Возвращаемое значение:
//     Произвольный - значение, найденное по статистике.
//
Функция ЗначениеРеквизитаПоСтатистике(
	СсылкаНаОбъект,
	ИмяОбъектаМетаданных,
	ИмяРеквизита,
	ЗначенияРеквизитовРодителей,
	ЧастотаИспользованияЗначения,
	РазмерВыборки) Экспорт
		
	// Сформируем текст запроса (содержит шаблоны для замены)
	// Алгоритм расчета значения реквизита:
	// - выберем последние по дате объекты в количестве "РазмерВыборки" (кроме помеченных на удаление объектов и текущего объекта)
	// - посчитаем количество раз, которое использовалось каждое значение заполняемого реквизита в выбранных объектах
	//  	например, Значение1 = 1 раз, Значение2 - 3 раза, Значение3 - 1 раз
	// - выберем одно значение реквизита, вес которого среди всех значений составляет больше 0,5 (50%)
	//  	например, вес Значение1 = 0,2, вес Значение2 = 0,6, вес Значение3 = 0,2, т.е. будет выбрано Значение2
	//  	если значения с подходящим весом (> 0,5) нет, то не будет выбрано ничего,
	//  	т.е. нет такого значения реквизита, которое по статистическим данным является "частотным".
	Запрос = Новый Запрос;
	
	ТекстЗапроса =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
	|	&ВыражениеРеквизита КАК ЗначениеРеквизита
	|ИЗ
	|	&ИмяТаблицы КАК ТаблицаОбъекта
	|ГДЕ
	|	НЕ ТаблицаОбъекта.ПометкаУдаления
	|	И &ОтборСсылка
	|	И &ДополнительныйОтбор
	|	
	|УПОРЯДОЧИТЬ ПО
	|	ТаблицаОбъекта.Дата УБЫВ";
	
	// Отборы запроса:
	Если ЗначениеЗаполнено(СсылкаНаОбъект) Тогда 
		// - по объекту, реквизит которого заполняется по статистике.
		Запрос.УстановитьПараметр("Ссылка", СсылкаНаОбъект);
	КонецЕсли;
	// - по минимальному весу значения; вес выше этого позволяет считать значение "частотным".
	Запрос.УстановитьПараметр("ЧастотаИспользованияЗначения", ЧастотаИспользованияЗначения);
	// - по реквизитам-родителям; параметры запроса вида "&Отбор_<Имя реквизита-родителя>".
	УсловияОтбора = Новый Массив;
	Для Каждого Родитель Из ЗначенияРеквизитовРодителей Цикл
		УсловияОтбора.Добавить("ТаблицаОбъекта." + Родитель.Ключ + " = &Отбор_" + Родитель.Ключ);
		Запрос.УстановитьПараметр("Отбор_" + Родитель.Ключ, Родитель.Значение);
	КонецЦикла;
	ДополнительныйОтбор = СтрСоединить(УсловияОтбора, Символы.ПС + Символы.Таб + Символы.Таб + "И" + " ");

	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "РАЗРЕШЕННЫЕ ПЕРВЫЕ 1", "РАЗРЕШЕННЫЕ ПЕРВЫЕ" + " " + Формат(РазмерВыборки, "ЧГ=0"));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ВыражениеРеквизита", "ТаблицаОбъекта." + ИмяРеквизита);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИмяТаблицы", ИмяОбъектаМетаданных);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ОтборСсылка", ?(ЗначениеЗаполнено(СсылкаНаОбъект), "НЕ ТаблицаОбъекта.Ссылка = &Ссылка", "ИСТИНА"));
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ДополнительныйОтбор", ?(ЗначениеЗаполнено(ДополнительныйОтбор), ДополнительныйОтбор, "ИСТИНА"));
	
	Запрос.Текст = ТекстЗапроса;
	
	Выборка = Запрос.Выполнить().Выбрать();
	ОбщееКоличество = Выборка.Количество();
	ВесаРеквизитов = Новый Соответствие;
	Пока Выборка.Следующий() Цикл
		ТекущийВес = ВесаРеквизитов.Получить(Выборка.ЗначениеРеквизита);
		Если ТекущийВес = Неопределено Тогда
			ТекущийВес = 1;
			ВесаРеквизитов.Вставить(Выборка.ЗначениеРеквизита, ТекущийВес);
		Иначе
			ТекущийВес = ТекущийВес + 1;
			ВесаРеквизитов.Вставить(Выборка.ЗначениеРеквизита, ТекущийВес);
		КонецЕсли;
		Если ТекущийВес / ОбщееКоличество > ЧастотаИспользованияЗначения Тогда
			Возврат Выборка.ЗначениеРеквизита;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращает шаблон структуры для описания реквизитов объекта.
//
// Возвращаемое значение:
//  Структура -  см. комментарий к ОписаниеРеквизитовОбъекта.
//
Функция ШаблонОписанияРеквизитовОбъекта()
	
	ОписаниеРеквизитовОбъекта = Новый Структура;
	ОписаниеРеквизитовОбъекта.Вставить("Объект",                      Новый Структура);
	ОписаниеРеквизитовОбъекта.Вставить("РеквизитыОбъекта",            Новый Структура);
	ОписаниеРеквизитовОбъекта.Вставить("ПорядокЗаполненияРеквизитов", Новый Массив);
	ОписаниеРеквизитовОбъекта.Вставить("КэшЗначенияРеквизитов",       Новый Структура);
	ОписаниеРеквизитовОбъекта.Вставить("ТекстОшибки",                 "");
	
	Возврат ОписаниеРеквизитовОбъекта;
	
КонецФункции

#Область ФормированиеСтруктурыОписанияРеквизитов

// Заполняет описание структуры реквизитов объекта информацией о всех реквизитах объекта.
//
// Параметры:
//  ИмяОбъектаМетаданных - Строка - имя объекта метаданных
//  ОписаниеРеквизитовОбъекта - Структура - см. комментарий к ОписаниеРеквизитовОбъекта
//  ЗаполняемыеРеквизиты - Структура - см. комментарий к ОписаниеРеквизитовОбъекта.
//
Процедура ДобавитьВОписаниеРеквизитыОбъекта(ИмяОбъектаМетаданных, ОписаниеРеквизитовОбъекта, ЗаполняемыеРеквизиты)
	
	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ИмяОбъектаМетаданных);
	
	Для Каждого ЗаполняемыйРеквизит Из ЗаполняемыеРеквизиты Цикл
		
		Если Не ОбщегоНазначения.ЕстьРеквизитОбъекта(ЗаполняемыйРеквизит.Ключ, МетаданныеОбъекта)
			И НЕ ОбщегоНазначения.ЭтоСтандартныйРеквизит(МетаданныеОбъекта.СтандартныеРеквизиты, ЗаполняемыйРеквизит.Ключ) Тогда
				
			ОписаниеРеквизитовОбъекта.ТекстОшибки = СтрШаблон(
				НСтр("ru='В метаданных объекта нет реквизита ""%1"".'"), ЗаполняемыйРеквизит.Ключ);
				
			Возврат;
		КонецЕсли;
		
		// Добавим в описание реквизит объекта, заполняемый по статистике
		ОписаниеРеквизитовОбъекта.РеквизитыОбъекта.Вставить(ЗаполняемыйРеквизит.Ключ, Новый Структура);
		
		Для Каждого РеквизитРодитель Из ЗаполняемыйРеквизит.Значение Цикл
			
			Если Не ОбщегоНазначения.ЕстьРеквизитОбъекта(РеквизитРодитель.Ключ, МетаданныеОбъекта)
				И НЕ ОбщегоНазначения.ЭтоСтандартныйРеквизит(МетаданныеОбъекта.СтандартныеРеквизиты, ЗаполняемыйРеквизит.Ключ) Тогда
					
				ОписаниеРеквизитовОбъекта.ТекстОшибки = СтрШаблон(
					НСтр("ru='В метаданных объекта нет реквизита ""%1"".'"), РеквизитРодитель.Ключ);
					
				Возврат;
			КонецЕсли;
			
			// Добавим в описание реквизита объекта, заполняемого по статистике, информацию о "реквизите-родителе".
			ОписаниеРеквизитовОбъекта.РеквизитыОбъекта[ЗаполняемыйРеквизит.Ключ].Вставить(
				РеквизитРодитель.Ключ,
				РеквизитРодитель.Значение);
			
		КонецЦикла;
		
		// Обязательно учитывается автор при заполнении по статистике.
		Если Не ОписаниеРеквизитовОбъекта.РеквизитыОбъекта[ЗаполняемыйРеквизит.Ключ].Свойство("Автор")
			И ОбщегоНазначения.ЕстьРеквизитОбъекта("Автор", МетаданныеОбъекта) Тогда
			ОписаниеРеквизитовОбъекта.РеквизитыОбъекта[ЗаполняемыйРеквизит.Ключ].Вставить(
				"Автор", Новый Структура("ОтбиратьВсегда"));
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет из описания "лишние" реквизиты, заполнение которых в данном контексте не требуется.
// В результате в описании реквизитов остаются только реквизиты,
// "подчиненные" самому реквизиту ОтборПоРеквизитуРодителю или любому из его "реквизитов-потомков".
// 
// Параметры:
//  ОписаниеРеквизитовОбъекта - Структура - см. комментарий к ОписаниеРеквизитовОбъекта
//  ОтборПоРеквизитуРодителю - Строка - см. комментарий к ОписаниеРеквизитовОбъекта.
//
Процедура ОставитьВОписанииТолькоПодчиненныеРеквизитыОбъекта(ОписаниеРеквизитовОбъекта, ОтборПоРеквизитуРодителю)
	
	Если Не ЗначениеЗаполнено(ОтборПоРеквизитуРодителю) // требуется заполнение всех реквизитов объекта
		Или ЗначениеЗаполнено(ОписаниеРеквизитовОбъекта.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим, что указанный реквизит-родитель есть (по "или")
	// - среди реквизитов, заполняемых по статистике
	// - среди реквизитов-родителей, влияющих на заполнение других реквизитов
	// По сути это защита от некорректного вызова, когда ошибочно передан несуществующий реквизит-родитель.
	РеквизитСуществует = Ложь;
	
	Для Каждого РеквизитИРодители Из ОписаниеРеквизитовОбъекта.РеквизитыОбъекта Цикл
		Если НРег(РеквизитИРодители.Ключ) = НРег(ОтборПоРеквизитуРодителю)
			Или РеквизитИРодители.Значение.Свойство(ОтборПоРеквизитуРодителю) Тогда
			РеквизитСуществует = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Не РеквизитСуществует Тогда
		ОписаниеРеквизитовОбъекта.ТекстОшибки = СтрШаблон(
			НСтр("ru='Для реквизита ""%1"" не предусмотрено заполнение по статистике.'"),
			ОтборПоРеквизитуРодителю);
		Возврат; // нет такого реквизита
	КонецЕсли;
	
	ПодчиненныеРеквизиты = Новый Структура(ОтборПоРеквизитуРодителю); // реквизит-родитель и все его "реквизиты-потомки"
	ПродолжатьПоиск      = Истина;
	
	// Ищем до тех пор, пока не будет выполнена холостая итерация,
	// на которой не будет найдено ни одного нового "реквизита-потомка".
	Пока ПродолжатьПоиск Цикл
		
		ПродолжатьПоиск = Ложь;
		
		Для Каждого РеквизитИРодители Из ОписаниеРеквизитовОбъекта.РеквизитыОбъекта Цикл
			
			Для Каждого ПодчиненныйРеквизит Из ПодчиненныеРеквизиты Цикл
				
				Если РеквизитИРодители.Значение.Свойство(ПодчиненныйРеквизит.Ключ)
					И Не ПодчиненныеРеквизиты.Свойство(РеквизитИРодители.Ключ) Тогда
					
					// Найден еще один "реквизит-потомок"
					ПодчиненныеРеквизиты.Вставить(РеквизитИРодители.Ключ);
					ПродолжатьПоиск = Истина;
					
					Прервать;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ПодчиненныеРеквизиты.Удалить(ОтборПоРеквизитуРодителю); // сам реквизит-родитель заполнять не надо
	
	// Удалим "лишние" реквизиты (не являющиеся "реквизитами-потомками")
	Для Каждого РеквизитИРодители Из ОписаниеРеквизитовОбъекта.РеквизитыОбъекта Цикл
		
		Если Не ПодчиненныеРеквизиты.Свойство(РеквизитИРодители.Ключ) Тогда
			
			// ... из структуры реквизитов объекта
			ОписаниеРеквизитовОбъекта.РеквизитыОбъекта.Удалить(РеквизитИРодители.Ключ);
			
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Вычисляет порядок, в которым должны заполняться реквизиты объекта.
// Реквизиты и их связи по сути являются описанием графа - в этой процедуре выполняется топологическая сортировка этого графа:
// - сначала должны заполняться реквизиты, среди "родителей" которых нет других заполняемых реквизитов
// - затем заполняются реквизиты, "подчиненные" реквизитам, найденным на предыдущей итерации
// - и т.д., пока на очередной итерации не будет найдено ни одного "подчиненного" реквизита
// - если в графе будет найден цикл (петля), то будет выдана ошибка - значит описание реквизитов объекта сформировано некорректно.
//
// Параметры:
//  ОписаниеРеквизитовОбъекта - см. ОписаниеРеквизитовОбъекта.
//
Процедура ОпределитьПорядокЗаполненияРеквизитовОбъекта(ОписаниеРеквизитовОбъекта)
	
	Если ЗначениеЗаполнено(ОписаниеРеквизитовОбъекта.ТекстОшибки) Тогда
		Возврат;
	КонецЕсли;
	
	ОписаниеРеквизитовОбъекта.ПорядокЗаполненияРеквизитов.Очистить();
	
	// Представим все дуги графа в виде структуры: Ключ - приемник, Значение - источник
	ВходящиеСвязи = Новый Структура;
	
	Для Каждого РеквизитИРодители Из ОписаниеРеквизитовОбъекта.РеквизитыОбъекта Цикл
		
		ВходящиеСвязи.Вставить(
			РеквизитИРодители.Ключ,
			ОбщегоНазначения.СкопироватьРекурсивно(РеквизитИРодители.Значение));
		
		Для Каждого Родитель Из РеквизитИРодители.Значение Цикл
			Если Не ВходящиеСвязи.Свойство(Родитель.Ключ) Тогда
				ВходящиеСвязи.Вставить(Родитель.Ключ, Новый Структура);
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
	
	// Продолжаем обход графа пока в нем остаются "несортированные" вершины.
	Пока ВходящиеСвязи.Количество() > 0 Цикл
		
		РеквизитыТекущегоУровня = Новый Структура; // вершины, в которые не входят дуги 
		
		Для Каждого ВходящаяСвязь Из ВходящиеСвязи Цикл
			Если ВходящаяСвязь.Значение.Количество() = 0 Тогда
				// Найдена вершина без входящих дуг (реквизит без родителей)
				РеквизитыТекущегоУровня.Вставить(ВходящаяСвязь.Ключ);
			КонецЕсли;
		КонецЦикла;
		
		Если РеквизитыТекущегоУровня.Количество() = 0 Тогда // в графе найден цикл
			ОписаниеРеквизитовОбъекта.ТекстОшибки = НСтр(
				"ru='При описании структуры реквизитов для заполнения по статистике
				|допущено зацикливание связей реквизитов'");
			Возврат;
		КонецЕсли;
		
		// Удалим найденные на текущей итерации вершины без входящих дуг из графа.
		// В результате некоторые из их подчиненных вершин теперь станут вершинами без входящих дуг.
		Для Каждого ТекущийРеквизит Из РеквизитыТекущегоУровня Цикл
			ВходящиеСвязи.Удалить(ТекущийРеквизит.Ключ); // удалим из заполняемых реквизитов
			Для Каждого ВходящаяСвязь Из ВходящиеСвязи Цикл
				ВходящаяСвязь.Значение.Удалить(ТекущийРеквизит.Ключ); // удалим из "реквизитов-родителей"
			КонецЦикла;
		КонецЦикла;
		
		// Среди найденных на текущей итерации оставим только те реквизиты, которые надо заполнять по статистике.
		Для Каждого ТекущийРеквизит Из РеквизитыТекущегоУровня Цикл
			Если Не ОписаниеРеквизитовОбъекта.РеквизитыОбъекта.Свойство(ТекущийРеквизит.Ключ) Тогда
				// Этот реквизит является только "родителем", но сам не заполняется.
				РеквизитыТекущегоУровня.Удалить(ТекущийРеквизит.Ключ);
			КонецЕсли;
		КонецЦикла;
		
		// Если на текущей итерации найден хоть один заполняемый по статистике реквизит,
		// то добавим новый уровень в порядок заполнения реквизитов.
		// В нем будут только заполняемые по статистике реквизиты, "подчиненные" только реквизитам вышестоящих уровней.
		Если РеквизитыТекущегоУровня.Количество() > 0 Тогда
			ОписаниеРеквизитовОбъекта.ПорядокЗаполненияРеквизитов.Добавить(РеквизитыТекущегоУровня);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти
