
#Область ПрограммныйИнтерфейс

#Область ПарсингФормулыИОперандов

// Вычисляет значение идентификатора из строки соответствии с правилами именования переменных.
// 
// Параметры:
//  СтрНаименование - Строка - Наименование, строка из которой необходимо получить идентификатор. 
//
// Возвращаемое значение:
//  Строка - Идентификатор, соответствующий правилам именования идентификаторов.
//
Функция ИдентификаторДляФормул(СтрНаименование) Экспорт
	
	Идентификатор = СтрНаименование;
	
	Цифры = Новый Массив();
	Для Сч = 0 По 9 Цикл
		Цифры.Добавить(Строка(Сч));
	КонецЦикла;
	
	ПервыйСимволНеЦифра = Ложь;
	
	Идентификатор = ПолучитьИдентификатор(Идентификатор);
	
	Если Не ПустаяСтрока(Идентификатор) Тогда
		Пока НЕ ПервыйСимволНеЦифра Цикл
			Если Цифры.Найти(Сред(Идентификатор, 1, 1)) = Неопределено Тогда
				ПервыйСимволНеЦифра = Истина;
			КонецЕсли;
			Если ПервыйСимволНеЦифра Тогда
				Прервать;
			Иначе
				Идентификатор = Сред(Идентификатор, 2);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Идентификатор;
	
КонецФункции

// Получает текст операнда для вставки в формулу.
//
// Параметры:
//  Операнд - Строка - имя операнда.
//
// Возвращаемое значение:
//  Строка - Текст операнда для вставки.
//
Функция ПолучитьТекстОперандаДляВставки(Операнд) Экспорт
	
	Возврат "[" + Операнд + "]";
	
КонецФункции // ПолучитьТекстОперандаДляВставки()

// Извлекает операнды из текстовой формулы
//
// Параметры:
//  Формула - Строка - текст формулы.
//  ТолькоУникальные - Булево - Если Истина, то в возвращаемый массив помещаются только уникальные операнды.
//
// Возвращаемое значение:
//  Массив - Операнды из текстовой формулы (без внешних скобок, например, "Номенклатура.{ДР.Экспедитор}").
//
Функция ОперандыТекстовойФормулы(Формула, ТолькоУникальные = Ложь) Экспорт
	
	МассивОперандов = Новый Массив;
	
	ТегНачалаОперанда = "[";
	ТегОкончанияОперанда = "]";
	
	ОставшаясяЧастьФормулы = Формула;
	
	НачалоОперанда = СтрНайти(ОставшаясяЧастьФормулы, ТегНачалаОперанда);
	Пока НачалоОперанда > 0 Цикл
		КонецОперанда = ПозицияЗакрывающегоТегаОкончанияОперанда(ОставшаясяЧастьФормулы, ТегНачалаОперанда, ТегОкончанияОперанда);
		Операнд = Сред(ОставшаясяЧастьФормулы, НачалоОперанда, (КонецОперанда - НачалоОперанда + 1));
		ОперандБезВнешнихСкобок = Сред(Операнд, 2, СтрДлина(Операнд) - 2);
		Если ТолькоУникальные Тогда
			Если МассивОперандов.Найти(ОперандБезВнешнихСкобок) = Неопределено Тогда
				МассивОперандов.Добавить(ОперандБезВнешнихСкобок);
			КонецЕсли;
		Иначе
			МассивОперандов.Добавить(ОперандБезВнешнихСкобок);
		КонецЕсли;
		
		ОставшаясяЧастьФормулы = Сред(ОставшаясяЧастьФормулы, КонецОперанда + 1);
		НачалоОперанда = СтрНайти(ОставшаясяЧастьФормулы, ТегНачалаОперанда);
	КонецЦикла;
	
	
	Возврат МассивОперандов;
	
КонецФункции

// Возвращает массив частей операнда. Например, операнд
// 			"СтрокаТабличнойЧасти[0].РеквизитТЧ.{ХарактеристикаРеквизита}.РеквизитХарактеристики"
// должен быть разделен на части:
// 			"СтрокаТабличнойЧасти[0]", "РеквизитТЧ", "{ХарактеристикаРеквизита}", "РеквизитХарактеристики".
// 
// Параметры:
// 	Операнд - Строка - Операнд формулы.
// 	ПредставленияХарактеристик - Булево - Флаг, указывающий, что парсится выражения с представлениями характеристик,
// 				а не идентификаторами.
// 	УдалятьВнешниеСкобки - Булево - Если Истина, то если операнд заключен во внешние [] скобки, они будут удалены.
// 				В основном, если операнд заключен во внешние квадратные скобки, это ограничение самого операнда,
// 				как, например, в формулах видов номенклатур. Однако, если разбирается на части часть операнда, то
// 				внешние квадратные скобки являются признаком характеристики, и их удалять не следует.
// 				Например, в методе "ВыполнениеПроверкиИПреобразованияВыражений", может распарсиваться путь
// 				типа "Счет.Субконто1.[Представление характеристики]". Тогда часть "Счет.Субконто1" - является
// 				первой частью выражения, а "[Представление характеристики]" - второй.
// Возвращаемое значение:
// 	Массив из Строка - Части операнда.
//
Функция ЧастиОперанда(Операнд, ПредставленияХарактеристик = Ложь, УдалятьВнешниеСкобки = Истина) Экспорт
	Результат = Новый Массив;
	
	РазбираемыйТекст = Операнд;
	
	ТегНачалаОперанда = "[";
	ТегОкончанияОперанда = "]";
	
	ТегНачалаХарактеристики = "{";
	ТегОкончанияХарактеристики = "}";
	Если ПредставленияХарактеристик Тогда
		ТегНачалаХарактеристики = "[";
		ТегОкончанияХарактеристики = "]";
	КонецЕсли;
	
	Если УдалятьВнешниеСкобки Тогда
		// Если операнд заключен во внешние скобки [], их нужно удалить.
		Если Лев(РазбираемыйТекст, 1) = ТегНачалаОперанда
			И Прав(РазбираемыйТекст, 1) = ТегОкончанияОперанда Тогда
			РазбираемыйТекст = Сред(РазбираемыйТекст, 2, СтрДлина(РазбираемыйТекст) - 2);
		КонецЕсли;
	КонецЕсли;
	
	// Внутри характеристики через точку указывается префикс типа характеристики.
	// Поэтому сначала ищутся теги характеристик, вне этих тегов части операнда разделяются точкой.
	РазделительЧастейОперанда = ".";
	
	НачалоПозицииХарактеристики = СтрНайти(РазбираемыйТекст, ТегНачалаХарактеристики);
	Пока НачалоПозицииХарактеристики > 0 Цикл
		КонецПозицииХарактеристики = ПозицияЗакрывающегоТегаОкончанияОперанда(РазбираемыйТекст,
			ТегНачалаХарактеристики, ТегОкончанияХарактеристики);
		
		Если НачалоПозицииХарактеристики = 1 Тогда
			ТекстПередХарактеристикой = "";
		Иначе
			ТекстПередХарактеристикой = Сред(РазбираемыйТекст, 1, НачалоПозицииХарактеристики - 1);
		КонецЕсли;
		Если НЕ ПустаяСтрока(ТекстПередХарактеристикой) Тогда
			Части = СтрРазделить(ТекстПередХарактеристикой, РазделительЧастейОперанда, Ложь);
			Для Каждого Часть Из Части Цикл
				Результат.Добавить(Часть);
			КонецЦикла;
		КонецЕсли;
		ЧастьХарактеристики = Сред(РазбираемыйТекст,
			НачалоПозицииХарактеристики,
			КонецПозицииХарактеристики - НачалоПозицииХарактеристики + 1);
		Результат.Добавить(ЧастьХарактеристики);
		
		РазбираемыйТекст = Сред(РазбираемыйТекст, КонецПозицииХарактеристики + 1);
		НачалоПозицииХарактеристики = СтрНайти(РазбираемыйТекст, ТегНачалаХарактеристики);
	КонецЦикла;
	Если НЕ ПустаяСтрока(РазбираемыйТекст) Тогда
		Части = СтрРазделить(РазбираемыйТекст, РазделительЧастейОперанда, Ложь);
		Для Каждого Часть Из Части Цикл
			Результат.Добавить(Часть);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция СпецСимволы() Экспорт
	СпецСимволы = " .,+,-,/,*,?,=,<,>,(,)%!@#$%&*""№:;{}[]?()\|/`~'^_";
	Возврат СпецСимволы;
КонецФункции

#КонецОбласти

#Область ФункцииОбщегоМодуля

// Возвращает пустой массив структур описаний функций, которые можно вызвать при выполнении формулы.
// 
// Возвращаемое значение:
// 	Массив из см. ОписаниеФункцииОбщегоМодуля
//
Функция ФункцииОбщегоМодуля() Экспорт
	Результат = Новый Массив;
	
	Возврат Результат;
КонецФункции

// Возвращает структуру описания функции, которую можно вызвать при выполнении формулы.
// 
// Возвращаемое значение:
// 	Структура - описание дополнительной функции, используемой в конструкторе формул и при выполнении формулы, со свойствами:
// 	 *Идентификатор - Строка - Обязательное поле. Идентификатор функции на языке кода. Например "РасчетПоАлгоритму".
// 	 *ПолныйПуть - Строка - Обязательное поле. Включает имя общего модуля и имя функции.
// 	 		Например, "СложныеРасчеты.РасчетПоАлгоритму".
// 	 *Представление - Строка - Обязательное поле. Представление отображения функции на языке пользователя.
// 	 		Например, "Расчет по алгоритму".
// 	 *КонструкцияДляВставки - Строка - Обязательное поле. Текст, вставляемый в конструктор формул.
// 	 		Содержит идентификатор функции на языке кода.
// 			Также может содержать запятые, а также подсказки для пользователя на языке пользователя.
// 			Например, "РасчетПоАлгоритму(<Параметр функции 1>, <Параметр функции 2>)".
// 			В приведенном примере описания параметров "<Параметр функции 1>" могут быть помещены в НСтр для отображения
// 			пользователю.
// 	 *Пояснение - Строка - Необязательный параметр. Пояснение, выводимое в конструкторе формул при позиционировании
// 	 		на строке функции. На языке пользователя.
//
Функция ОписаниеФункцииОбщегоМодуля() Экспорт
	ОписаниеФункции = Новый Структура;
	// Обязательные параметры.
	ОписаниеФункции.Вставить("Идентификатор", "");
	ОписаниеФункции.Вставить("ПолныйПуть", "");
	ОписаниеФункции.Вставить("Представление", "");
	ОписаниеФункции.Вставить("КонструкцияДляВставки", "");
	
	// Необязательные параметры.
	ОписаниеФункции.Вставить("Пояснение", "");
	
	Возврат ОписаниеФункции;
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Вычисляет значение идентификатора из строки соответствии с правилами
// именования идентификаторов.
// 
// Параметры:
// 	СтрокаПредставления - Строка - Представление, строка из которой необходимо получить идентификатор.
//
// Возвращаемое значение:
// 	Строка - Идентификатор, соответствующий правилам именования идентификаторов.
//
Функция ПолучитьИдентификатор(СтрокаПредставления)
	
	СпецСимволы = СпецСимволы();
	Цифры = "0123456789";
	
	Идентификатор = "";
	БылСпецСимвол = Ложь;
	БылиЗначащиеСимволыНеЦифры = Ложь;
	
	Для НомСимвола = 1 По СтрДлина(СтрокаПредставления) Цикл
		
		Символ = Сред(СтрокаПредставления, НомСимвола, 1);
		
		Если СтрНайти(СпецСимволы, Символ) <> 0 Тогда
			БылСпецСимвол = Истина;
			Если Символ = "_" Тогда
				Идентификатор = Идентификатор + Символ;
				БылиЗначащиеСимволыНеЦифры = Истина;
			КонецЕсли;
		ИначеЕсли НЕ БылиЗначащиеСимволыНеЦифры
			И СтрНайти(Цифры, Символ) <> 0 Тогда
			БылСпецСимвол = Истина;
			Идентификатор = Идентификатор + Символ;
		ИначеЕсли БылСпецСимвол
			ИЛИ НомСимвола = 1 Тогда
			БылСпецСимвол = Ложь;
			Идентификатор = Идентификатор + ВРег(Символ);
			БылиЗначащиеСимволыНеЦифры = Истина;
		Иначе
			Идентификатор = Идентификатор + Символ;
			БылиЗначащиеСимволыНеЦифры = Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Идентификатор;
	
КонецФункции

Функция ПозицияЗакрывающегоТегаОкончанияОперанда(ОставшаясяЧастьФормулы, ТегНачалаОперанда, ТегОкончанияОперанда)
	
	СчетчикВложенныхТегов = 0;
	Позиция = СтрНайти(ОставшаясяЧастьФормулы, ТегНачалаОперанда,, 1);
	
	СледующаяПозицияЗакрытия = 0;
	СчетчикВложенныхТегов = СчетчикВложенныхТегов + 1;
	Пока НЕ СчетчикВложенныхТегов = 0 Цикл
		// Например, операнд, включающий индекс строки табличной части.
		СледующаяПозицияОткрытия = СтрНайти(ОставшаясяЧастьФормулы, ТегНачалаОперанда,, Позиция + 1);
		СледующаяПозицияЗакрытия = СтрНайти(ОставшаясяЧастьФормулы, ТегОкончанияОперанда,, Позиция + 1);
		
		Если СледующаяПозицияОткрытия <> 0
			И (СледующаяПозицияОткрытия < СледующаяПозицияЗакрытия) Тогда
			Позиция = СледующаяПозицияОткрытия;
			СчетчикВложенныхТегов = СчетчикВложенныхТегов + 1;
		Иначе
			Позиция = СледующаяПозицияЗакрытия;
			СчетчикВложенныхТегов = СчетчикВложенныхТегов - 1;
		КонецЕсли;
		Если Позиция = 0 Тогда
			ТекстОшибки = НСтр("ru = 'Ошибка при разборе текста формулы: не найден тег закрытия операнда'");
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Позиция;
	
КонецФункции

#КонецОбласти

