////////////////////////////////////////////////////////////////////////////////
// Модуль содержит общие процедуры и функции для форм регламентированной
// отчетности.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Функция возвращает ссылку на головную организацию.
//
// Возвращаемое значение: ссылка на элемент справочника организаций.
//
// Параметры:
// 	Организация - ссылка на элемент справочника организаций.
//
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	ГоловнаяОрганизация = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, "ГоловнаяОрганизация");
	
	Если НЕ ЗначениеЗаполнено(Организация)
	 ИЛИ НЕ ЗначениеЗаполнено(ГоловнаяОрганизация) Тогда
	 
		Возврат Организация;
		
	Иначе
		
		Возврат ГоловнаяОрганизация;
		
	КонецЕсли;

КонецФункции

Функция ВерсияПрограммы() Экспорт
	
	Возврат СокрЛП(Метаданные.Версия);
	
КонецФункции

Функция НазваниеПрограммы() Экспорт
	
	Возврат Метаданные.КраткаяИнформация;
	
КонецФункции

Функция НазваниеИВерсияПрограммы() Экспорт
	Возврат ВРЕГ(Лев(НазваниеПрограммы() + " " + ВерсияПрограммы(), 40));
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция РазложитьФИО(Знач ФИОСтр) Экспорт
	
	ФИОСтр = СокрЛП(ФИОСтр);
	
	ФИО = Новый Структура("Фамилия, Имя, Отчество", "", "", "");
	
	ПервыйПробел = СтрНайти(ФИОСтр, " ");
	
	Если ПервыйПробел = 0 Тогда
		
		ФИО.Фамилия = ФИОСтр;
		
		Возврат ФИО;
		
	КонецЕсли;
	
	ФИО.Фамилия = СокрЛП(Лев(ФИОСтр, ПервыйПробел - 1));
	
	ФИОСтр = СокрЛП(Сред(ФИОСтр, ПервыйПробел + 1));
	
	ВторойПробел = СтрНайти(ФИОСтр, " ");
	
	Если ВторойПробел = 0 Тогда
		
		ФИО.Имя = ФИОСтр;
		
		Возврат ФИО;
		
	КонецЕсли;
	
	ФИО.Имя = СокрЛП(Лев(ФИОСтр, ВторойПробел - 1));
	
	ФИО.Отчество = СокрЛП(Сред(ФиоСтр, ВторойПробел + 1));
	
	Запрос = Новый Запрос;
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	ФИОФизическихЛицСрезПоследних.Фамилия,
	|	ФИОФизическихЛицСрезПоследних.Имя,
	|	ФИОФизическихЛицСрезПоследних.Отчество
	|ИЗ
	|	РегистрСведений.ФИОФизическихЛиц.СрезПоследних КАК ФИОФизическихЛицСрезПоследних
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|		ПО ФИОФизическихЛицСрезПоследних.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|ГДЕ
	|	ФизическиеЛица.Наименование ПОДОБНО &Фамилия";
	
	Запрос.УстановитьПараметр("Фамилия", СокрЛП(ФИО.Фамилия) + "%");
		
	Результат = Запрос.Выполнить();
	
	ФИОФизическихЛиц = Результат.Выбрать();
	
	Пока ФИОФизическихЛиц.Следующий() Цикл
		
		ФИОФизическогоЛица = СокрЛП(ФИОФизическихЛиц.Фамилия) + " " + СокрЛП(ФИОФизическихЛиц.Имя) + " " + СокрЛП(ФИОФизическихЛиц.Отчество);
		
		Если ВРег(СокрЛП(ФИОФизическогоЛица)) = ВРег(СокрЛП(СокрЛП(ФИО.Фамилия) + " " + СокрЛП(ФИО.Имя) + " " + СокрЛП(ФИО.Отчество))) Тогда
			
			ФИО.Фамилия  = СокрЛП(ФИОФизическихЛиц.Фамилия);
			ФИО.Имя      = СокрЛП(ФИОФизическихЛиц.Имя);
			ФИО.Отчество = СокрЛП(ФИОФизическихЛиц.Отчество);
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ФИО;
	
КонецФункции

// Помещает данные во временное хранилище и устанавливает новый адрес.
// Если исходный адрес данных не пустой, то производит предварительную очистку хранилища.
//
// Параметры:
//   ПомещаемыеДанные - Произвольный - данные, которые необходимо поместить во временное хранилище.
//   ИдентификаторСеанса - УникальныйИдентификатор - уникальный идентификатор, необходимый для помещения
//     во временное хранилище.
//   АдресДанных - Строка, Неопределено - переменная, содержащая адрес во временном хранилище.
//
Процедура ПоместитьВКэш(ПомещаемыеДанные, ИдентификаторСеанса, АдресДанных) Экспорт
	
	Если ЭтоАдресВременногоХранилища(АдресДанных) Тогда
		УдалитьИзВременногоХранилища(АдресДанных);
	КонецЕсли;
	
	АдресДанных = ПоместитьВоВременноеХранилище(ПомещаемыеДанные, ИдентификаторСеанса);
	
КонецПроцедуры

#КонецОбласти

#Область ПроцедурыИФункцииВыгрузки

Функция УзелПуст(Узел, ПоказателиНеанализируемыеНаЗаполненность = Неопределено) Экспорт 
	
	Если (СтрНайти(Узел.Тип, "A") <> 0 ИЛИ СтрНайти(Узел.Тип, "А") <> 0)
	   И (СтрНайти(Узел.Обязательность, "Н") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "H") <> 0) Тогда // учтем оба варианта: кириллицу и латиницу
	   
	        
	   		Возврат Не (ЗначениеЗаполнено(Узел.Значение) И Узел.Код = "s1" 
					И Узел.Родитель.Строки.Количество() = 2 
					И Узел.Владелец().Колонки.Найти("КоличествоПодчиненных") <> Неопределено
					И (Узел.Родитель.КоличествоПодчиненных = 2));
	КонецЕсли;
	
	Если Узел.Формат = "N" Тогда
		ОбязательноеНулевоеЗначение = Ложь;
		Если ТипЗнч(Узел.Показатели) = Тип("Структура") Тогда
			ФорматПредставленияНуля = Неопределено;
			Если Узел.Показатели.Свойство("ЧН" + Узел.Ключ, ФорматПредставленияНуля) Тогда
				ОбязательноеНулевоеЗначение = НЕ ПустаяСтрока(Формат(0, ФорматПредставленияНуля));
			КонецЕсли;
		КонецЕсли;
		ПустойУзел = (Узел.Значение = "0" ИЛИ НЕ ЗначениеЗаполнено(Узел.Значение)) И НЕ ОбязательноеНулевоеЗначение;
	Иначе
		ПустойУзел = НЕ ЗначениеЗаполнено(Узел.Значение);
	КонецЕсли;
	
	Для Каждого Стр Из Узел.Строки Цикл
		Если НЕ УзелПуст(Стр) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	Возврат ПустойУзел;
	
КонецФункции

Функция СкопироватьУзел(Родитель, Узел) Экспорт 
	
	// находим узел с максимальным индексом и с тем же кодом, что и у копируемого, и добавляем новый сразу после найденного
	СтрокиСТемЖеКодом = Родитель.Строки.НайтиСтроки(Новый Структура("Код", Узел.Код), Ложь);
	МаксИндекс = -1;
	Для Каждого СтрокаСТемЖеКодом Из СтрокиСТемЖеКодом Цикл
		ТекИндекс = Родитель.Строки.Индекс(СтрокаСТемЖеКодом);
		Если ТекИндекс > МаксИндекс Тогда
			МаксИндекс = ТекИндекс;
		КонецЕсли;
	КонецЦикла;
	
	ИндексСоздаваемогоУзла = МаксИндекс + 1;
	Если ИндексСоздаваемогоУзла >= Родитель.Строки.Количество() ИЛИ ИндексСоздаваемогоУзла = 0 Тогда // если аналогичный узел не найден или найденный узел - последний
		НовыйУзел = Родитель.Строки.Добавить();
	Иначе
		НовыйУзел = Родитель.Строки.Вставить(ИндексСоздаваемогоУзла);
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(НовыйУзел, Узел, , "Родитель, Строки");
	Для Каждого Стр Из Узел.Строки Цикл
		СкопироватьУзел(НовыйУзел, Стр);
	КонецЦикла;
	Возврат НовыйУзел;
	
КонецФункции

Функция ПолучитьПервыйПодчиненныйУзелСЗаполненнымКлючом(Родитель) Экспорт 
	
	Для Каждого Стр Из Родитель.Строки Цикл
		Если ЗначениеЗаполнено(Стр.Ключ) Тогда
			Возврат Стр;
		КонецЕсли;
	КонецЦикла;
	Возврат Неопределено;
	
КонецФункции

Процедура УдалитьУзел(Узел) Экспорт 
	
	РодительУзла = ?(Узел.Родитель = Неопределено, Узел.Владелец(), Узел.Родитель);
	РодительУзла.Строки.Удалить(Узел);
	
КонецПроцедуры

Процедура УстановитьЗначениеЭлемента(УзелРодитель, ИмяЭлемента, ЗначениеЭлемента) Экспорт 
	
	ПодчиненныйЭлемент = ПолучитьПодчиненныйЭлемент(УзелРодитель, ИмяЭлемента);
	ВывестиПоказательВXML(ПодчиненныйЭлемент, ЗначениеЭлемента);
	
КонецПроцедуры

Функция ВывестиПоказательВXML(Узел, ЗначениеПоказателя) Экспорт 
	
	МинШирина = Узел.МинРазмерность;
	МаксШирина = Узел.МаксРазмерность;
	
	Если Узел.Формат = "T" ИЛИ Узел.Формат = "Т" Тогда
		Узел.Значение = ?(МаксШирина < СтрДлина(СокрЛП(ЗначениеПоказателя)), СокрЛП(Лев(СокрЛП(ЗначениеПоказателя), МаксШирина)), СокрЛП(ЗначениеПоказателя));
	ИначеЕсли Узел.Формат = "N" Тогда
		СтрокаФормата = "ЧРД=.;ЧН=0;ЧГ=;";
		Если Узел.МаксРазмерность <> 0 И Узел.МаксРазмерность <> 99999 Тогда
			СтрокаФормата = СтрокаФормата + "ЧЦ=" + Формат(Узел.МаксРазмерность, "ЧГ=") + ";";
		КонецЕсли;
		Если Узел.МинРазмерность <> 99999 Тогда
			СтрокаФормата = СтрокаФормата + "ЧДЦ=" + Формат(Узел.МинРазмерность, "ЧГ=") + ";";
		КонецЕсли;
		Узел.Значение = СокрЛП(Формат(ЗначениеПоказателя, СтрокаФормата));
	ИначеЕсли Узел.Формат = "gYear" Тогда
		Если ТипЗнч(ЗначениеПоказателя) = Тип("Дата") Тогда
			Узел.Значение = СокрЛП(Формат(ЗначениеПоказателя, "ДФ=гггг"));
		Иначе
			Узел.Значение = Прав(СокрЛП(ЗначениеПоказателя), 4);
		КонецЕсли;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ПолучитьПодчиненныйЭлемент(Узел, КодЭлемента) Экспорт 
	
	Для Каждого Стр Из Узел.Строки Цикл
		Если Стр.Код = КодЭлемента Тогда
			Возврат Стр;
		КонецЕсли;
	КонецЦикла;
	
КонецФункции

Функция НовыйУзелИзПрототипа(ПрототипУзла) Экспорт 
	
	РодительУзла = ПрототипУзла.Родитель;
	
	ПозицияИсходногоУзла = РодительУзла.Строки.Индекс(ПрототипУзла);
	НовыйУзел = РодительУзла.Строки.Вставить(ПозицияИсходногоУзла);
	ЗаполнитьЗначенияСвойств(НовыйУзел, ПрототипУзла, , "Родитель, Строки");
	Для Каждого Стр из ПрототипУзла.Строки Цикл
		СкопироватьУзел(НовыйУзел, Стр);
	КонецЦикла;
	
	Возврат НовыйУзел;
	
КонецФункции

Функция ИзвлечьСтруктуруXML(ИмяФормы, ИмяМакета) Экспорт 
	
	ДеревоСтруктуры = Новый ДеревоЗначений;
	ДеревоСтруктуры.Колонки.Добавить("Код");
	ДеревоСтруктуры.Колонки.Добавить("Тип");
	ДеревоСтруктуры.Колонки.Добавить("Формат");
	ДеревоСтруктуры.Колонки.Добавить("МинРазмерность");
	ДеревоСтруктуры.Колонки.Добавить("МаксРазмерность");
	ДеревоСтруктуры.Колонки.Добавить("Обязательность");
	ДеревоСтруктуры.Колонки.Добавить("Многостраничность");
	ДеревоСтруктуры.Колонки.Добавить("Многострочность");
	ДеревоСтруктуры.Колонки.Добавить("Раздел");
	ДеревоСтруктуры.Колонки.Добавить("Ключ");
	ДеревоСтруктуры.Колонки.Добавить("Условие");
	ДеревоСтруктуры.Колонки.Добавить("ЗначениеПоУмолчанию");
	ДеревоСтруктуры.Колонки.Добавить("Значение");
	ДеревоСтруктуры.Колонки.Добавить("Представление");
	ДеревоСтруктуры.Колонки.Добавить("Показатели");
	
	Если ТипЗнч(ИмяФормы) = Тип("Строка") Тогда
		Если Метаданные.Отчеты.Найти(ИмяФормы) = Неопределено Тогда
			Макет = РегламентированнаяОтчетностьВызовСервера.ОбъектОтчета(ИмяФормы).ПолучитьМакет(ИмяМакета);
		Иначе
			Макет = Отчеты[ИмяФормы].ПолучитьМакет(ИмяМакета);
		КонецЕсли;
	ИначеЕсли ТипЗнч(ИмяФормы) = Тип("ФормаКлиентскогоПриложения") Тогда
		Макет = РегламентированнаяОтчетностьВызовСервера.ОбъектОтчета(ИмяФормы.ИмяФормы).ПолучитьМакет(ИмяМакета);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	ВысотаТаблицы = Макет.ВысотаТаблицы;
	
	УчтенныеГруппы = Новый Соответствие;
	
	Для Уровень = 0 По Макет.КоличествоУровнейГруппировокСтрок() - 1 Цикл
		Макет.ПоказатьУровеньГруппировокСтрок(Уровень);
		Для НомерСтроки = 2 По ВысотаТаблицы Цикл
			НомСтр = ВысотаТаблицы - НомерСтроки + 2;
			Видимость = Макет.Область(НомСтр, 0, НомСтр, 0).Видимость;
			Если Видимость И УчтенныеГруппы.Получить(НомСтр) = Неопределено Тогда
				
				РодительскийУзел = ДеревоСтруктуры;
				Если Уровень <> 0 Тогда
					Для Инд = 1 По НомСтр - 2 Цикл
						Узел = УчтенныеГруппы.Получить(НомСтр - Инд);
						Если Узел <> Неопределено Тогда
							РодительскийУзел = Узел;
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				НовСтр = РодительскийУзел.Строки.Вставить(0);
				НовСтр.Код = СокрЛП(Макет.Область(НомСтр, 1, НомСтр, 1).Текст);
				НовСтр.Раздел = СокрЛП(Макет.Область(НомСтр, 2, НомСтр, 2).Текст);
				НовСтр.Ключ = СокрЛП(Макет.Область(НомСтр, 3, НомСтр, 3).Текст);
				НовСтр.Тип = СокрЛП(Макет.Область(НомСтр, 4, НомСтр, 4).Текст);
				НовСтр.Формат = СокрЛП(Макет.Область(НомСтр, 5, НомСтр, 5).Текст);
				МинРазмерность = СокрЛП(Макет.Область(НомСтр, 6, НомСтр, 6).Текст);
				НовСтр.МинРазмерность = ?(ПустаяСтрока(МинРазмерность), ?(НовСтр.Формат = "N", 99999, 0), Число(МинРазмерность));
				МаксРазмерность = СокрЛП(Макет.Область(НомСтр, 7, НомСтр, 7).Текст);
				НовСтр.МаксРазмерность = ?(ПустаяСтрока(МаксРазмерность), 99999, Число(МаксРазмерность));
				НовСтр.Обязательность = СокрЛП(Макет.Область(НомСтр, 8, НомСтр, 8).Текст);
				НовСтр.Многостраничность = НЕ ПустаяСтрока(Макет.Область(НомСтр, 9, НомСтр, 9).Текст);
				НовСтр.Многострочность = НЕ ПустаяСтрока(Макет.Область(НомСтр, 10, НомСтр, 10).Текст);
				НовСтр.Условие = СокрЛП(Макет.Область(НомСтр, 11, НомСтр, 11).Текст);
				НовСтр.ЗначениеПоУмолчанию = СокрЛП(Макет.Область(НомСтр, 12, НомСтр, 12).Текст);
				НовСтр.Представление = СокрЛП(Макет.Область(НомСтр, 13, НомСтр, 13).Текст);
				
				УчтенныеГруппы.Вставить(НомСтр, НовСтр);
				
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат ДеревоСтруктуры;
	
КонецФункции

Функция ПолучитьДеревоВыгрузки(Форма, ИмяМакета) Экспорт 
	СтруктураВыгрузки = Неопределено;
	Если ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
		Для Каждого Реквизит Из Форма.ПолучитьРеквизиты() Цикл
			Если Нрег(Реквизит.Имя) = Нрег("СтруктураВыгрузки") Тогда
				СтруктураВыгрузки = Форма.СтруктураВыгрузки;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ТипЗнч(СтруктураВыгрузки) = Тип("ДанныеФормыДерево") Тогда
		Если СтруктураВыгрузки.ПолучитьЭлементы().Количество() > 0 Тогда
			ДеревоВыгрузки = ДанныеФормыВЗначение(СтруктураВыгрузки, Тип("ДеревоЗначений"));
		Иначе 
			Если ТипЗнч(Форма) = Тип("Структура") И Форма.Свойство("ИмяФормы") Тогда
				ДеревоВыгрузки = ИзвлечьСтруктуруXML(Форма.ИмяФормы, ИмяМакета);
			Иначе
				ДеревоВыгрузки = ИзвлечьСтруктуруXML(Форма, ИмяМакета);
			КонецЕсли;
			ЗначениеВДанныеФормы(ДеревоВыгрузки, СтруктураВыгрузки);
		КонецЕсли;
		Возврат ДеревоВыгрузки;
	Иначе
		Если ТипЗнч(Форма) = Тип("Структура") И Форма.Свойство("ИмяФормы") Тогда
			Возврат ИзвлечьСтруктуруXML(Форма.ИмяФормы, ИмяМакета)
		Иначе 
			Возврат ИзвлечьСтруктуруXML(Форма, ИмяМакета)
		КонецЕсли;
	КонецЕсли;
КонецФункции

Функция ИмеютсяАналогичныеСоседниеУзлыКлючРаздел(Стр) Экспорт 
	
	Возврат (Стр.Родитель.Строки.НайтиСтроки(Новый Структура("Ключ, Раздел", Стр.Ключ, Стр.Раздел), Ложь).Количество() > 1);
	
КонецФункции

Функция ИмеютсяАналогичныеСоседниеУзлыКлюч(Стр) Экспорт 
	
	Возврат (Стр.Родитель.Строки.НайтиСтроки(Новый Структура("Ключ", Стр.Ключ), Ложь).Количество() > 1);
	
КонецФункции

Функция СоздатьНовыйПотокXML(Кодировка = "utf-8") Экспорт
	
	ПотокXML = Новый ЗаписьXML();
	ПотокXML.Отступ = Истина;
	ПотокXML.УстановитьСтроку(Кодировка);
	ПотокXML.ЗаписатьОбъявлениеXML();
	Возврат ПотокXML;
	
КонецФункции

Функция УсловиеВыполнено(Владелец, ПараметрыВыгрузки, Условие, ИмяРаздела = "Титульный", Узел = Неопределено) Экспорт
	
	Попытка
		РезультатВычисленияВыражения = ОбщегоНазначения.ВычислитьВБезопасномРежиме(
			СтрЗаменить(Условие, "&", "Параметры."), ПараметрыВыгрузки);
		
		Если РезультатВычисленияВыражения <> Неопределено Тогда
			Если РезультатВычисленияВыражения = 1 ИЛИ РезультатВычисленияВыражения = 0
			 ИЛИ РезультатВычисленияВыражения = Истина ИЛИ РезультатВычисленияВыражения = Ложь Тогда
				Возврат НЕ (Булево(РезультатВычисленияВыражения) = Ложь);
			Иначе
				СообщитьВТаблицуСообщений(Владелец, "Не удалось вычислить выражение-условие: """ + Условие + """!", ИмяРаздела, "");
			КонецЕсли;
		КонецЕсли;
		
	Исключение
		СообщитьВТаблицуСообщений(Владелец, "Не удалось вычислить выражение-условие: """ + Условие + """!", ИмяРаздела, "");
		Возврат Истина;
		
	КонецПопытки;
	
КонецФункции

Процедура ДополнитьСтруктуруПараметров(мДанныеОтчета, ПараметрыВыгрузки, Узел) Экспорт 
	
	Если НЕ ПустаяСтрока(Узел.Раздел) Тогда
		Если РегламентированнаяОтчетностьКлиентСервер.СвойствоОпределено(мДанныеОтчета, Узел.Раздел) Тогда
			ПоказателиРаздела = мДанныеОтчета[Узел.Раздел];
			Если ТипЗнч(ПоказателиРаздела) = Тип("Структура") Тогда
				Для Каждого Эл Из ПоказателиРаздела Цикл
					ПараметрыВыгрузки.Вставить(Эл.Ключ, Эл.Значение);
				КонецЦикла;
			КонецЕсли;
		Иначе
			ПоказателиРаздела = мДанныеОтчета[Узел.Раздел];
			Для Каждого Эл Из ПоказателиРаздела Цикл
				ПараметрыВыгрузки.Вставить(Эл.Ключ, Эл.Значение);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ДополнитьСтруктуруПараметровПрочиеОтчеты(мДанныеОтчета, ПараметрыВыгрузки, Узел) Экспорт 
	
	Если НЕ ПустаяСтрока(Узел.Раздел) Тогда
		Если РегламентированнаяОтчетностьКлиентСервер.СвойствоОпределено(мДанныеОтчета, "ПолеТабличногоДокумента" + Узел.Раздел) Тогда
			ПоказателиРаздела = мДанныеОтчета["ПолеТабличногоДокумента" + Узел.Раздел];
			Для Каждого Эл Из ПоказателиРаздела Цикл
				ПараметрыВыгрузки.Вставить(Эл.Ключ, Эл.Значение);
			КонецЦикла;
		Иначе
			ПоказателиРаздела = мДанныеОтчета[Узел.Раздел];
			Для Каждого Эл Из ПоказателиРаздела Цикл
				ПараметрыВыгрузки.Вставить(Эл.Ключ, Эл.Значение);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ЗаписатьУзелДереваВXML(СтрокаДерева, ПотокXML, ПараметрыВыгрузки) Экспорт
	
	Если ТипЗнч(СтрокаДерева) = Тип("ДеревоЗначений") Тогда
		Для Каждого Стр Из СтрокаДерева.Строки Цикл
			ЗаписатьУзелДереваВXML(Стр, ПотокXML, ПараметрыВыгрузки);
		КонецЦикла;
	Иначе
		Если СтрокаДерева.Тип = "А" ИЛИ СтрокаДерева.Тип = "A" Тогда
			ПотокXML.ЗаписатьАтрибут(СтрокаДерева.Код, Строка(СтрокаДерева.Значение));
		Иначе
			ПотокXML.ЗаписатьНачалоЭлемента(СтрокаДерева.Код);
			Для Каждого Лист Из СтрокаДерева.Строки Цикл
				Если Лист.Тип = "А" ИЛИ Лист.Тип = "A" Тогда
					ЗаписатьУзелДереваВXML(Лист, ПотокXML, ПараметрыВыгрузки);
				КонецЕсли;
			КонецЦикла;
			Для Каждого Лист Из СтрокаДерева.Строки Цикл
				Если Не (Лист.Тип = "А" ИЛИ Лист.Тип = "A") Тогда
					ЗаписатьУзелДереваВXML(Лист, ПотокXML, ПараметрыВыгрузки);
				КонецЕсли;
			КонецЦикла;
			ПотокXML.ЗаписатьТекст(Строка(СтрокаДерева.Значение));
			ПотокXML.ЗаписатьКонецЭлемента();
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

Функция ЗначениеСоответствуетФормату(Форма, Стр) Экспорт
	
	СтатусПроверки = Истина;
	Если Стр.Формат = "Т" ИЛИ Стр.Формат = "T" Тогда // учтем оба варианта: кириллицу и латиницу
		ДлинаЗначения = СтрДлина(Стр.Значение);
		Если ДлинаЗначения < Стр.МинРазмерность Тогда
			СтатусПроверки = Ложь;
			СообщитьВТаблицуСообщений(Форма, "Длина значения показателя """ + ПредставлениеПоказателя(Стр) + """ меньше минимально возможной (" + ДлинаЗначения + " < " + Стр.МинРазмерность + ")", "Титульный", "");
		КонецЕсли;
		Если ДлинаЗначения > Стр.МаксРазмерность Тогда
			СтатусПроверки = Ложь;
			СообщитьВТаблицуСообщений(Форма, "Длина значения показателя """ + ПредставлениеПоказателя(Стр) + """ больше максимально возможной (" + ДлинаЗначения + " > " + Стр.МаксРазмерность + ")", "Титульный", "");
		КонецЕсли;
	КонецЕсли;
	Возврат СтатусПроверки;
	
КонецФункции

Функция ПредставлениеПоказателя(Стр) Экспорт 
	
	Возврат ?(ПустаяСтрока(Стр.Представление), Стр.Код, Стр.Представление);
	
КонецФункции

Функция ВывестиПоказательСтатистикиВXML(Узел, ЗначениеПоказателя, ФорматПредставленияНуля = "") Экспорт 
	
	МинШирина = Узел.МинРазмерность;
	МаксШирина = Узел.МаксРазмерность;
	
	Если Узел.Формат = "T" ИЛИ Узел.Формат = "Т" Тогда      // учтем оба варианта: кириллицу и латиницу
		Если ЗначениеЗаполнено(ЗначениеПоказателя) Тогда
			Если МинШирина = 10 И МаксШирина = 10 И ТипЗнч(ЗначениеПоказателя) = Тип("Дата") Тогда 
				Узел.Значение = Формат(ЗначениеПоказателя, "ДФ=dd.MM.yyyy");
			ИначеЕсли МинШирина = 7 И МаксШирина = 7 И ТипЗнч(ЗначениеПоказателя) = Тип("Дата") Тогда 
				Узел.Значение = Формат(ЗначениеПоказателя, "ДФ=MM.yyyy");
			Иначе 
				Узел.Значение = ?(МаксШирина < СтрДлина(СокрЛП(ЗначениеПоказателя)), СокрЛП(Лев(СокрЛП(ЗначениеПоказателя), МаксШирина)), СокрЛП(ЗначениеПоказателя));
			КонецЕсли;
		Иначе
			Узел.Значение = Неопределено;
		КонецЕсли;
	ИначеЕсли Узел.Формат = "B" ИЛИ Узел.Формат = "В" Тогда // учтем оба варианта: кириллицу и латиницу
		Если ЗначениеЗаполнено(ЗначениеПоказателя) Тогда
			Узел.Значение = ?(ТипЗнч(ЗначениеПоказателя) = Тип("Строка"), СокрЛП(ЗначениеПоказателя), ?(Булево(0 + ЗначениеПоказателя), "true", "false"));
		Иначе
			Узел.Значение = Неопределено;
		КонецЕсли;
	ИначеЕсли Узел.Формат = "N" Тогда
		СтрокаФормата = "ЧРД=.;ЧН=0;ЧГ=;";
		Если Узел.МаксРазмерность <> 0 И Узел.МаксРазмерность <> 99999 Тогда
			СтрокаФормата = СтрокаФормата + "ЧЦ=" + Формат(Узел.МаксРазмерность, "ЧГ=") + ";";
		КонецЕсли;
		Если Узел.МинРазмерность <> 99999 Тогда
			СтрокаФормата = СтрокаФормата + "ЧДЦ=" + Формат(Узел.МинРазмерность, "ЧГ=") + ";";
		КонецЕсли;
		Узел.Значение = ЧислоПоФормату(ЗначениеПоказателя, СтрокаФормата, Истина);
		Если СтрНайти(ФорматПредставленияНуля, "ЧН=") > 0 Тогда
			Узел.Показатели = Новый Структура("ЧН" + СокрЛП(Узел.Ключ), ФорматПредставленияНуля);
		КонецЕсли;
	ИначеЕсли Узел.Формат = "gYear" Тогда
		Если ТипЗнч(ЗначениеПоказателя) = Тип("Дата") Тогда
			Если ЗначениеЗаполнено(ЗначениеПоказателя) Тогда
				Узел.Значение = СокрЛП(Формат(ЗначениеПоказателя, "ДФ=гггг"));
			Иначе
				Узел.Значение = Неопределено;
			КонецЕсли;
		Иначе
			Узел.Значение = Прав(СокрЛП(ЗначениеПоказателя), 4);
		КонецЕсли;
	КонецЕсли;
	
КонецФункции

Процедура ДополнитьДеревоВыгрузки(ДеревоВыгрузки) Экспорт 
	ДеревоВыгрузки.Колонки.Добавить("КоличествоПодчиненных", Новый ОписаниеТипов("Число"));
	Для Каждого Стр Из ДеревоВыгрузки.Строки Цикл 
		ДополнитьДеревоВыгрузкиРек(Стр);
	КонецЦикла;
КонецПроцедуры

Процедура ДополнитьДеревоВыгрузкиРек(СтрДеревоВыгрузки)
	СтрДеревоВыгрузки.КоличествоПодчиненных = СтрДеревоВыгрузки.Строки.Количество();
	Для Каждого Стр Из СтрДеревоВыгрузки.Строки Цикл 
		ДополнитьДеревоВыгрузкиРек(Стр);
	КонецЦикла;
КонецПроцедуры

Процедура ОтсечьНезаполненныеНеобязательныеУзлыСтатистики(Узел) Экспорт 
	Если ТипЗнч(Узел) = Тип("ДеревоЗначений") Тогда 
		ДополнитьДеревоВыгрузки(Узел);
	ИначеЕсли Узел.Владелец().Колонки.Найти("КоличествоПодчиненных") = Неопределено Тогда 
		ДополнитьДеревоВыгрузки(Узел.Владелец());
	КонецЕсли;
	
	КоличествоСтрок = Узел.Строки.Количество();
	Для Инд = 1 По КоличествоСтрок Цикл
		Стр = Узел.Строки.Получить(КоличествоСтрок - Инд);
		ОтсечьНезаполненныеНеобязательныеУзлыСтатистики(Стр);
	КонецЦикла;
	
	Если ТипЗнч(Узел) <> Тип("ДеревоЗначений") Тогда
		Если (СтрНайти(Узел.Тип, "A") <> 0 ИЛИ СтрНайти(Узел.Тип, "А") <> 0) // Необязательные атрибуты пропускаем (они удаляются только вместе с узлом)
			И (СтрНайти(Узел.Обязательность, "Н") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "H") <> 0) Тогда // учтем оба варианта: кириллицу и латиницу
			Возврат;
		КонецЕсли;
		
		Если (СтрНайти(Узел.Обязательность, "Н") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "H") <> 0) И УзелПуст(Узел) Тогда // учтем оба варианта: кириллицу и латиницу
			УдалитьУзел(Узел);
		ИначеЕсли (СтрНайти(Узел.Обязательность, "М") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "M") <> 0) // учтем оба варианта: кириллицу и латиницу
			И УзелПуст(Узел)
			И ?(СтрНайти(Узел.Обязательность, "О") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "O") <> 0, ИмеютсяАналогичныеСоседниеУзлыКлючРаздел(Узел), Истина) Тогда
			УдалитьУзел(Узел);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ПроверитьДанные(Форма, Узел) Экспорт 
	
	СтатусПроверки = Истина;
	Если ТипЗнч(Узел) <> Тип("ДеревоЗначений") Тогда
		Если НЕ ЗначениеСоответствуетФормату(Форма, Узел) Тогда
			СтатусПроверки = Ложь;
		КонецЕсли;
	КонецЕсли;
	Для Каждого Стр Из Узел.Строки Цикл
		СтатусПроверки = (ПроверитьДанные(Форма, Стр) И СтатусПроверки); // именно в указанном порядке для выдачи всех ошибок
	КонецЦикла;
	Возврат СтатусПроверки;
	
КонецФункции

Функция СформироватьСтруктуруДопАтрибутов(ИмяФормы, ИмяМакета) Экспорт 
	
	ДопАтрибуты = Новый Структура;
	
	Если ТипЗнч(ИмяФормы) = Тип("ФормаКлиентскогоПриложения") Тогда
		Макет = РегламентированнаяОтчетностьВызовСервера.ОбъектОтчета(ИмяФормы.ИмяФормы).ПолучитьМакет(ИмяМакета);
	Иначе 
		Макет = РегламентированнаяОтчетностьВызовСервера.ОбъектОтчета(ИмяФормы).ПолучитьМакет(ИмяМакета);
	КонецЕсли;
	
	Для НомСтр = 1 По Макет.ВысотаТаблицы Цикл
		АтрКлюч = СокрЛП(Макет.Область(НомСтр, 1, НомСтр, 1).Текст);
		Если НЕ ПустаяСтрока(АтрКлюч) Тогда
			АтрКлюч = СтроковыеФункцииКлиентСервер.ЗаменитьОдниСимволыДругими(".- ", АтрКлюч, "___");
			ДопАтрибуты.Вставить(АтрКлюч, СокрЛП(Макет.Область(НомСтр, 2, НомСтр, 2).Текст));
		КонецЕсли;
	КонецЦикла;
	
	Если ДопАтрибуты.Свойство("OKUD")
		И ТипЗнч(ДопАтрибуты.OKUD) = Тип("Строка")
		И СтрДлина(ДопАтрибуты.OKUD) <= 6 Тогда
		
		ДопАтрибуты.OKUD = Прав("0000000" + ДопАтрибуты.OKUD, 7);
	КонецЕсли;
	
	Возврат ДопАтрибуты;
	
КонецФункции

// Функция возвращеат формат выгрузки стат. отчета в формате **-**-****, например, 16-09-2013
// ИсточникОтчета - Строка, имя отчета, например, РегламентированныйОтчетСтатистикаФормаП1
// ИмяФормы - Строка, имя формы, например, ФормаОтчета2016Кв1
// ДопПараметры - Неопределено или структура с доп. параметрами
Функция ПолучитьВерсиюВыгрузкиСтатОтчета(ИсточникОтчета, ИмяФормы, ДопПараметры = Неопределено) Экспорт
	ИмяМакетаАттр = СтрЗаменить(ИмяФормы, "ФормаОтчета", "АтрибВыгрузкиXML");
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ
	|	0 КАК Ссылка
	|ИЗ
	|	Справочник.РегламентированныеОтчеты КАК РегламентированныеОтчеты
	|ГДЕ
	|	РегламентированныеОтчеты.ИсточникОтчета = &ИсточникОтчета
	|	И НЕ РегламентированныеОтчеты.ПометкаУдаления
	|	И РегламентированныеОтчеты.ВнешнийОтчетИспользовать";
	
	Запрос.УстановитьПараметр("ИсточникОтчета", ИсточникОтчета);
	
	РезультатЗапроса = Запрос.Выполнить();
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		ОтчетИмя = "ВнешнийОтчет."+ИсточникОтчета+".Форма."+ИмяФормы;
	Иначе
		ОтчетИмя = "Отчет."+ИсточникОтчета+".Форма."+ИмяФормы;
	КонецЕсли;
	
	ВерсияРезультат = "";
	Для Каждого Макет Из Метаданные.Отчеты[ИсточникОтчета].Макеты Цикл
		Если СтрНачинаетсяС(Макет.Имя, ИмяМакетаАттр) Тогда
			ДопАтрибуты = СформироватьСтруктуруДопАтрибутов(ОтчетИмя, Макет.Имя);
			ДопАтрибуты.Свойство("version", ВерсияРезультат);
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВерсияРезультат;
КонецФункции

Процедура ОбработатьУсловныеЭлементы(Форма, Знач ПараметрыВыгрузки, Узел) Экспорт 
	
	Если ТипЗнч(Узел) <> Тип("ДеревоЗначений") Тогда
		Если Узел.Код = ПараметрыВыгрузки.ИмяКлючевогоУзлаСодержательнойЧасти Тогда
			Возврат;
		КонецЕсли;
		ДополнитьСтруктуруПараметров(Форма.мДанныеОтчета, ПараметрыВыгрузки, Узел);
	КонецЕсли;
	КоличествоСтрок = Узел.Строки.Количество();
	Для Инд = 1 По КоличествоСтрок Цикл
		ТекСтр = Узел.Строки.Получить(КоличествоСтрок - Инд);
		Если НЕ ПустаяСтрока(ТекСтр.Условие) Тогда
			Если НЕ УсловиеВыполнено(Форма, ПараметрыВыгрузки, ТекСтр.Условие, , Узел) Тогда
				Узел.Строки.Удалить(ТекСтр);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ОбработатьУсловныеЭлементы(Форма,ПараметрыВыгрузки, ТекСтр);
	КонецЦикла;
	
КонецПроцедуры

Функция ВыгрузитьДеревоВXML(ДеревоВыгрузки, ПараметрыВыгрузки, Кодировка = "utf-8") Экспорт 
	
	ПотокXML = СоздатьНовыйПотокXML(Кодировка); // создаем новый поток для записи
	ЗаписатьУзелДереваВXML(ДеревоВыгрузки, ПотокXML, ПараметрыВыгрузки); // пишем дерево в поток
	ТекстДляЗаписи = ПотокXML.Закрыть(); // получаем текст XML
	
	Возврат ТекстДляЗаписи;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ДобавитьОшибкуФормированияРеглОтчета(РезультатВыгрузки, ТекстОшибки) Экспорт
	
	Ошибки = Неопределено;
	
	Если НЕ РезультатВыгрузки.Свойство("Ошибки", Ошибки)
		ИЛИ Ошибки = Неопределено Тогда
		Ошибки = Новый Массив;
		РезультатВыгрузки.Вставить("Ошибки", Ошибки);
	КонецЕсли;
	
	Ошибки.Добавить(ТекстОшибки);
	
КонецПроцедуры

Функция НовыйРезультатВыгрузкиРеглОтчета() Экспорт
	
	Результат = Новый Структура;
	
	Результат.Вставить("ТипФайлаВыгрузки", "");
	Результат.Вставить("ТаблицаСообщений", НовыйТаблицаСообщенийОбОшибкахВыгрузки());
	Результат.Вставить("РеглОтчетВыгружен", Ложь);
	Результат.Вставить("ИмяФайлаВыгрузки", "");
	Результат.Вставить("АдресФайлаВыгрузки", "");
	Результат.Вставить("КодировкаФайлаВыгрузки", "");
	Результат.Вставить("Ошибки", Новый Массив);
	
	Возврат Результат;
	
КонецФункции

Функция НовыйТаблицаСообщенийОбОшибкахВыгрузки() Экспорт
	
	ТаблицаСообщений = Новый ТаблицаЗначений;
	
	ТаблицаСообщений.Колонки.Добавить("ОтчетДок");
	ТаблицаСообщений.Колонки.Добавить("Отчет",     Новый ОписаниеТипов("Строка"));
	ТаблицаСообщений.Колонки.Добавить("Раздел",    Новый ОписаниеТипов("Строка"));
	ТаблицаСообщений.Колонки.Добавить("ИмяЯчейки", Новый ОписаниеТипов("Строка"));
	ТаблицаСообщений.Колонки.Добавить("Описание",  Новый ОписаниеТипов("Строка"));
	ТаблицаСообщений.Колонки.Добавить("Страница",  Новый ОписаниеТипов("Строка"));
		
	Возврат ТаблицаСообщений;
	
КонецФункции

Функция ПредставительЯвляетсяФизЛицом(Представитель) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Представитель) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Метаданные.Справочники.Найти("ФизическиеЛица") = Неопределено Тогда
		Возврат Представитель.ВидКонтрагента = Перечисления.ЮридическоеФизическоеЛицо.ФизическоеЛицо;
	Иначе
		Возврат ТипЗнч(Представитель) = Тип("СправочникСсылка.ФизическиеЛица");
	КонецЕсли;
	
КонецФункции

Функция СвернутьДанныеТабличногоПоля(Данные) Экспорт
	
	ТП = Новый ТаблицаЗначений;
	ТП.Колонки.Добавить("Имя");
	ТП.Колонки.Добавить("Кол");
	ТП.Колонки.Добавить("Номер");
	ТП.Колонки.Добавить("Знач");
	
	Для Каждого Стр Из Данные Цикл
		НоваяСтрока = ТП.Добавить();
		НоваяСтрока.Имя = Стр.Ключ;
		НоваяСтрока.Кол = 1;
		НоваяСтрока.Знач = Стр.Значение;
	КонецЦикла;
	
	ТП.Сортировать("Имя");
	
	Для Каждого Стр Из ТП Цикл
		Имя = Стр.Имя;
		
		Если ЭтоКодПоказателяП(Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		ПризнакКвадратика = Ложь; // Признак того, что значение является частью другого значения.
		
		НомерСимвола = СтрДлина(Имя);
		Было_ = Ложь; // Признак того, что в текущем наименовании показателя уже встречался символ "_".
		БылаЦифра = Ложь;
		
		Пока НомерСимвола > 0 Цикл
			
			Симв = Сред(Имя, НомерСимвола, 1);
			КодСимв = КодСимвола(Симв);
			
			Если (КодСимв >= КодСимвола("0") И КодСимв <= КодСимвола("9")) ИЛИ (Симв = "_") Тогда
				
				Если Симв = "_" Тогда
					Если БылаЦифра Тогда
						
						ПризнакКвадратика = Истина;
						НомерСимвола = НомерСимвола - 1;
						Прервать;
						
					КонецЕсли;
				Иначе
					БылаЦифра = Истина;
				КонецЕсли;
				
			Иначе
				Прервать;
			КонецЕсли;
			
			НомерСимвола = НомерСимвола - 1;
			
		КонецЦикла;
		
		Если БылаЦифра Тогда
			Корень = Лев(Стр.Имя, НомерСимвола);
			Номер = Сред(Стр.Имя, НомерСимвола + 1);
			Попытка
				Стр.Номер = Число( ?( Лев(Номер, 1) = "_", Сред(Номер, 2), Номер));
			Исключение
				
				Сообщение = Новый СообщениеПользователю;

				Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Ошибки преобразования номера из окончания: %1 === %2'"), Корень, Номер);
	
				Сообщение.Сообщить();
				
			КонецПопытки;
			Стр.Имя = Корень;
		КонецЕсли;
		
	КонецЦикла;
	
	ТП.Сортировать("Имя, Номер");
	
	ТП2 = ТП.Скопировать();
	ТП2.Свернуть("Имя", "Кол");
	
	Для Каждого Стр Из ТП2 Цикл
		Если Стр.Имя = "П" ИЛИ Стр.Имя = "ЧНП" Тогда
			Продолжить;
		КонецЕсли;
		Если Стр.Кол > 1 Тогда
			ЗначениеСводногоПоказателя = ВычислитьЗначениеПоКорню(ТП, Стр.Имя);
			НайдЗнач = Неопределено;
			Если НЕ Данные.Свойство(Стр.Имя, НайдЗнач) Тогда
				Данные.Вставить(Стр.Имя, ЗначениеСводногоПоказателя);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ВычислитьЗначениеПоКорню(Табл, Корень)
	
	Табл2 = Табл.Скопировать();
	ИтоговоеЗначение = "";
	
	Для Каждого Стр Из Табл2 Цикл
		
		Имя = Стр.Имя;
		Если Имя = Корень Тогда
			ИтоговоеЗначение = ИтоговоеЗначение + Стр.Знач;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ((ВРЕГ(Лев(Корень, 4)) = "ДАТА") ИЛИ (СтрЧислоВхождений(Корень, "Дата") <> 0)) 
		И (((СтрДлина(ИтоговоеЗначение)=8) ИЛИ (СтрДлина(ИтоговоеЗначение)=6)) ИЛИ (ПустаяСтрока(ИтоговоеЗначение)))Тогда
		
		Если ПустаяСтрока(ИтоговоеЗначение) Тогда
			ИтоговоеЗначение = "00.00.0000";
		Иначе
			ИтоговоеЗначение = Лев(ИтоговоеЗначение, 2) + "." + Сред(ИтоговоеЗначение, 3, 2) + "." + Сред(ИтоговоеЗначение, 5);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ИтоговоеЗначение;
	
КонецФункции

Процедура СообщитьВТаблицуСообщений(Владелец, Описание, Раздел, ИмяЯчейки = "", ФИО = "") Экспорт
	
	НовСтр = Владелец.ТаблицаСообщений.Добавить();
	НовСтр.Раздел    = Раздел;
	НовСтр.ИмяЯчейки = ИмяЯчейки;
	НовСтр.Описание  = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = '%1'"), Описание);
	НовСтр.Страница  = ФИО;
	
КонецПроцедуры

Функция ЭтоКодПоказателяП(КодПок)
	
	Если СтрДлина(КодПок) < 13 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Пок = СокрЛП(КодПок);
	
	Если Сред(Пок, 1, 1) = "П" Тогда
		
		Для Сч = 2 По 13 Цикл
			
			КодСимв = КодСимвола(Пок, Сч);
			
			Если НЕ ((КодСимв >= КодСимвола("0")) И (КодСимв <= КодСимвола("9"))) Тогда
				Возврат Ложь;
			КонецЕсли;
			
		КонецЦикла;
		
		Возврат Истина;
		
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции


Функция ЧислоПоФормату(Значение, СтрокаФормата, УдалитьНезначащиеНулиПослеРазделителя = Ложь) Экспорт 
	
	ЗначениеПоФормату = СокрЛП(Формат(?(Значение = Неопределено, 0, Значение), СтрокаФормата));
	
	Если  УдалитьНезначащиеНулиПослеРазделителя Тогда
		
		Разд = ".";
		
		ПозРазд = СтрНайти(ЗначениеПоФормату, Разд);
		Если ПозРазд > 0 Тогда
			
			ЦелаяЧасть = Лев(ЗначениеПоФормату, ПозРазд - 1);
			ДробнаяЧасть = Сред(ЗначениеПоФормату, ПозРазд + 1);
			Для Сч = 1 По СтрДлина(ДробнаяЧасть) Цикл
				Если Прав(ДробнаяЧасть, 1) <> "0" Тогда
					Прервать;
				КонецЕсли;
				ДробнаяЧасть = Лев(ДробнаяЧасть, СтрДлина(ДробнаяЧасть) - 1);
			КонецЦикла;
			
			ЗначениеПоФормату = ЦелаяЧасть + ?(ПустаяСтрока(ДробнаяЧасть), "", Разд + ДробнаяЧасть);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ЗначениеПоФормату;
	
КонецФункции

#КонецОбласти
