#Область ПрограммныйИнтерфейс

// Версия библиотеки
// 
// Возвращаемое значение:
//  Строка - Версия библиотеки
Функция ВерсияБиблиотеки() Экспорт
	
	Возврат "1.1.34.26";
	
КонецФункции

// Версия подсистемы
// 
// Параметры:
//  Редакция - Строка - Редакция
// 
// Возвращаемое значение:
//  Строка - Версия подсистемы
Функция ВерсияПодсистемы(Редакция = "1") Экспорт
	
	Разделитель = ".";
	ВерсияБиблиотеки = ВерсияБиблиотеки();
	ЧастиВерсииБиблиотеки = СтрРазделить(ВерсияБиблиотеки, Разделитель);
	
	ЧастиВерсииБиблиотеки[0] = Редакция;
	
	Возврат СтрСоединить(ЧастиВерсииБиблиотеки, Разделитель);
	
КонецФункции

// см. ОбщегоНазначенияПереопределяемый.ПриДобавленииПараметровРаботыКлиента
Процедура ПриДобавленииПараметровРаботыКлиента(Параметры) Экспорт
	
	ДобавитьПараметрВыборТипПодписиБСП = Ложь;
	
	Если ПодсистемаСуществует("ИСМП") Тогда
		ДобавитьПараметрВыборТипПодписиБСП = Истина;
		МодульОбщегоНазначенияИСМП = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияИСМП");
		МодульОбщегоНазначенияИСМП.ПриДобавленииПараметровРаботыКлиента(Параметры);
	КонецЕсли;
	
	Если ПодсистемаСуществует("ЗЕРНО") Тогда
		
		ДобавитьПараметрВыборТипПодписиБСП = Истина;
		
		МодульИнтеграцияЗЕРНО = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияЗЕРНО");
		МодульИнтеграцияЗЕРНО.ПриДобавленииПараметровРаботыКлиента(Параметры);
		
	КонецЕсли;
	
	Если ДобавитьПараметрВыборТипПодписиБСП Тогда
		
		ВерсияБСП = СтандартныеПодсистемыСервер.ВерсияБиблиотеки();
		
		ИменаПараметров = ОбщегоНазначенияИСКлиентСерверПовтИсп.ИменаПараметровРаботыКлиентаВыборТипаПодписиБСП();
		Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияБСП, "3.1.7.247") >= 0 Тогда
			Параметры.Вставить(ИменаПараметров.ИмяПараметраПриложения, ИменаПараметров.ЗначениеПараметраВыборТипаПодписиИспользуетКонструктор);
		ИначеЕсли ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияБСП, "3.1.7.61") >= 0 Тогда
			Параметры.Вставить(ИменаПараметров.ИмяПараметраПриложения, ИменаПараметров.ЗначениеПараметраВыборТипаПодписиЗадаетсяПеречислением);
		Иначе
			Параметры.Вставить(ИменаПараметров.ИмяПараметраПриложения, ИменаПараметров.ЗначениеПараметраВыборТипаПодписиНеПоддерживается);
		КонецЕсли;
	
	КонецЕсли;
	
КонецПроцедуры

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
// Параметры:
//  ИдентификаторНазначения    - УникальныйИдентификатор, Неопределено - уникальный идентификатор формы для показа сообщения.
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Примеры : см ОбщегоНазначения.СообщитьПользователю.
//
//@skip-check method-too-many-params
Процедура СообщитьПользователюВФорму(
		Знач ИдентификаторНазначения = Неопределено,
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Если ИдентификаторНазначения <> Неопределено Тогда
		Сообщение.ИдентификаторНазначения = ИдентификаторНазначения;
	КонецЕсли;
	
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
	Если КлючДанных <> Неопределено
		И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Заполняет представление регламентного задания (реквизиты ЗаданиеАктивно, ТекстРасписания)
//
// Параметры:
//  Задание				 - РегламентноеЗадание, Неопределено - регламентное задание представление которого необходимо получить
//  ТекстРасписания		 - Строка - представление расписания (выходной)
//  РасписаниеАктивно	 - Булево - использование задания (выходной)
//
Процедура ПолучитьТекстЗаголовкаИРасписанияРегламентнойНастройки(Задание, ТекстРасписания, РасписаниеАктивно) Экспорт
	
	РасписаниеАктивно = Ложь;
	
	Если Задание = Неопределено Тогда
		
		ТекстРасписания = НСтр("ru = '<Расписание не задано>'");
		
	Иначе
		
		Если Задание.Использование Тогда
			РасписаниеАктивно = Истина;
			ТекстРасписания = СтрШаблон(НСтр("ru = 'Расписание: %1'"), Строка(Задание.Расписание));
		Иначе
			ТекстРасписания = СтрШаблон(НСтр("ru = 'Расписание (НЕ АКТИВНО): %1'"), Строка(Задание.Расписание));
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает менеджер (модуль менеджера или общий модуль) по полному имени метаданных
// 
// Параметры:
//   ПолноеИмя - Строка - полное имя объекта для получения модуля менеджера.
//
// Возвращаемое значение:
//   СправочникМенеджер, ДокументМенеджер, ОбщийМодуль - менеджер объекта для библиотеки
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	МенеджерОбъекта = Неопределено;
	ОбщегоНазначенияИСПереопределяемый.ПриОпределенииМенеджераОбъектаПоПолномуИмени(МенеджерОбъекта, ПолноеИмя);
	
	Если МенеджерОбъекта = Неопределено Тогда
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
	КонецЕсли;
	
	Возврат МенеджерОбъекта;
	
КонецФункции

// Возвращает менеджер (модуль менеджера или общий модуль) объекта по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
// См. также ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, менеджер которого требуется получить.
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ОбработкаМенеджер, РегистрСведенийМенеджер - менеджер объекта.
//
// Пример:
//  МенеджерСправочника = ОбщегоНазначения.МенеджерОбъектаПоСсылке(СсылкаНаОрганизацию);
//
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	МенеджерОбъекта = Неопределено;
	ОбщегоНазначенияИСПереопределяемый.ПриОпределенииМенеджераОбъектаПоСсылке(МенеджерОбъекта, Ссылка);
	
	Если МенеджерОбъекта = Неопределено Тогда
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка);
	КонецЕсли;
	
	Возврат МенеджерОбъекта;
	
КонецФункции

// Право определяемого типа.
// 
// Параметры:
//  ОпределяемыйТип  - ОбъектМетаданныхОпределяемыйТип - Определяемый тип
//  Право - Строка - Право
// 
// Возвращаемое значение:
//  Булево - Право определяемого типа
Функция ПравоОпределяемогоТипа(ОпределяемыйТип, Право) Экспорт
	
	Для Каждого ВозможныйТип Из ОпределяемыйТип.Тип.Типы() Цикл
		МетаданныеТипа = Метаданные.НайтиПоТипу(ВозможныйТип);
		Если МетаданныеТипа <> Неопределено Тогда
			Если ПравоДоступа(Право, МетаданныеТипа) Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция ХэшСуммаСтроки(СтрокаДляРасчетаХеша) Экспорт
	
	ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
	ХешированиеДанныхОбъект.Добавить(СтрокаДляРасчетаХеша);
	
	Возврат Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
	
КонецФункции

// Текст исключения обработки статуса
//
// Параметры:
//  Документ - ДокументСсылка - Документ.
//  Операция - ПеречислениеСсылка - Операция.
// 
// Возвращаемое значение:
//  Строка - Текст исключения.
//
Функция ТекстИсключенияОбработкиСтатуса(Документ, Операция) Экспорт
	
	Возврат СтрШаблон(
		НСтр("ru = 'При изменении статуса документа %1 не обработана операция %2'"),
		Документ,
		Операция);
		
КонецФункции

// Работа с регистром "ОписаниеНоменклатурыИС", при незаполненном переопределении библиотечный сценарий
//
// Параметры:
//  ТекстЗапроса           - Строка - текст запроса с регистром "ОписаниеНоменклатурыИС" (исходящий),
//  ПутьКРегистру          - Строка - имя таблицы регистра "ОписаниеНоменклатурыИС" в запросе,
//  ПутьКПолюНоменклатура  - Строка - путь к номенклатуре в запросе
//  ПутьКИсточникуОписания - Строка - путь к источнику описания 
Процедура ОбновитьТекстЗапросаСРегистромОписаниеНоменклатурыИС(ТекстЗапроса, ПутьКРегистру, ПутьКПолюНоменклатура, ПутьКИсточникуОписания = "") Экспорт
	
	ОбщегоНазначенияИСПереопределяемый.ОбновитьТекстЗапросаСРегистромОписаниеНоменклатурыИС(ТекстЗапроса,
		ПутьКРегистру, ПутьКПолюНоменклатура, ПутьКИсточникуОписания);
	// Определение источника описания
	ИмяПоляЗамены = "&ПутьКИсточникуОписания";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПоляЗамены, ПутьКИсточникуОписания);
	// Соединение с регистром
	ИмяПоляЗамены = "&ТоварыОписаниеНоменклатурыИС";
	ТекстЗамены = СтрШаблон("%2.Номенклатура = %1", ПутьКПолюНоменклатура, ПутьКРегистру);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПоляЗамены, ТекстЗамены);
	// Получение признака Произвольная единица учета
	ИмяПоляЗамены = "&ПроизвольнаяЕдиницаУчета";
	ТекстЗамены = СтрШаблон("ЕСТЬNULL(%1.КоличествоВПотребительскойУпаковке, 1) <> 1
	|	ИЛИ ЕСТЬNULL(%1.ЕмкостьПотребительскойУпаковки, 1) > 1", ПутьКРегистру);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПоляЗамены, ТекстЗамены);
	// Получение признака Требует взвешивания
	ИмяПоляЗамены = "&ТребуетВзвешивания";
	ТекстЗамены = СтрШаблон("ЕСТЬNULL(%1.КоличествоВПотребительскойУпаковке, 1) = 0", ПутьКРегистру);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ИмяПоляЗамены, ТекстЗамены);
	
КонецПроцедуры

// Работа с регистром "ОписаниеНоменклатурыИС" при использовании источника описания номенклатуры отличного от ссылки 
//   на номенклатуру:
//   * Дополняет входящий массив классами номенклатуры,
//   * Возвращает соответствие добавленных классов и исходной номенклатуры.
//
// Параметры:
//  Номенклатура - Массив Из ОпределяемыйТип.ИсточникОписанияноменклатурыИС - Источник описания номенклатуры.
// Возвращаемое значение:
//  Соответствие из КлючИЗначение - описание добавленных классов номенклатуры:
//   * Ключ - ОпределяемыйТип.ИсточникОписанияноменклатурыИС - Источник описания номенклатуры,
//   * Значение - Массив Из ОпределяемыйТип.номенклатура - номенклатура из входящего массива
Функция ДополнитьИсточникиОписанияНоменклатуры(Номенклатура) Экспорт
	
	СоответстиеИсточникаНоменклатуре = Новый Соответствие;
	ОбщегоНазначенияИСПереопределяемый.ДополнитьИсточникиОписанияНоменклатуры(Номенклатура, СоответстиеИсточникаНоменклатуре);
	Для Каждого КлючИЗначение Из СоответстиеИсточникаНоменклатуре Цикл
		Номенклатура.Добавить(КлючИЗначение.Ключ);
	КонецЦикла;
	Возврат СоответстиеИсточникаНоменклатуре;
	
КонецФункции

// Получить из текста JSON структуру.
// 
// Параметры:
// 	ТекстJSON                    - Строка - Текст JSON.
// 	ПреобразовыватьВСоответствие - Булево - Признак преобразования в соответствие.
// Возвращаемое значение:
// 	Структура, Неопределено, Произвольный - Результат преобразования JSON.
Функция ТекстJSONВОбъект(ТекстJSON, ПреобразовыватьВСоответствие = Ложь) Экспорт
	
	Чтение = Новый ЧтениеJSON;
	Чтение.УстановитьСтроку(ТекстJSON);
	
	Попытка
		РезультатРазбора = ПрочитатьJSON(Чтение, ПреобразовыватьВСоответствие);
	Исключение
		РезультатРазбора = Неопределено;
	КонецПопытки;
	
	Возврат РезультатРазбора;
	
КонецФункции

// Формирует из структуры текст JSON
// 
// Параметры:
// 	Структура                    - Структура - Произвольная структура данных
//  УдалитьПробелыИПереносыСтрок - Булево    - признак использования отступов, по умолчанию Истина.
// Возвращаемое значение:
// 	Строка - Текст JSON
Функция ОбъектВТекстJSON(Структура, УдалитьПробелыИПереносыСтрок = Ложь) Экспорт
	
	Если УдалитьПробелыИПереносыСтрок Тогда
		ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Нет, "");
	Иначе
		ПараметрыЗаписиJSON = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, "  ");
	КонецЕсли;
	
	ЗаписьJSON = Новый ЗаписьJSON();
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON);
	
	ЗаписатьJSON(ЗаписьJSON, Структура);
	
	ТекстJSON = ЗаписьJSON.Закрыть();
	
	Возврат ТекстJSON;
	
КонецФункции

// Сформировать текст ошибки по результату отправки запроса.
//
// Параметры:
//  URLЗапроса - Строка - Заголовок ошибки, например: Параметры авторизации не получены из ИС МОТП.
//  РезультатОтправкиЗапроса - Структура - Результат отправки HTTP-запроса:
//  * ЗапросОтправлен             - Булево - признак того, что сообщение отправлено.
//  * ОтветПолучен                - Булево - признак того, что сообщение получено.
//  * КодСостояния                - Число  - Код состояния HTTP-запроса.
//  * ТекстОшибки                 - Строка - текст ошибки, если таковая возникла.
//  * ТекстВходящегоСообщенияJSON - Строка - текст ответа, на отправленное сообщение.
// Возвращаемое значение:
//  Строка - Текст ошибки.
Функция ТекстОшибкиПоРезультатуОтправкиЗапроса(URLЗапроса, РезультатОтправкиЗапроса) Экспорт
	
	Если РезультатОтправкиЗапроса.ОтветПолучен Тогда

		ТекстОшибки = СтрШаблон(
			НСтр("ru='При выполнении запроса %1 возникла ошибка.
				     |Код состояния HTTP: %2.
				     |Текст ошибки: %3.'"),
			URLЗапроса,
			РезультатОтправкиЗапроса.КодСостояния,
			ПредставлениеОшибкиИзJSON(РезультатОтправкиЗапроса.ТекстВходящегоСообщенияJSON));
			
	Иначе
		
		ТекстОшибки = СтрШаблон(
			НСтр("ru='При отправке запроса %1 возникла ошибка.
				     |Текст ошибки: %2.'"),
			URLЗапроса,
			РезультатОтправкиЗапроса.ТекстОшибки);

	КонецЕсли;
	
	Возврат ТекстОшибки;

КонецФункции

Функция ЭтоРасширеннаяВерсияГосИС(Подсистема = Неопределено) Экспорт
	
	Если Подсистема = Неопределено Тогда
		Подсистема = "БазоваяФункциональность";
	КонецЕсли;
	
	Возврат ОбщегоНазначения.ПодсистемаСуществует(СтрШаблон("ГосИС.%1.Расширенная", Подсистема));
	
КонецФункции

// Выполняет поиск организации предприятия по ИНН и/или КПП.
//
// Параметры:
//   ИНН - Строка - ИНН искомой организации,
//   КПП - Строка - КПП искомой организации.
// 
// Возвращаемое значение:
//   ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено - найденная организация
//
Функция ОрганизацияПоИННКПП(ИНН, КПП) Экспорт
	
	Организация = Неопределено;
	ОбщегоНазначенияИСПереопределяемый.ЗаполнитьОрганизациюПоИННКПП(Организация, ИНН, КПП);
	Возврат Организация;
	
КонецФункции

// Получает список доступных для использования организаций.
//
//Возвращаемое значение:
//   СписокЗначений Из ОпределяемыйТип.Организация - ссылки на организации:
//    * Значение      - ОпределяемыйТип.Организация - ссылка на организацию.
//    * Представление - Строка - наименование организации.
Функция ДоступныеОрганизации() Экспорт
	
	СписокОрганизаций = Новый Массив;
	ОбщегоНазначенияИСПереопределяемый.ПриОпределенииСпискаОрганизацийНедоступныхДляВыбора(СписокОрганизаций);
	
	Организации = Новый СписокЗначений;
	
	ШаблонЗапроса = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Организации.Ссылка       КАК Ссылка,
	|	Организации.Наименование КАК Наименование
	|ИЗ
	|	%1 КАК Организации
	|ГДЕ
	|	НЕ (Организации.Ссылка В (&СписокОрганизаций))
	|";
	
	Объединение = "
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|";

	Порядок = "
	|УПОРЯДОЧИТЬ ПО
	|	Организации.Наименование";
	
	ТекстЗапроса = "";
	ТипыОрганизаций = Метаданные.ОпределяемыеТипы.Организация.Тип.Типы();
	ПерваяИтерация = Истина;
	
	Для Каждого Тип Из ТипыОрганизаций Цикл
		
		ПолноеИмя = Метаданные.НайтиПоТипу(Тип).ПолноеИмя();
		ТекстЗапроса = ТекстЗапроса + СтрШаблон(ШаблонЗапроса, ПолноеИмя) + ?(Не ПерваяИтерация, Объединение, "");
		ПерваяИтерация = Ложь;
		
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса + Порядок;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("СписокОрганизаций", СписокОрганизаций);
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Организации.Добавить(Выборка.Ссылка, Выборка.Наименование);
	КонецЦикла;
	
	Возврат Организации;
	
КонецФункции

// Возвращает значение по умолчанию переданного определяемого типа.
// 
// Параметры:
//  ОпределяемыйТипИлиИмяТипа - Строка, ОбъектМетаданныхОпределяемыйТип - Определяемый тип или имя типа
// 
// Возвращаемое значение:
//  Произвольный, Неопределено - Пустое значение определяемого типа
Функция ПустоеЗначениеОпределяемогоТипа(ОпределяемыйТипИлиИмяТипа) Экспорт
	
	// Обход ошибки платформы:
	// в некоторых случаях в фоновых заданиях для ссылочных типов определяемого типа
	// приведение значения выполняется не корректно
	// Справочники.СерииНоменклатуры.ПустаяСсылка() <> Метаданные.ОпределяемыеТипы.СерияНоменклатуры.Тип.ПривестиЗначение()
	
	Если ТипЗнч(ОпределяемыйТипИлиИмяТипа) = Тип("Строка") Тогда
		ОпределяемыйТип = Метаданные.ОпределяемыеТипы[ОпределяемыйТипИлиИмяТипа];
	Иначе
		ОпределяемыйТип = ОпределяемыйТипИлиИмяТипа;
	КонецЕсли;
	
	ТипыОпределяемогоТипа = ОпределяемыйТип.Тип.Типы();
	
	Если ТипыОпределяемогоТипа.Количество() = 1 Тогда
		
		ТипОпределяемогоТипа = ТипыОпределяемогоТипа[0];
		
		Если ТипОпределяемогоТипа = Неопределено Тогда
			Возврат Неопределено;
		ИначеЕсли ОбщегоНазначения.ЭтоСсылка(ТипОпределяемогоТипа) Тогда
			Возврат Новый (ТипОпределяемогоТипа)
		КонецЕсли;
		
		Возврат ОпределяемыйТип.Тип.ПривестиЗначение();
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Определяет необходимость указания серии для маркируемой продукции.
// 
// Параметры:
//  Товар - Структура - данные строки номенклатуры. Содержит обязательные поля:
//   * Номенклатура   - ОпределяемыйТип.Номенклатура               - номенклатура,
//   * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - характеристика.
//  ПараметрыСканирования - (См. ШтрихкодированиеОбщегоНазначенияИСКлиент.ПараметрыСканирования).
// Возвращаемое значение:
//  Булево - Истина, если требуется указать серию.
Функция ТребуетсяВыборСерии(Товар, ПараметрыСканирования) Экспорт
	
	Если ПараметрыСканирования.ДополнительныеПараметры.Свойство("ДанныеУточнения")
			И ПараметрыСканирования.ДополнительныеПараметры.ДанныеУточнения.Свойство("Серия") Тогда
		Возврат ЗначениеЗаполнено(ПараметрыСканирования.ДополнительныеПараметры.ДанныеУточнения.Серия);
	КонецЕсли;
	
	ТребуетсяВыбор = Ложь;
	
	Операция = Неопределено;
	Если ШтрихкодированиеОбщегоНазначенияИС.ДопустимаПродукцияИСМП(ПараметрыСканирования)
			Или ШтрихкодированиеОбщегоНазначенияИС.ДопустимаТабачнаяПродукция(ПараметрыСканирования) Тогда
		Операция = ПараметрыСканирования.ВидОперацииИСМП;
	ИначеЕсли ПараметрыСканирования.ДопустимыеВидыПродукции.Найти(Перечисления.ВидыПродукцииИС.Алкогольная) <> Неопределено Тогда
		Операция = ПараметрыСканирования.Операция;
	КонецЕсли;
	
	ПараметрыУказанияСерий = ПараметрыСканирования.ПараметрыУказанияСерий;
	
	ДанныеДляРасчетаСерии  = Новый Структура;
	ДанныеДляРасчетаСерии.Вставить("Склад",          ПараметрыСканирования.Склад);
	ДанныеДляРасчетаСерии.Вставить("Операция",       Операция);
	ДанныеДляРасчетаСерии.Вставить("Номенклатура",   Товар.Номенклатура);
	ДанныеДляРасчетаСерии.Вставить("Характеристика", Товар.Характеристика);
	
	ОбщегоНазначенияИСПереопределяемый.ПриОпределенииНеобходимостиВыбораСерии(
		ДанныеДляРасчетаСерии, ПараметрыУказанияСерий, ТребуетсяВыбор, Неопределено, ПараметрыСканирования.КэшированныеЗначения);
	
	Возврат ТребуетсяВыбор;
	
КонецФункции

Функция ЕстьПродукцияТребующаяВзвешивания() Экспорт
	
	Используется = Ложь;
	
	Если ОбщегоНазначенияИСКлиентСервер.ЭтоРасширеннаяВерсияГосИС() Тогда 
		
		МодульИнтеграцияИС = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияИС");
		Используется = МодульИнтеграцияИС.ЕстьПродукцияТребующаяВзвешивания();
		
	Иначе
		
		ОбщегоНазначенияИСПереопределяемый.ИспользованиеПродукцииТребующейВзвешивания(Используется);
		
	КонецЕсли;
	
	Возврат Используется;
	
КонецФункции

// Списывает из остатка вскрытых потребительских упаковок количество частично проданного товара.
// 
// Параметры:
//  ИсточникДанных - ДанныеФормыСтруктура, ДокументОбъект, Структура - объект формы, объект документа или произвольная структура,
//                   в которой находятся данные штрихкодов упаковок. Источник должен иметь поля и коллекции с именами,
//                   указанными в параметрах сканирования: ИмяТабличнойЧастиШтрихкодыУпаковок,
//                   ИмяКолонкиШтрихкодУпаковки, ИмяКолонкиЧастичноеВыбытиеКоличество
//  ПараметрыСканирования - см. ШтрихкодированиеОбщегоНазначенияИС.ПараметрыСканирования
Процедура СписатьОстатокПоВскрытымПотребительскимУпаковкам(ИсточникДанных, ПараметрыСканирования) Экспорт
	
	Если Не ШтрихкодированиеОбщегоНазначенияИС.ТребуетсяЧастичноеВыбытие(ПараметрыСканирования)
		Или Не ЗначениеЗаполнено(ПараметрыСканирования.ИмяТабличнойЧастиШтрихкодыУпаковок)
		Или Не ЗначениеЗаполнено(ПараметрыСканирования.ИмяКолонкиЧастичноеВыбытиеКоличество) Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	НоменклатураОписания      = Новый Массив;
	НоменклатураШтрихкодов    = Новый Соответствие();
	КодыМаркировкиДляСписания = Новый ТаблицаЗначений();
	КодыМаркировкиДляСписания.Колонки.Добавить("ШтрихкодУпаковки", Метаданные.РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.Измерения.КодМаркировки.Тип);
	КодыМаркировкиДляСписания.Колонки.Добавить("Количество",       Метаданные.РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.Ресурсы.Остаток.Тип);
	
	ШтрихкодыУпаковок = ИсточникДанных[ПараметрыСканирования.ИмяТабличнойЧастиШтрихкодыУпаковок];
	Для Каждого СтрокаДанных Из ШтрихкодыУпаковок Цикл
		
		КоличествоЧастичногоВыбытия = СтрокаДанных[ПараметрыСканирования.ИмяКолонкиЧастичноеВыбытиеКоличество];
		Если Не ЗначениеЗаполнено(КоличествоЧастичногоВыбытия) Тогда
			Продолжить;
		КонецЕсли;
		
		ШтрихкодУпаковки = СтрокаДанных[ПараметрыСканирования.ИмяКолонкиШтрихкодУпаковки];
		
		НоваяСтрока = КодыМаркировкиДляСписания.Добавить();
		НоваяСтрока.ШтрихкодУпаковки = ШтрихкодУпаковки;
		НоваяСтрока.Количество       = КоличествоЧастичногоВыбытия;
		
		Если ПараметрыСканирования.РежимБРМК Тогда
			Если СтрокаДанных[ПараметрыСканирования.ИмяКолонкиЧастичноеВыбытиеВариантУчета] = Перечисления.ВариантыУчетаЧастичногоВыбытияИС.НастроеннаяНоменклатура Тогда
				НоменклатураПоШтрихкоду = СтрокаДанных[ПараметрыСканирования.ИмяКолонкиЧастичноеВыбытиеНоменклатура];
			Иначе
				НоменклатураПоШтрихкоду = СтрокаДанных.Номенклатура;
			КонецЕсли;
			НоменклатураОписания.Добавить(НоменклатураПоШтрихкоду);
			НоменклатураШтрихкодов.Вставить(ШтрихкодУпаковки, НоменклатураПоШтрихкоду);
		КонецЕсли;
		
	КонецЦикла;
	
	Если КодыМаркировкиДляСписания.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	КодыМаркировкиДляСписания.Свернуть("ШтрихкодУпаковки", "Количество");
	
	Если Не ПараметрыСканирования.РежимБРМК Тогда
		НоменклатураШтрихкодов = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(
			КодыМаркировкиДляСписания.ВыгрузитьКолонку("ШтрихкодУпаковки"), "Номенклатура");
		Для Каждого КлючИЗначение Из НоменклатураШтрихкодов Цикл
			НоменклатураОписания.Добавить(КлючИЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	
	ОписанияНоменклатуры = ОписаниеНоменклатуры(НоменклатураОписания);
	
	Блокировка = Новый БлокировкаДанных();
	
	ЭлементБлокировки = Блокировка.Добавить(Метаданные.РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ПолноеИмя());
	ЭлементБлокировки.ИсточникДанных = КодыМаркировкиДляСписания;
	ЭлементБлокировки.ИспользоватьИзИсточникаДанных(
		Метаданные.РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.Измерения.КодМаркировки.Имя, "ШтрихкодУпаковки");
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка.Заблокировать();
		
		ДанныеПодключений = РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ВскрытыеПотребительскиеУпаковкиПоКодуМаркировки(
			КодыМаркировкиДляСписания.ВыгрузитьКолонку("ШтрихкодУпаковки"), Истина);
		
		Для Каждого СтрокаТаблицы Из КодыМаркировкиДляСписания Цикл
			
			ДанныеПодключения = ДанныеПодключений[СтрокаТаблицы.ШтрихкодУпаковки];
			
			Если ДанныеПодключения = Неопределено
				Или ДанныеПодключения.ВидПродукции = Перечисления.ВидыПродукцииИС.Алкогольная
				Или Не ЗначениеЗаполнено(ДанныеПодключения.ВидПродукции) Тогда
				Продолжить;
			КонецЕсли;
			
			Номенклатура         = НоменклатураШтрихкодов[СтрокаТаблицы.ШтрихкодУпаковки];
			ОписаниеНоменклатуры = ОписанияНоменклатуры[Номенклатура];
			
			Если ЗначениеЗаполнено(ОписаниеНоменклатуры.ЕмкостьПотребительскойУпаковки)
				И ЗначениеЗаполнено(ОписаниеНоменклатуры.КоличествоВПотребительскойУпаковке)
				И ОписаниеНоменклатуры.ВариантЧастичногоВыбытия = Перечисления.ВариантыУчетаЧастичногоВыбытияИС.ТекущаяНоменклатура Тогда
				Коэффициент = 1 / (ОписаниеНоменклатуры.КоличествоВПотребительскойУпаковке / ОписаниеНоменклатуры.ЕмкостьПотребительскойУпаковки);
			Иначе
				Коэффициент = 1;
			КонецЕсли;
			
			ДанныеЗаписиОстатка = РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ИнициализироватьДанныеВскрытияПотребительскойУпаковки();
			Если ДанныеПодключения.ВидПродукции = Перечисления.ВидыПродукцииИС.Пиво
				Или ДанныеПодключения.ВидПродукции = Перечисления.ВидыПродукцииИС.ПивоВПотребительскихУпаковках Тогда
				КоличествоРасход = СтрокаТаблицы.Количество * Коэффициент;
			Иначе
				КоличествоРасход = Окр(СтрокаТаблицы.Количество * Коэффициент);
			КонецЕсли;
			ДанныеЗаписиОстатка.Остаток = ДанныеПодключения.Остаток - КоличествоРасход;
			
			Если ДанныеЗаписиОстатка.Остаток <= 0 Тогда
				Если ДанныеПодключения.ВидПродукции = Перечисления.ВидыПродукцииИС.Пиво
					Или ДанныеПодключения.ВидПродукции = Перечисления.ВидыПродукцииИС.ПивоВПотребительскихУпаковках
					Или Не ЗначениеЗаполнено(ДанныеПодключения.ВидПродукции) Тогда
					ДанныеЗаписиОстатка.Статус = Перечисления.СтатусыВскрытыхПотребительскихУпаковокИС.Отключено;
					РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ЗаписатьВскрытиеПотребительскойУпаковки(ДанныеЗаписиОстатка, ДанныеПодключения);
				Иначе
					РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.УдалитьВскрытыеПотребительскиеУпаковки(СтрокаТаблицы.ШтрихкодУпаковки);
				КонецЕсли;
			Иначе
				РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ЗаписатьВскрытиеПотребительскойУпаковки(ДанныеЗаписиОстатка, ДанныеПодключения);
			КонецЕсли;
			
		КонецЦикла;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		
		ВызватьИсключение
		
	КонецПопытки;
	
КонецПроцедуры

// Определяет включено ли ведение учета продукции, подлежащей маркированию.
//
// Параметры:
// 	РасширеннаяВерсияГосИС - Булево
// Возвращаемое значение:
//  Булево - Истина, если учет ведется.
Функция ВедетсяУчетМаркируемойПродукции(РасширеннаяВерсияГосИС) Экспорт
	
	Возврат ОбщегоНазначенияИСПовтИсп.ВедетсяУчетМаркируемойПродукции(РасширеннаяВерсияГосИС);
	
КонецФункции

#Область РаботаСЧасовымиПоясами

Функция ДатаИзСтроки(Значение, Делитель = 1000, ПриводитьКМестномуВремени = Истина) Экспорт
	
	Если СтрНайти(Значение, "T") > 0 Тогда
		Возврат ДатаИзСтрокиISO(Значение);
	Иначе
		Возврат ОбщегоНазначенияИСКлиентСервер.ДатаИзСтрокиUNIX(Значение, Делитель, ПриводитьКМестномуВремени);
	КонецЕсли;
	
КонецФункции

Функция ДатаИзСтрокиISO(Значение) Экспорт
	
	Конвертор = РаботаСXMLИС.ОбъектXDTOПоИмениСвойства("http://gosis.1c.ru/Convertor", "query");
	Конвертор.ХранилищеДаты = РаботаСXMLИС.ОбъектXDTOПоИмениТипа(Конвертор, "ХранилищеДаты");
	
	Попытка
		Конвертор.ХранилищеДаты.Значение = Значение;
		Возврат Конвертор.ХранилищеДаты.Значение;
	Исключение
		Возврат Дата(1, 1, 1);
	КонецПопытки;
	
КонецФункции

Функция ДатаВСтрокуUNIX(Дата, Делитель = 1000) Экспорт
	
	Значение = (УниверсальноеВремя(Дата) - '19700101') * Делитель;
	
	Возврат Значение;
	
КонецФункции

#КонецОбласти

#Область ОписаниеНоменклатуры

// Возвращает новые параметры описания номенклатуры.
//
// Возвращаемое значение:
//  Структура - Инициализировать данные описания:
// * Номенклатура                        - Неопределено, ОпределяемыйТип.Номенклатура                  - Номенклатура.
// * ЕмкостьПотребительскойУпаковки      - Число                                                       - Емкость потребительской упаковки для часчтиного выбытия.
// * КоличествоВПотребительскойУпаковке  - Число                                                       - Количество учетных единиц товара в потребительской упаковке.
// * ВариантЧастичногоВыбытия            - ПеречислениеСсылка.ВариантыУчетаЧастичногоВыбытияИС         - Вариант частичного выбытия.
// * ВариантИспользованияЕдиницыХранения - ПеречислениеСсылка.ВариантыИспользованияЕдиницыХраненияИС - Вариант использования единицы измерения.
// * ПотребительскаяУпаковка             - Неопределено, ОпределяемыйТип.Упаковка                      - потребительская упаковка
// * УпаковкаЧастичногоВыбытия           - Неопределено, ОпределяемыйТип.Упаковка                      - упаковка частичного выбытия
Функция ИнициализироватьДанныеОписанияНоменклатуры() Экспорт

	ДанныеНоменклатуры = Новый Структура();
	ДанныеНоменклатуры.Вставить("Номенклатура",                        Неопределено);
	ДанныеНоменклатуры.Вставить("ЕмкостьПотребительскойУпаковки",      0);
	ДанныеНоменклатуры.Вставить("КоличествоВПотребительскойУпаковке",  1);
	ДанныеНоменклатуры.Вставить("ВариантЧастичногоВыбытия",            Перечисления.ВариантыУчетаЧастичногоВыбытияИС.ПустаяСсылка());
	ДанныеНоменклатуры.Вставить("ВариантИспользованияЕдиницыХранения", Перечисления.ВариантыИспользованияЕдиницыХраненияИС.ПотребительскаяУпаковка);
	ДанныеНоменклатуры.Вставить("ПотребительскаяУпаковка",             Неопределено);
	ДанныеНоменклатуры.Вставить("УпаковкаЧастичногоВыбытия",           Неопределено);
	
	Возврат ДанныеНоменклатуры;

КонецФункции

// Возвращает описание входящей номенклатуры. Разворачивает описание из подходящего класса номенклатуры при необходимости.
//
// Параметры:
//   Номенклатура - ОпределяемыйТип.ИсточникОписанияНоменклатурыИС, Массив Из ОпределяемыйТип.ИсточникОписанияНоменклатурыИС - 
//     номенклатура (класс номенклатуры) для которой требуется получить описание ИС
//
// Возвращаемое значение:
//   Соответствие из КлючИЗначение - номенклатура с описанием:
//    * Ключ -ОпределяемыйТип.ИсточникОписанияНоменклатурыИС - номенклатура,
//    * Значение - см. ИнициализироватьДанныеОписанияНоменклатуры.
Функция ОписаниеНоменклатуры(Знач Номенклатура) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Результат = Новый Соответствие;
	
	Если ТипЗнч(Номенклатура) = Тип("Массив") Тогда
		МассивНоменклатур = Номенклатура;
	Иначе 
		МассивНоменклатур = Новый Массив;
		МассивНоменклатур.Добавить(Номенклатура);
	КонецЕсли;

	Для Каждого ЭлементМассива Из МассивНоменклатур Цикл
		ДанныеНоменклатуры = ИнициализироватьДанныеОписанияНоменклатуры();
		Результат.Вставить(ЭлементМассива, ДанныеНоменклатуры);
	КонецЦикла;

	СоответствиеРезультатаВходящимДанным = ДополнитьИсточникиОписанияНоменклатуры(МассивНоменклатур);
	
	ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ОписаниеНоменклатурыИС.Номенклатура                        КАК Номенклатура,
		|	ОписаниеНоменклатурыИС.ЕмкостьПотребительскойУпаковки      КАК ЕмкостьПотребительскойУпаковки,
		|	ОписаниеНоменклатурыИС.КоличествоВПотребительскойУпаковке  КАК КоличествоВПотребительскойУпаковке,
		|	ОписаниеНоменклатурыИС.ВариантЧастичногоВыбытия            КАК ВариантЧастичногоВыбытия,
		|	ОписаниеНоменклатурыИС.ВариантИспользованияЕдиницыХранения КАК ВариантИспользованияЕдиницыХранения,
		|	ОписаниеНоменклатурыИС.ПотребительскаяУпаковка             КАК ПотребительскаяУпаковка,
		|	ОписаниеНоменклатурыИС.УпаковкаЧастичногоВыбытия           КАК УпаковкаЧастичногоВыбытия
		|ИЗ
		|	РегистрСведений.ОписаниеНоменклатурыИС КАК ОписаниеНоменклатурыИС
		|ГДЕ
		|	ОписаниеНоменклатурыИС.Номенклатура В (&Номенклатура)";
	ОбщегоНазначенияИСПереопределяемый.ДополнитьТекстЗапросаОписанияНоменклатуры(ТекстЗапроса);
	Запрос = Новый Запрос(ТекстЗапроса);
	
	Запрос.УстановитьПараметр("Номенклатура", МассивНоменклатур);
	Выборка = Запрос.Выполнить().Выбрать();
	
	Пока Выборка.Следующий() Цикл
		Если СоответствиеРезультатаВходящимДанным.Получить(Выборка.Номенклатура) <> Неопределено Тогда
			Для Каждого ЗначениеСоответствия Из СоответствиеРезультатаВходящимДанным[Выборка.Номенклатура] Цикл
				Для Каждого ЭлементСтруктуры Из Результат[ЗначениеСоответствия] Цикл
					Если Выборка[ЭлементСтруктуры.Ключ] <> Неопределено Тогда
			 			Результат[ЗначениеСоответствия][ЭлементСтруктуры.Ключ] = Выборка[ЭлементСтруктуры.Ключ];
					КонецЕсли;
				КонецЦикла;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Выборка.Сбросить();
	Пока Выборка.Следующий() Цикл
		Если Результат.Получить(Выборка.Номенклатура) <> Неопределено Тогда
			Для Каждого ЭлементСтруктуры Из Результат[Выборка.Номенклатура] Цикл
				Если Выборка[ЭлементСтруктуры.Ключ] <> Неопределено Тогда
		 			Результат[Выборка.Номенклатура][ЭлементСтруктуры.Ключ] = Выборка[ЭлементСтруктуры.Ключ];
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

#КонецОбласти

#Область Запросы

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//  Запрос				 - Запрос	 - запрос, параметры которого предварительно установлены.
//  ТекстыЗапроса		 - СписокЗначений	 - в списке перечислены тексты запросов и их имена.
//  ВыгрузитьРезультат	 - Булево			 - Истина, если результат запроса нужно выгрузить в таблицы значений.
// 
// Возвращаемое значение:
//  Структура - структура в которую помещены полученные таблицы
//
Функция ВыполнитьПакетЗапросов(Запрос, ТекстыЗапроса, ВыгрузитьРезультат = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	МассивТекстаЗапроса = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстаЗапроса.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли;
		МассивТекстаЗапроса.Добавить(ТекстЗапроса.Значение);
		МассивТекстаЗапроса.Добавить(ОбщегоНазначения.РазделительПакетаЗапросов());
		
	КонецЦикла;
	
	Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Символы.ПС);
	
	// Выполнение запроса.
	Результат = Запрос.ВыполнитьПакет();

	КоличествоЗапросовВПакете = 0;
	
	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		
		Если СтрЧислоВхождений(ТекстЗапроса.Значение, ";") > 0 Тогда
			Подзапросы = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТекстЗапроса.Значение, ";");
			КоличествоПодзапросов = Подзапросы.Количество();
			ИндексЗапросаРезультате = Неопределено;
			Для Индекс = -(КоличествоПодзапросов - 1) По 0 Цикл
				Если Найти(Подзапросы[-Индекс], "#РезультатЗапроса#") > 0 Тогда
					ИндексЗапросаРезультате = -Индекс;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ИндексЗапросаРезультате = Неопределено Тогда
				ИндексЗапросаРезультате = КоличествоПодзапросов - 1;
			КонецЕсли;
		Иначе
			КоличествоПодзапросов = 1;
			ИндексЗапросаРезультате = 0;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			РезультатТаблица = Результат[КоличествоЗапросовВПакете + ИндексЗапросаРезультате];
			РезультатТаблица = ?(ВыгрузитьРезультат, РезультатТаблица.Выгрузить(), РезультатТаблица);
			Таблицы.Вставить(ТекстЗапроса.Представление, РезультатТаблица);
		КонецЕсли;
		
		КоличествоЗапросовВПакете = КоличествоЗапросовВПакете + КоличествоПодзапросов;
		
	КонецЦикла;
	
	Возврат Таблицы;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область ФункцииИспользующиеПереопределение

//Формирует представление строки номенклатуры. Переопределяется.
//   Значение по-умолчанию: непустые представления составляющих, через запятую.
//
//Параметры:
//   Номенклатура   - ОпределяемыйТип.Номенклатура               - ссылка на номенклатуру.
//   Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - ссылка на характеристику номенклатуры.
//   Упаковка       - ОпределяемыйТип.Упаковка                   - ссылка на упаковку.
//   Серия          - ОпределяемыйТип.СерияНоменклатуры          - ссылка на серию номенклатуры.
//   ПоУмолчанию    - Строка                                     - Значение, если номенклатура не заполнена.
//
//Возвращаемое значение:
//   Строка - представление строки номенклатуры
//
Функция ПредставлениеНоменклатуры(Номенклатура, Характеристика, Упаковка = Неопределено, Серия = Неопределено, ПоУмолчанию = Неопределено) Экспорт
	
	Представление = "";
	ОбщегоНазначенияИСПереопределяемый.ЗаполнитьПредставлениеНоменклатуры(
		Представление, Номенклатура, Характеристика, Упаковка, Серия);
	
	Если Представление = "" Тогда
		МассивФормированияПредставления = Новый Массив;
		Если ЗначениеЗаполнено(Номенклатура) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Номенклатура));
		КонецЕсли;
		Если ЗначениеЗаполнено(Характеристика) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Характеристика));
		КонецЕсли;
		Если ЗначениеЗаполнено(Упаковка) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Упаковка));
		КонецЕсли;
		Если ЗначениеЗаполнено(Серия) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Серия));
		КонецЕсли;
		Представление = СтрСоединить(МассивФормированияПредставления, ", ");
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Представление) И ЗначениеЗаполнено(ПоУмолчанию) Тогда
		Представление = Строка(ПоУмолчанию);
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

#КонецОбласти

Функция ОбъединитьПути(Путь1, Путь2, Путь3 = Неопределено) Экспорт
	
	РазделительПути = "\";
	
	МассивПутей = Новый Массив();
	МассивПутей.Добавить(Путь1);
	МассивПутей.Добавить(Путь2);
	МассивПутей.Добавить(Путь3);
	
	МассивПутейИтоговый = Новый Массив();
	
	Для Каждого Путь Из МассивПутей Цикл
		Если Не ЗначениеЗаполнено(Путь) Тогда
			Продолжить;
		КонецЕсли;
		Если Прав(Путь, 1) = "/"
			Или Прав(Путь, 1) = РазделительПути Тогда
			МассивПутейИтоговый.Добавить(Сред(Путь, СтрДлина(Путь) - 1));
		Иначе
			МассивПутейИтоговый.Добавить(Путь);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(МассивПутейИтоговый, РазделительПути);

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Формирует массив пустых значений определяемого типа.
// 
// Параметры:
//  ОпределяемыйТипИлиИмяТипа - Строка, ОбъектМетаданныхОпределяемыйТип - определяемый тип, по которому надо получить пустые значения
//  по умолчанию
// Возвращаемое значение:
//  Массив из ЛюбаяСсылка - Пустые значения определяемого типа.
//
Функция НезаполненныеЗначенияОпределяемогоТипа(ОпределяемыйТипИлиИмяТипа) Экспорт
	
	Если ТипЗнч(ОпределяемыйТипИлиИмяТипа) = Тип("Строка") Тогда
		ОпределяемыйТип = Метаданные.ОпределяемыеТипы[ОпределяемыйТипИлиИмяТипа];
	Иначе
		ОпределяемыйТип = ОпределяемыйТипИлиИмяТипа;
	КонецЕсли;
	
	МассивПустыхЗначений = Новый Массив;
	Для Каждого ТипЗначения Из ОпределяемыйТип.Тип.Типы() Цикл
		МассивТипов = Новый Массив;
		МассивТипов.Добавить(ТипЗначения);
		ОписаниеТипа = Новый ОписаниеТипов(МассивТипов);
		МассивПустыхЗначений.Добавить(ОписаниеТипа.ПривестиЗначение());
	КонецЦикла;
	
	Если МассивПустыхЗначений.Количество() > 1 Тогда
		МассивПустыхЗначений.Добавить(Неопределено);
	КонецЕсли;
	
	Возврат МассивПустыхЗначений;
	
КонецФункции

// Возвращает пароль к сертификату, если доступен текущему пользователю.
// При вызове в привилегированном режиме текущий пользователь не учитывается.
//
// Параметры:
//  Сертификат - Неопределено - вернуть пароли ко всем сертификатам, доступным текущему пользователю.
//             - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - вернуть пароль
//                 к указанному сертификату.
//              
// Возвращаемое значение:
//  Неопределено - пароль для указанного сертификата не указан.
//  Строка       - пароль для указанного сертификата.
//  Соответствие - все заданные пароли, доступные текущему пользователю
//                 в виде ключ - сертификат и значение - пароль.
//
Функция ПарольКСертификату(Сертификат = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Данные = Константы.КонтекстРаботыИС.Получить().Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	РольДляПроверки = Неопределено;
	Если Метаданные.Роли.Найти("ДобавлениеИзменениеЭлектронныхПодписейИШифрование") <> Неопределено Тогда
		РольДляПроверки = "ДобавлениеИзменениеЭлектронныхПодписейИШифрование";
	ИначеЕсли Метаданные.Роли.Найти("ДобавлениеИзменениеСертификатовКлючейЭлектроннойПодписиИШифрования") <> Неопределено Тогда
		РольДляПроверки = "ДобавлениеИзменениеСертификатовКлючейЭлектроннойПодписиИШифрования";
	Иначе
		ВызватьИсключение НСтр("ru = 'Не определена роль для добавления и (или) изменения электронных подписей'");
	КонецЕсли;
	
	Если Не Пользователи.РолиДоступны(РольДляПроверки) Тогда
		Если Сертификат <> Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		Возврат Новый СписокЗначений;
	КонецЕсли;
	
	Если Сертификат <> Неопределено Тогда
		Если ТипЗнч(Данные) <> Тип("Соответствие") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Свойства = Данные.Получить(Сертификат);
		
		Если ТипЗнч(Свойства) = Тип("Структура")
		   И Свойства.Свойство("Пароль")
		   И ТипЗнч(Свойства.Пароль) = Тип("Строка")
		   И Свойства.Свойство("Пользователь")
		   И ТипЗнч(Свойства.Пользователь) = Тип("СправочникСсылка.Пользователи") Тогда
			
		   Если Свойства.Пользователь = Пользователи.ТекущийПользователь()
			   ИЛИ Свойства.Пользователь = Справочники.Пользователи.ПустаяСсылка() Тогда
				
				Возврат Свойства.Пароль;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;
	
	ПаролиСертификатов = Новый Соответствие;
	
	Если ТипЗнч(Данные) <> Тип("Соответствие") Тогда
		Возврат ПаролиСертификатов;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Данные Цикл
		Свойства = КлючИЗначение.Значение;
		
		Если ТипЗнч(Свойства) = Тип("Структура")
		   И Свойства.Свойство("Пароль")
		   И ТипЗнч(Свойства.Пароль) = Тип("Строка")
		   И Свойства.Свойство("Пользователь")
		   И ТипЗнч(Свойства.Пользователь) = Тип("СправочникСсылка.Пользователи") Тогда
			
		   Если Свойства.Пользователь = Пользователи.ТекущийПользователь()
			   ИЛИ Свойства.Пользователь = Справочники.Пользователи.ПустаяСсылка()
			 Или ПривилегированныйРежим() Тогда
				ПаролиСертификатов.Вставить(КлючИЗначение.Ключ, Свойства.Пароль);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПаролиСертификатов;
	
КонецФункции

// Серверное ожидание перед очередным действием в соответствии с ограничениями сервиса
//
// Параметры:
//   ВремяОжидания   - Число     - длительность паузы
//   ПараметрыОбмена - Структура - параметры обмена с обязательным свойством:
//    * ФоновоеЗадание - Неопределено, ФоновоеЗадание - задание ожидания
//
Процедура Ожидать(ВремяОжидания, ПараметрыОбмена) Экспорт
	
	Если ВремяОжидания <= 0 Тогда
		Возврат;
	КонецЕсли;
	
	ФоновоеЗадание = Неопределено;
	Если ПараметрыОбмена.ФоновоеЗадание = Неопределено Тогда
		
		ТекущийСеансИнформационнойБазы = ПолучитьТекущийСеансИнформационнойБазы();
		ФоновоеЗадание = ТекущийСеансИнформационнойБазы.ПолучитьФоновоеЗадание();
		
		Если ФоновоеЗадание = Неопределено Тогда
			Если ОбщегоНазначения.РазделениеВключено()
				И ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.БазоваяФункциональность") Тогда
				ОбщийМодульОбщегоНазначенияБТС = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияБТС");
				ОбщийМодульОбщегоНазначенияБТС.Пауза(ВремяОжидания);
				Возврат;
			КонецЕсли;
		Иначе
			ПараметрыОбмена.ФоновоеЗадание = ФоновоеЗадание;
		КонецЕсли;
		
	Иначе
		ФоновоеЗадание = ПараметрыОбмена.ФоновоеЗадание;
	КонецЕсли;
	
	Если ФоновоеЗадание <> Неопределено Тогда
		Попытка
			//@skip-check object-deprecated
			ФоновоеЗадание.ОжидатьЗавершения(ВремяОжидания);
		Исключение
			ВремяОжидания = 0;
		КонецПопытки;
	КонецЕсли;
	
	Если ВремяОжидания = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоWindowsСервер() Тогда
		
		НастройкиПрокси = Новый ИнтернетПрокси(Ложь);
		НастройкиПрокси.НеИспользоватьПроксиДляЛокальныхАдресов = Истина;
		НастройкиПрокси.НеИспользоватьПроксиДляАдресов.Добавить("127.0.0.0");
		
		Попытка
			Loopback = Новый HTTPСоединение(
				"127.0.0.0",,,,НастройкиПрокси,
				ВремяОжидания);
			Loopback.Получить(Новый HTTPЗапрос());
		Исключение
			ВремяОжидания = 0;
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

// Конвертирует входящий текст JSON содержащий globalErrors в представление ошибки.
// 
// Параметры:
// 	ТекстВходящегоСообщенияJSON - Строка - Текст сообщения JSON.
// Возвращаемое значение:
// 	Строка - Представление ошибки.
Функция ПредставлениеОшибкиИзJSON(ТекстВходящегоСообщенияJSON)
	
	ДанныеJSON = ТекстJSONВОбъект(ТекстВходящегоСообщенияJSON);
	
	Если ДанныеJSON <> Неопределено
		И ТипЗнч(ДанныеJSON) = Тип("Структура")
		И ДанныеJSON.Свойство("globalErrors")
		И ТипЗнч(ДанныеJSON.globalErrors) = Тип("Массив") Тогда
		
		ТекстыОшибок = Новый Массив;
		Для Каждого СтрокаОшибки Из ДанныеJSON.globalErrors Цикл
			
			Если Не (ТипЗнч(СтрокаОшибки) = Тип("Строка") Или ТипЗнч(СтрокаОшибки) = Тип("Структура")) Тогда
				Возврат ТекстВходящегоСообщенияJSON;
			КонецЕсли;
			
			Если ТипЗнч(СтрокаОшибки) = Тип("Строка") И ЗначениеЗаполнено(СтрокаОшибки) Тогда
				ТекстыОшибок.Добавить(ТекстПредставленияОшибки(СтрокаОшибки));
			ИначеЕсли ТипЗнч(СтрокаОшибки) = Тип("Структура") Тогда
				
				ТекстОшибки = Неопределено;
				КодОшибки   = Неопределено;
				СтрокаОшибки.Свойство("error",     ТекстОшибки);
				СтрокаОшибки.Свойство("errorCode", КодОшибки);
				ПредставлениеОшибки = СокрЛП(СтрШаблон("%1: %2", КодОшибки, ТекстОшибки));
				Если ЗначениеЗаполнено(КодОшибки) Или ЗначениеЗаполнено(ТекстОшибки) Тогда
					ТекстыОшибок.Добавить(ПредставлениеОшибки);
				Иначе
					Возврат ТекстВходящегоСообщенияJSON;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если ДанныеJSON.Свойство("fieldErrors") И ТипЗнч(ДанныеJSON.fieldErrors) = Тип("Массив") Тогда
			
			Для Каждого СтрокаОшибкиПоля Из ДанныеJSON.fieldErrors Цикл
				
				ИмяПоля     = Неопределено;
				ТекстОшибки = Неопределено;
				СтрокаОшибкиПоля.Свойство("fieldName",  ИмяПоля);
				СтрокаОшибкиПоля.Свойство("fieldError", ТекстОшибки);
				
				ПредставлениеОшибки = СокрЛП(СтрШаблон("%1: %2", ИмяПоля, ТекстОшибки));
				Если ЗначениеЗаполнено(ИмяПоля) Или ЗначениеЗаполнено(ТекстОшибки) Тогда
					ТекстыОшибок.Добавить(ПредставлениеОшибки);
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
		Возврат СтрСоединить(ТекстыОшибок, Символы.ПС);
		
	ИначеЕсли ДанныеJSON <> Неопределено
		И ТипЗнч(ДанныеJSON) = Тип("Массив") Тогда
		
		ТекстыОшибок = Новый Массив;
		Для Каждого СтрокаОшибки Из ДанныеJSON Цикл
			
			Если Не ТипЗнч(СтрокаОшибки) = Тип("Структура")
				Или Не СтрокаОшибки.Свойство("cisInfo")
				Или Не СтрокаОшибки.Свойство("errorMessage") Тогда
				Возврат ТекстВходящегоСообщенияJSON;
			КонецЕсли;
			
			ТекстыОшибок.Добавить(ТекстПредставленияОшибки(СтрокаОшибки.errorMessage));
			
		КонецЦикла;
		
		Возврат СтрСоединить(ТекстыОшибок, Символы.ПС);
		
	Иначе
		Возврат ТекстВходящегоСообщенияJSON;
	КонецЕсли;
	
КонецФункции

// Возвращает найденое значение во внутреннем соответствии текстов ошибок.
// Если значение в соответствии не найдено, то возвращается исходное значение.
// 
// Параметры:
// 	ИсходноеСообщение - Строка - Исходный текст.
// Возвращаемое значение:
// 	Строка - Найденое значение или сходнное.
Функция ТекстПредставленияОшибки(ИсходноеСообщение)
	
	ЗначениеПоиска = СокрЛП(НРег(ИсходноеСообщение));
	
	ТекстыОшибок = Новый Соответствие();
	
	ТекстыОшибок.Вставить(
		НРег("Not enough balance"),
		НСтр("ru = 'Недостаточно средств на балансе для получения кодов маркировки из СУЗ'"));
	
	ВозвращаемоеЗначение = ТекстыОшибок.Получить(ЗначениеПоиска);
	
	Если ВозвращаемоеЗначение = Неопределено Тогда
		ВозвращаемоеЗначение = ИсходноеСообщение;
	КонецЕсли;
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

// Возвращает ссылку на общий модуль или модуль менеджера по имени.
//
// Параметры:
//  ИмяМодуля - Строка - имя общего модуля.
//  КешированныеЗначения - Неопределено, Структура - КешированныеЗначения
// Возвращаемое значение:
//   ОбщийМодуль
//   МодульМенеджераОбъекта
Функция ОбщийМодуль(ИмяМодуля, КешированныеЗначения) Экспорт
	
	Если КешированныеЗначения = Неопределено Тогда
		КешированныеЗначения = Новый Соответствие();
	КонецЕсли;
	
	ОписаниеМодуля = КешированныеЗначения[ИмяМодуля];
	Если ОписаниеМодуля = Неопределено Тогда
		ОписаниеМодуля = Новый Структура("Модуль");
		ОписаниеМодуля.Модуль = ОбщегоНазначения.ОбщийМодуль(ИмяМодуля);
		КешированныеЗначения[ИмяМодуля] = ОписаниеМодуля;
	КонецЕсли;
	
	Возврат ОписаниеМодуля.Модуль;
	
КонецФункции

Функция ПодсистемаСуществует(КраткоеИмяПодсистемы) Экспорт
	
	ПолноеИмяПодсистемы = ОбщегоНазначенияИСКлиентСервер.ПолноеИмяПодсистемы(КраткоеИмяПодсистемы);
	Возврат ОбщегоНазначения.ПодсистемаСуществует(ПолноеИмяПодсистемы);
	
КонецФункции

// Записыват вскрытие потребительской упаковки и, при необхоидмости, готовит документ для передачи в ГИС МТ
// 
// Параметры:
//  ДанныеПодключения - см. РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ИнициализироватьДанныеВскрытияПотребительскойУпаковки
//  ДанныеОтключения  - Неопределено
//                    - см. РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ИнициализироватьДанныеВскрытияПотребительскойУпаковки
// Возвращаемое значение:
//  Структура - результат подключения кега к оборудованию розлива:
// * Документ - ОпределяемыйТип.ДокументПодключениеКегаКОборудованиюРозливаИСМП - документ подключения кега
// * ТекстОшибки - Строка, Неопределено - текст ошибки подключения при наличии
Функция ВскрытьПотребительскуюУпаковку(ДанныеПодключения, ДанныеОтключения = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ВозвращаемоеЗначение = Новый Структура;
	ВозвращаемоеЗначение.Вставить("Документ",    ПустоеЗначениеОпределяемогоТипа("ДокументПодключениеКегаКОборудованиюРозливаИСМП"));
	ВозвращаемоеЗначение.Вставить("ТекстОшибки", Неопределено);
	
	Блокировка = Новый БлокировкаДанных();
	
	ЭлементБлокировки = Блокировка.Добавить(Метаданные.РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ПолноеИмя());
	ЭлементБлокировки.УстановитьЗначение("КодМаркировки", ДанныеПодключения.КодМаркировки);
	
	Если ДанныеОтключения <> Неопределено Тогда
		ЭлементБлокировки = Блокировка.Добавить(Метаданные.РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ПолноеИмя());
		ЭлементБлокировки.УстановитьЗначение("КодМаркировки", ДанныеОтключения.КодМаркировки);
	КонецЕсли;
	
	НачатьТранзакцию();
	
	Попытка
		
		Блокировка.Заблокировать();
		
		Если (ДанныеПодключения.ВидПродукции = Перечисления.ВидыПродукцииИС.Пиво
				Или ДанныеПодключения.ВидПродукции = Перечисления.ВидыПродукцииИС.ПивоВПотребительскихУпаковках)
			И ЭтоРасширеннаяВерсияГосИС("ИСМП") Тогда
			
			МенеджерПодключения = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени("Документ.ПодключениеКегаКОборудованиюРозливаИСМП");
			ДокументОбъект      = МенеджерПодключения.СоздатьДокумент();
			
			ЗаполнитьЗначенияСвойств(ДокументОбъект, ДанныеПодключения);
			ДокументОбъект.КодМаркировки = ДанныеПодключения.КодМаркировки;
			ДокументОбъект.Дата          = ТекущаяДатаСеанса();
			
			ДокументОбъект.Записать(РежимЗаписиДокумента.Проведение);
			
			ВозвращаемоеЗначение.Документ = ДокументОбъект.Ссылка;
			ДанныеПодключения.Документ    = ДокументОбъект.Ссылка;
		
		КонецЕсли;
		
		РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ЗаписатьВскрытиеПотребительскойУпаковки(ДанныеПодключения);
		
		Если ДанныеОтключения <> Неопределено Тогда
			
			ТаблицаДанных = РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.НоваяТаблицаОтключенияВскрытыхПотребительскихУпаковок();
			НоваяСтрока                  = ТаблицаДанных.Добавить();
			НоваяСтрока.КодМаркировки    = ДанныеОтключения.КодМаркировки;
			НоваяСтрока.УчитыватьОстаток = Истина;
			РегистрыСведений.ВскрытыеПотребительскиеУпаковкиИС.ОтключитьВскрытыеПотребительскиеУпаковки(ТаблицаДанных);
			
		КонецЕсли;
		
		ЗафиксироватьТранзакцию();
		
	Исключение
		
		ОтменитьТранзакцию();
		
		ИнформацияОбОшибке = ИнформацияОбОшибке();
				
		ВозвращаемоеЗначение.ТекстОшибки = СтрШаблон(
			НСтр("ru = 'Ошибка записи данных вскрытия потребительской упаковки %1:
				       |%2'"),
			ДанныеПодключения.КодМаркировки,
			ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке));
		
		ТекстОшибкиПодробно = СтрШаблон(
			НСтр("ru = 'Ошибка записи данных вскрытия потребительской упаковки %1:
				       |%2'"),
			ДанныеПодключения.КодМаркировки,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке));
		
		ОбщегоНазначенияИСВызовСервера.ЗаписатьОшибкуВЖурналРегистрации(ТекстОшибкиПодробно);
		
	КонецПопытки;
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

Функция КомментарийКонтактнойИнформации(КонтактнаяИнформация) Экспорт
	
	Возврат УправлениеКонтактнойИнформацией.КомментарийКонтактнойИнформации(КонтактнаяИнформация);
	
КонецФункции

#Область Обмен

// Получает сертификаты организаций, для предназначены для подписания на сервере.
// 
// Возвращаемое значение:
//  Структура - Структура со свойствами:
//   * Сертификаты - ТаблицаЗначений - содержит сертификат и пароль.
//   * МенеджерКриптографии - МенеджерКриптографии - менеджер криптографии.
//
Функция СертификатыДляПодписанияНаСервере() Экспорт
	
	Если Не ОбщегоНазначения.ИнформационнаяБазаФайловая()
		И Не ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НастройкиОбмена = НастройкиОбменаГосИС();
	
	Если НастройкиОбмена = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НастройкиОбмена.Колонки.Найти("Подразделение") = Неопределено Тогда
		НастройкиОбмена.Колонки.Добавить("Подразделение", Метаданные.ОпределяемыеТипы.Подразделение.Тип);
	КонецЕсли;
	
	Запрос = Новый Запрос(
	"ВЫБРАТЬ
	|	Т.Организация   КАК Организация,
	|	Т.Подразделение КАК Подразделение,
	|	Т.Сертификат    КАК Сертификат
	|ПОМЕСТИТЬ ТаблицаДанных
	|ИЗ
	|	&Таблица КАК Т
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ТаблицаДанных.Организация          КАК Организация,
	|	ТаблицаДанных.Подразделение        КАК Подразделение,
	|	ТаблицаДанных.Сертификат           КАК Сертификат,
	|	ТаблицаДанных.Сертификат.Отпечаток КАК Отпечаток,
	|	ТаблицаДанных.Сертификат.Программа КАК Программа
	|ИЗ
	|	ТаблицаДанных КАК ТаблицаДанных
	|ГДЕ
	|	НЕ ТаблицаДанных.Сертификат.Отозван
	|	И (ТаблицаДанных.Сертификат.ДействителенДо >= &ТекущаяДатаСеанса
	|	   ИЛИ ТаблицаДанных.Сертификат.ДействителенДо = ДАТАВРЕМЯ(1, 1, 1))
	|");
	
	Запрос.УстановитьПараметр("Таблица",           НастройкиОбмена);
	Запрос.УстановитьПараметр("ТекущаяДатаСеанса", ТекущаяДатаСеанса());
	
	ДанныеСертификатовИзНастроекОбмена = Запрос.Выполнить().Выгрузить();
	
	СертификатыОрганизацийДляОбменаНаСервере = Новый ТаблицаЗначений();
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Организация");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Подразделение");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Сертификат");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Отпечаток");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("СертификатКриптографии");
	СертификатыОрганизацийДляОбменаНаСервере.Колонки.Добавить("Пароль");
	
	СертификатыОрганизацийДляОбменаНаСервере.Индексы.Добавить("Организация");
	СертификатыОрганизацийДляОбменаНаСервере.Индексы.Добавить("Организация,Подразделение");
	
	Программа = Неопределено;
	Для Каждого ДанныеСертификата Из ДанныеСертификатовИзНастроекОбмена Цикл
		
		Пароль = ПарольКСертификату(ДанныеСертификата.Сертификат);
		
		СертификатКриптографии = ЭлектроннаяПодписьСлужебный.ПолучитьСертификатПоОтпечатку(
			ДанныеСертификата.Отпечаток,
			Ложь,
			Ложь);
		Если СертификатКриптографии = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаТЧ = СертификатыОрганизацийДляОбменаНаСервере.Добавить();
		СтрокаТЧ.Организация            = ДанныеСертификата.Организация;
		СтрокаТЧ.Подразделение          = ДанныеСертификата.Подразделение;
		СтрокаТЧ.Сертификат             = ДанныеСертификата.Сертификат;
		СтрокаТЧ.Отпечаток              = ДанныеСертификата.Отпечаток;
		СтрокаТЧ.СертификатКриптографии = СертификатКриптографии;
		Если Пароль <> Неопределено Тогда
			СтрокаТЧ.Пароль = Пароль;
		Иначе
			СтрокаТЧ.Пароль = "";
		КонецЕсли;
		
		Программа = ДанныеСертификата.Программа;
		
	КонецЦикла;
	
	Если СертификатыОрганизацийДляОбменаНаСервере.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МенеджерКриптографии = ЭлектроннаяПодпись.МенеджерКриптографии("Подписание",,, Программа);
	
	СертификатыДляПодписанияНаСервере = Новый Структура;
	СертификатыДляПодписанияНаСервере.Вставить("Сертификаты",          СертификатыОрганизацийДляОбменаНаСервере);
	СертификатыДляПодписанияНаСервере.Вставить("МенеджерКриптографии", МенеджерКриптографии);
	
	//@skip-check constructor-function-return-section
	Возврат СертификатыДляПодписанияНаСервере;
	
КонецФункции

// Получает доступные пользователю для подписи сертификаты по организации.
//
// Параметры:
//  Организация - ОпределяемыйТип.Организация - организация, чьи сертификаты получаются.
//  ВключатьСертификатыБезОрганизации - Булево - Включать сертификаты с незаполненной организацией, если отсутсвуют сертификаты организации.
//  ВключатьСертификатыФЛ - Булево - Включать сертификаты, оформленные на физических лиц
// Возвращаемое значение:
//   Массив из СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - массив доступных сертификатов.
//
Функция СертификатыПользователяДляПодписиПоОрганизации(Организация, ВключатьСертификатыБезОрганизации = Ложь, ВключатьСертификатыФЛ = Истина) Экспорт
	
	Если ТипЗнч(Организация) = Тип("Массив") Тогда
		Организации = Организация;
	Иначе
		Организации = Новый Массив;
		Организации.Добавить(Организация);
	КонецЕсли;
	
	Возврат СертификатыПользователяДляПодписиПоОрганизациям(Организации, ВключатьСертификатыБезОрганизации, ВключатьСертификатыФЛ)[Организация];
	
КонецФункции

// Получает доступные пользователю для подписи сертификаты по организациям.
//
// Параметры:
//  Организации - Массив из ОпределяемыйТип.Организация - организация, чьи сертификаты получаются.
//  ВключатьСертификатыБезОрганизации - Булево - Включать сертификаты с незаполненной организацией, если отсутствуют сертификаты организации.
//  ВключатьСертификатыФЛ - Булево - Включать сертификаты, оформленные на физических лиц
// Возвращаемое значение:
//   Соответствие из КлючИЗначение:
//   * Ключ - ОпределяемыйТип.Организация - организация.
//   * Значение - Массив из СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - массив доступных сертификатов.
//
Функция СертификатыПользователяДляПодписиПоОрганизациям(Организации, ВключатьСертификатыБезОрганизации = Ложь, ВключатьСертификатыФЛ = Истина) Экспорт
	
	Результат = Новый Соответствие;
	Для Каждого Организация Из Организации Цикл
		Результат.Вставить(Организация, Новый Массив);
	КонецЦикла;
	
	ЕстьПравоДоступаЧтение = ПравоДоступа("Чтение", Метаданные.Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования);
	Если Не ЕстьПравоДоступаЧтение Тогда
		Возврат Результат;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	Сертификаты.Организация       КАК Организация,
	|	Сертификаты.Ссылка            КАК Сертификат,
	|	Сертификаты.ДанныеСертификата КАК ДанныеСертификата
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования.Пользователи КАК ПользователиСертификатов
	|		ПО Сертификаты.Ссылка = ПользователиСертификатов.Ссылка
	|ГДЕ
	|	Сертификаты.Организация В (&Организации)
	|	И НЕ Сертификаты.Отозван
	|	И НЕ Сертификаты.ПометкаУдаления
	|	И (Сертификаты.ДействителенДо >= &ТекущаяДатаСеанса
	|			ИЛИ Сертификаты.ДействителенДо = ДАТАВРЕМЯ(1, 1, 1))
	|	И (Сертификаты.Пользователь = &Пользователь
	|			ИЛИ ПользователиСертификатов.Пользователь = &Пользователь
	|			ИЛИ Сертификаты.Пользователь В (&ПустойПользователь)
	|				И ПользователиСертификатов.Пользователь ЕСТЬ NULL)
	|;
	|ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	Сертификаты.Ссылка КАК Сертификат
	|ИЗ
	|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования.Пользователи КАК ПользователиСертификатов
	|		ПО Сертификаты.Ссылка = ПользователиСертификатов.Ссылка
	|ГДЕ
	|	ВЫБОР
	|		КОГДА &ВключатьСертификатыБезОрганизации
	|			ТОГДА Сертификаты.Организация В (&ПустаяОрганизация)
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ
	|	И НЕ Сертификаты.Отозван
	|	И НЕ Сертификаты.ПометкаУдаления
	|	И (Сертификаты.ДействителенДо >= &ТекущаяДатаСеанса
	|			ИЛИ Сертификаты.ДействителенДо = ДАТАВРЕМЯ(1, 1, 1))
	|	И (Сертификаты.Пользователь = &Пользователь
	|			ИЛИ ПользователиСертификатов.Пользователь = &Пользователь
	|			ИЛИ Сертификаты.Пользователь В (&ПустойПользователь)
	|				И ПользователиСертификатов.Пользователь ЕСТЬ NULL)";
	
	Запрос.УстановитьПараметр("ТекущаяДатаСеанса",                 ТекущаяДатаСеанса());
	Запрос.УстановитьПараметр("ВключатьСертификатыБезОрганизации", ВключатьСертификатыБезОрганизации И ВключатьСертификатыФЛ);
	Запрос.УстановитьПараметр("Организации",                       Организации);
	Запрос.УстановитьПараметр("ПустаяОрганизация",                 НезаполненныеЗначенияОпределяемогоТипа("Организация"));
	Запрос.УстановитьПараметр("Пользователь",                      Пользователи.ТекущийПользователь());
	Запрос.УстановитьПараметр("ПустойПользователь",                НезаполненныеЗначенияОпределяемогоТипа("Пользователь"));
	Запрос.Параметры.ПустойПользователь.Добавить(Пользователи.СсылкаНеуказанногоПользователя());
	
	РезультатЗапроса = Запрос.ВыполнитьПакет();
	
	Выборка = РезультатЗапроса[0].Выбрать();
	Пока Выборка.Следующий() Цикл  
		
		СертификатыПоОрганизации = Результат[Выборка.Организация];
		Если СертификатыПоОрганизации.Найти(Выборка.Сертификат) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если Не ВключатьСертификатыФЛ Тогда
			
			ДвоичныеДанныеСертификата = Выборка.ДанныеСертификата.Получить();
			
			Если ТипЗнч(ДвоичныеДанныеСертификата) = Тип("ДвоичныеДанные") Тогда
				
				Сертификат = Новый СертификатКриптографии(ДвоичныеДанныеСертификата);
			
				СубъектСертификата = ЭлектроннаяПодпись.СвойстваСубъектаСертификата(Сертификат).Организация;
				Если Не ЗначениеЗаполнено(СубъектСертификата) Тогда
					Продолжить;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
		СертификатыПоОрганизации.Добавить(Выборка.Сертификат);
		
	КонецЦикла;
	
	Если ВключатьСертификатыБезОрганизации Тогда
		Выборка = РезультатЗапроса[1].Выбрать();
		Для Каждого КлючИЗначение Из Результат Цикл
			Если КлючИЗначение.Значение.Количество() = 0 Тогда
				Выборка.Сбросить();
				Пока Выборка.Следующий() Цикл
					КлючИЗначение.Значение.Добавить(Выборка.Сертификат);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область ФорматированиеJSON

// Форматирует текст сообщения в формате JSON
//
// Параметры:
//  ТекстСообщенияJSON           - Строка - текст сообщения, который.
//  УдалитьПробелыИПереносыСтрок - Булево - признак использования отступов, по умолчанию Ложь.
//  КлючиРазворачиванияBASE64 - Неопределено -
//                            - Соответствие Из КлючИЗначение:
//  * Ключ - Строка - Имя свойства для разворота BASE64
//  * Значение - Неопределено - не используется
// Возвращаемое значение:
//  Строка - отформатированная строка JSON.
//
Функция ФорматироватьJSON(ТекстСообщенияJSON, УдалитьПробелыИПереносыСтрок = Ложь, КлючиРазворачиванияBASE64 = Неопределено) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON();
	ЧтениеJSON.УстановитьСтроку(ТекстСообщенияJSON);
	
	Данные = ПрочитатьJSON(ЧтениеJSON, Истина);
	ЧтениеJSON.Закрыть();
	
	Если КлючиРазворачиванияBASE64 <> Неопределено
		И ТипЗнч(Данные) <> Тип("Массив") Тогда
		Для Каждого КлючИЗначение Из КлючиРазворачиванияBASE64 Цикл
			ДанныеПоКлючу = Данные[КлючИЗначение.Ключ];
			Если ДанныеПоКлючу = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			Данные[КлючИЗначение.Ключ] = ТекстJSONВОбъект(ШтрихкодированиеОбщегоНазначенияИСКлиентСервер.Base64ВШтрихкод(ДанныеПоКлючу), Истина);
		КонецЦикла;
	КонецЕсли;
	
	Возврат ОбъектВТекстJSON(Данные, УдалитьПробелыИПереносыСтрок);
	
КонецФункции

#КонецОбласти

#Область ОбменСИспользованиемЭДО

// Получает структуру настроек обмена через ЭДО, извлекая из константы НастройкиОбменаГосИС.
// 
// Возвращаемое значение:
//  ТаблицаЗначений, Неопределено, Произвольный - Настройки обмена.
//
Функция НастройкиОбменаГосИС() Экспорт
	
	ХранилищеЗначения = Константы.НастройкиОбменаГосИС.Получить();
	
	Если ХранилищеЗначения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НастройкиОбмена = ХранилищеЗначения.Получить();
	
	Возврат НастройкиОбмена;
	
КонецФункции

Функция СертификатыОрганизаций() Экспорт
	
	СертификатыОрганизаций = Новый ТаблицаЗначений();
	СертификатыОрганизаций.Колонки.Добавить("Организация", Метаданные.ОпределяемыеТипы.Организация.Тип);
	
	НастройкиОбменаГосИС = НастройкиОбменаГосИС();
	
	Если НастройкиОбменаГосИС = Неопределено Тогда
		Возврат СертификатыОрганизаций;
	КонецЕсли;
	
	Для Каждого Строка Из НастройкиОбменаГосИС Цикл
		ЗаполнитьЗначенияСвойств(СертификатыОрганизаций.Добавить(), Строка);
	КонецЦикла;
	
	Возврат СертификатыОрганизаций;
	
КонецФункции

#КонецОбласти

#Область ОрганизацииКонтрагенты

// Проверяет использование подразделений в информационной базе.
// 
// Возвращаемое значение:
//  Булево - Подразделения используются.
//
Функция ИспользоватьПодразделения() Экспорт
	
	Использовать = Ложь;
	ОбщегоНазначенияИСПереопределяемый.ИспользованиеПодразделений(Использовать);
	Возврат Использовать;
	
КонецФункции

// Определяет использование в инофрмационной базе обособленных подразделений выделенных на отдельный баланс
// 
// Возвращаемое значение:
//  Булево - Используются подразделения, выделенных на обособленный баланс
//
Функция ИспользоватьОбособленныеПодразделенияВыделенныеНаБаланс() Экспорт
	
	Использовать = Ложь;
	ОбщегоНазначенияИСПереопределяемый.ИспользоватьОбособленныеПодразделенияВыделенныеНаБаланс(Использовать);
	Возврат Использовать;
	
КонецФункции

#КонецОбласти

#Область МинимальныеЦеныПодакцизныхТоваров

//Выполняет проверку минимальных цен подакцизных товаров
//
// Параметры:
//  ПараметрыСканирования - Структура - параметры проверки минимальных цен
//   * Грузоотправитель   - ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено
//   * Грузополучатель    - ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено
//   * ВидДокумента       - ПеречислениеСсылка.ВидыДокументовЕГАИС
//   * ЭтоРеализация      - Булево 
//   
//  Товары - ТаблицаЗначений - таблица продукции для проверки минимальных цен алкгольной продукции
//  см. 
//   * Номенклатура   - ОпределяемыйТип.Номенклатура
//   * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры
//   * Серия          - ОпределяемыйТип.СерияНоменклатуры
//  
//  ШтрихкодыУпаковок - ТаблицаЗначений - штриходы упаковок табачной продукции для проверки минимальных/максимальных цен
//   см. ОбщегоНазначенияИСМП.МинимальныеЦеныТабачнойПродукции
// 
// Возвращаемое значение:
//  РезультатыПроверкиЦен - Структура - результаты проверки минимальных цен подакцизных товаров
//   * РезультатыПроверкиПоАлкогольнойПродукции - см. ОбщегоНазначенияЕГАИС.ПодобратьМинимальныеЦеныАлкогольнойПродукции 
//   * РезультатыПроверкиПоТабачнойПродукции - см. ОбщегоНазначенияИСМП.МинимальныеЦеныТабачнойПродукции
//
Функция МинимальныеЦеныПодакцизныхТоваров(ПараметрыСканирования=Неопределено, Товары=Неопределено, ШтрихкодыУпаковок=Неопределено) Экспорт
	
	РезультатыПроверкиЦен = Новый Структура;
	
	Если Товары <> Неопределено Тогда
		МодульИнтеграцияЕГАИС = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияЕГАИС");
		ПараметрыПроверки     = МодульИнтеграцияЕГАИС.ИнициализироватьПараметрыПроверкиМинимальныхЦен();
		
		Если ПараметрыСканирования.ВидДокумента = Перечисления.ВидыДокументовЕГАИС.ЧекККМ Тогда
			ПараметрыПроверки.РозничнаяПродажа = Истина;
		Иначе
			Если ПараметрыСканирования.ЭтоРеализация Тогда
				ПараметрыПроверки.Реализация = Истина;
			Иначе
				ПараметрыПроверки.Поступление = Истина;
			КонецЕсли;
		КонецЕсли;
		
		ПараметрыПроверки.Организация = ПараметрыСканирования.Грузоотправитель;
		ПараметрыПроверки.Контрагент  = ПараметрыСканирования.Грузополучатель;
		
		МодульИнтеграцияЕГАИС.ПодобратьМинимальныеЦеныАлкогольнойПродукции(Товары, ПараметрыПроверки);
		РезультатыПроверкиЦен.Вставить("РезультатыПроверкиПоАлкогольнойПродукции", ПараметрыПроверки);	
	КонецЕсли;
	
	Если ШтрихкодыУпаковок <> Неопределено Тогда
		МодульИнтеграцияИСМП = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияИСМП");
		РезультатыПроверкиПоТабачнойПродукции = МодульИнтеграцияИСМП.МинимальныеЦеныТабачнойПродукции(ШтрихкодыУпаковок, ПараметрыСканирования);
		РезультатыПроверкиЦен.Вставить("РезультатыПроверкиПоТабачнойПродукции", РезультатыПроверкиПоТабачнойПродукции);	
	КонецЕсли;
	
	Возврат РезультатыПроверкиЦен;
	
КонецФункции

#КонецОбласти

#Область СправочникиИКлассификаторы

// Переопределяются алгоритмы обработки файла загруженного
// из сервиса классификаторов. После обработки файла нельзя удалять
// временного хранилища, т.к. при необходимости он будет сохранен в
// кэше для последующего использования.
//
// Параметры:
//  Идентификатор           - Строка - идентификатор классификатора в сервисе классификаторов.
//                            Определяется в процедуре ПриДобавленииКлассификаторов.
//  Версия                  - Число - номер загруженной версии;
//  Адрес                   - Строка - адрес двоичных данных файла обновления во
//                            временном хранилище;
//  Обработан               - Булево - если Ложь, при обработке файла обновления были ошибки
//                            и его необходимо загрузить повторно;
//  ДополнительныеПараметры - Структура - содержит дополнительные параметры обработки.
//                            Необходимо использовать для передачи значений в переопределяемый
//                            метод РаботаСКлассификаторамиВМоделиСервисаПереопределяемый.ПриОбработкеОбластиДанных
//                            и метод ИнтеграцияПодсистемБИП.ПриОбработкеОбластиДанных..
// Пример:
//	Если Идентификатор = "CentralBankRefinancingRate" Тогда
//		Обработан = РегистрыСведений.СтавкиРефинансирования.ОбновитьДанныеРегистраИзФайла(Адрес, ДополнительныеПараметры);
//	КонецЕсли;
//
//@skip-warning
Процедура ПриЗагрузкеКлассификатора(Идентификатор, Версия, Адрес, Обработан, ДополнительныеПараметры) Экспорт
	
	Если ПодсистемаСуществует("ЕГАИС") Тогда
		МодульОбщегоНазначенияЕГАИС = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияЕГАИС");
		МодульОбщегоНазначенияЕГАИС.ПриЗагрузкеКлассификатора(Идентификатор, Версия, Адрес, Обработан, ДополнительныеПараметры);
	КонецЕсли;
	
КонецПроцедуры

// Переопределяются номер версии классификатора, который уже загружен в информационную базу.
// При начале использовании подсистемы "РаботаСКлассификаторами" или при подключении нового
// классификатора к сервису, неизвестно какой номер версии классификатора загружен в ИБ,
// поэтому при очередной итерации обновления данных из сервиса данные будут загружены повторно.
// Чтобы избежать повторной загрузки, необходимо указать задать начальный номер версии.
// Метод будет вызван при попытке загрузить версию классификатора, у которого установлена
// версия равная 0.
//
// Параметры:
//  Идентификатор        - Строка - идентификатор классификатора в сервисе классификаторов.
//                         Определяется в процедуре ПриДобавленииКлассификаторов.
//  НачальныйНомерВерсии - Число - номер версии загруженного классификатора.
//
// Пример:
//	Если Идентификатор = "CentralBankRefinancingRate" Тогда
//		НачальныйНомерВерсии = РегистрыСведений.СтавкиРефинансирования.НомерЗагруженнойВерсии();
//	КонецЕсли;
//
//@skip-warning
Процедура ПриОпределенииНачальногоНомераВерсииКлассификатора(Идентификатор, НачальныйНомерВерсии) Экспорт
	
	Если ПодсистемаСуществует("ЕГАИС") Тогда
		МодульОбщегоНазначенияЕГАИС = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияЕГАИС");
		МодульОбщегоНазначенияЕГАИС.ПриОпределенииНачальногоНомераВерсииКлассификатора(Идентификатор, НачальныйНомерВерсии);
	КонецЕсли;
	
КонецПроцедуры

// Переопределяется список и настройки классификаторов обновления которых необходимо
// загружать из сервиса классификаторов. Для получения идентификатора необходимо
// перевести наименование объекта метаданных, данные которого планируется обновлять,
// на английский язык. При переводе рекомендуется использовать профессиональные
// программы перевода текста, либо воспользоваться услугами переводчика, т.к. при
// обнаружении смысловых ошибок в идентификаторе потребуется заводить новый классификатор
// и изменять код конфигурации.
//
// Параметры:
//  Классификаторы  - Массив из Структура - содержит настройки загрузки классификаторов.
//                    Состав настроек см. функцию РаботаСКлассификаторами.ОписаниеКлассификатора.
//
// Пример:
//	Описатель = РаботаСКлассификаторами.ОписаниеКлассификатора();
//	Описатель.Наименование               = НСтр("ru = 'Ставки рефинансирования'");
//	Описатель.Идентификатор              = "CentralBankRefinancingRate";
//	Описатель.ОбновлятьАвтоматически     = Истина;
//	Описатель.ОбщиеДанные                = Истина;
//	Описатель.СохранятьФайлВКэш          = Ложь;
//	Описатель.ОбработкаРазделенныхДанных = Ложь;
//	Классификаторы.Добавить(Описатель);
//
//@skip-warning
Процедура ПриДобавленииКлассификаторов(Классификаторы) Экспорт
	
	Если ПодсистемаСуществует("ЕГАИС") Тогда
		МодульОбщегоНазначенияЕГАИС = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияЕГАИС");
		МодульОбщегоНазначенияЕГАИС.ПриДобавленииКлассификаторов(Классификаторы);
	КонецЕсли;
	
КонецПроцедуры

// см. РаботаСКлассификаторамиВМоделиСервисаПереопределяемый.ПриОпределенииИдентификаторовКлассификаторов
Процедура ПриОпределенииИдентификаторовКлассификаторовВМоделиСервиса(Идентификаторы) Экспорт
	
	Если ПодсистемаСуществует("ЕГАИС") Тогда
		МодульОбщегоНазначенияЕГАИС = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияЕГАИС");
		МодульОбщегоНазначенияЕГАИС.ПриОпределенииИдентификаторовКлассификаторовВМоделиСервиса(Идентификаторы);
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#КонецОбласти
