
#Область СлужебныйПрограммныйИнтерфейс

#Область ПрисоединенныеФайлы

// Возвращает двоичные данные присоединенных файлов.
// 
// Параметры:
// 	ПрисоединенныеФайлы - Массив из ОпределяемыйТип.ПрисоединенныйФайл
// 	КонтекстДиагностики - см. ОбработкаНеисправностейБЭД.НовыйКонтекстДиагностики
// Возвращаемое значение:
// 	Соответствие из КлючИЗначение:
// 	  * Ключ - ОпределяемыйТип.ПрисоединенныйФайл
// 	  * Значение - ДвоичныеДанные
Функция ДвоичныеДанныеФайлов(ПрисоединенныеФайлы, КонтекстДиагностики = Неопределено) Экспорт
	Возврат ИнтеграцияБСПБЭД.ДвоичныеДанныеФайлов(ПрисоединенныеФайлы, КонтекстДиагностики = Неопределено);
КонецФункции

#КонецОбласти

#Область ФайловаяСистема

// Получение строки в формате Base64 по двоичным данным.
//
// Параметры:
//  Данные - ДвоичныеДанные - Данные, которые необходимо преобразовать в формат Base64.
// 
// Возвращаемое значение:
//  Строка - Двоичные данные в формате Base64.
//
Функция Base64СтрокаИзДвоичныхДанных(Знач Данные) Экспорт
	
	Результат = "";
	
	Если ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
		Результат = ПолучитьBase64СтрокуИзДвоичныхДанных(Данные);
		Результат = СтрЗаменить(Результат, Символы.ПС, "");
		Результат = СтрЗаменить(Результат, Символы.ВК, "");
		Результат = СтрЗаменить(Результат, " ", "");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает временный рабочий каталог.
// Каталог создается в каталоге временных файлов системы или ином предопределенном каталоге.
//
// Возвращаемое значение:
//  Строка - временный каталог.
//
Функция ВременныйКаталог() Экспорт
	
	ИмяКаталога = ПолучитьИмяВременногоФайла() + ПолучитьРазделительПути();
	СоздатьКаталог(ИмяКаталога);
	Возврат ИмяКаталога;
	
КонецФункции

// Возвращает имя временного файла.
//
// Параметры:
//  Расширение - Строка - расширение файла
// 
// Возвращаемое значение:
//  Строка
Функция ТекущееИмяВременногоФайла(Расширение = "") Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла(Расширение);
	
	Возврат ИмяВременногоФайла;
	
КонецФункции

// Удаляет временные файлы или каталог.
//
// Параметры:
//  Путь - Строка - полный путь к файлу или каталогу
//  Маска - Строка - маска для выбора удаляемых файлов,
//        - Неопределено - удаляются все файлы и каталог <Путь>.
//
Процедура УдалитьВременныеФайлы(Путь, Маска = Неопределено) Экспорт
	
	Попытка
		УдалитьФайлы(Путь, Маска);
	Исключение
		ВидОперации = НСтр("ru = 'Удаление временного файла.'");
		ПодробныйТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ОбработкаНеисправностейБЭД.ОбработатьОшибку(ВидОперации, ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().ЭлектронноеВзаимодействие, ПодробныйТекстОшибки);
	КонецПопытки;
	
КонецПроцедуры

// Производит попытку создать файл по переданному пути. Если путь не передан, получает имя временного 
// файла самостоятельно.
// 
// Параметры:
// 	ИмяФайла - Строка
// Возвращаемое значение:
// 	Строка - имя созданного файла
Функция СоздатьТестовыйФайл(ИмяФайла = "") Экспорт
	
	Если ИмяФайла = "" Тогда
		ИмяФайла = ПолучитьИмяВременногоФайла("tmp");
	КонецЕсли;
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла);
	ЗаписьТекста.ЗаписатьСтроку(ИмяФайла);
	ЗаписьТекста.Закрыть();
		
	Возврат ИмяФайла;
	
КонецФункции

// Формирует zip архив. Если параметр ИмяФайла заполнен записывает архив по указанному пути.
// 
// Параметры:
// 	МассивФайлов - Массив из Строка - полные имена файлов (или маски), которые необходимо поместить в архив.
// 	ИмяФайла - Строка - имя файла для записи сформированного архива, если не задан, функция возвращает двоичные данные
// 	ПараметрыФормирования - см. НовыеПараметрыФормированияАрхива
// Возвращаемое значение:
// 	- Строка - имя файла сформированного архива
// 	- ДвоичныеДанные - сформированный архив в виде двоичных данных
// 	- Неопределено - архив не удалось сформировать
Функция СформироватьАрхивФайлов(МассивФайлов, ИмяФайла = Неопределено, ПараметрыФормирования = Неопределено) Экспорт
	
	Если ПараметрыФормирования = Неопределено Тогда
		ПараметрыФормирования = НовыеПараметрыФормированияАрхива();
	КонецЕсли;
	ЗаписьВФайл = ИмяФайла <> Неопределено;
	Попытка
		Если ЗаписьВФайл Тогда
			ЗаписьАрхива = Новый ЗаписьZIPФайла(ИмяФайла);
		Иначе
			ЗаписьАрхива = Новый ЗаписьZIPФайла();
		КонецЕсли;
		
		Для Каждого ИмяДобавляемогоФайла Из МассивФайлов Цикл
			ЗаписьАрхива.Добавить(ИмяДобавляемогоФайла, ПараметрыФормирования.РежимСохраненияПутей,
				ПараметрыФормирования.РежимОбработкиПодкаталогов);
		КонецЦикла;
		Если ЗаписьВФайл Тогда
			ЗаписьАрхива.Записать();
			Возврат ИмяФайла;
		Иначе
			Возврат ЗаписьАрхива.ПолучитьДвоичныеДанные();
		КонецЕсли;
	Исключение
		ТекстСообщения = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()) + Символы.ПС
			+ НСтр("ru = 'Проверьте поддержку русского языка в региональных настройках ОС для non-Unicode programs
			|и наличие доступа к каталогу временных файлов.'");
		ЭлектронноеВзаимодействие.ОбработатьОшибку(НСтр("ru = 'запись файла архива на диск'"),
																					ТекстОшибки,
																					ТекстСообщения);
		
		Возврат ?(ЗаписьВФайл, "", Неопределено);
		
	КонецПопытки;
	
КонецФункции

// Возвращает параметры формирования архива, см. СформироватьАрхивФайлов.
// 
// Возвращаемое значение:
// 	Структура:
// * РежимОбработкиПодкаталогов - РежимСохраненияПутейZIP
// * РежимСохраненияПутей - РежимОбработкиПодкаталоговZIP
Функция НовыеПараметрыФормированияАрхива() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("РежимСохраненияПутей", РежимСохраненияПутейZIP.НеСохранятьПути);
	Параметры.Вставить("РежимОбработкиПодкаталогов", РежимОбработкиПодкаталоговZIP.НеОбрабатывать);
	
	Возврат Параметры;
	
КонецФункции

// Возвращает уникальный идентификатор для использования в качестве части имени файла.
// 
// Возвращаемое значение:
// 	Строка
Функция НовыйUUID() Экспорт
	
	Возврат НРег(СтрЗаменить(Строка(Новый("УникальныйИдентификатор")), "-", ""));
	
КонецФункции

// Записывает текст в файл.
// 
// Параметры:
// 	Текст - Строка
// 	ИмяФайла - Строка
// 	Кодировка - Строка, КодировкаТекста -
Процедура ЗаписатьТекстВФайл(Текст, ИмяФайла, Кодировка = Неопределено) Экспорт
	
	Если Кодировка = Неопределено Тогда
		ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла);
	Иначе
		ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, Кодировка);
	КонецЕсли;
	ЗаписьТекста.Записать(Текст);
	ЗаписьТекста.Закрыть();
	
КонецПроцедуры

// Записывает двоичные данные в файл и возвращает результат.
// 
// Параметры:
// 	ДвоичныеДанные - ДвоичныеДанные
// 	ИмяФайла - Строка
// 	КонтекстДиагностики - см. ОбработкаНеисправностейБЭД.НовыйКонтекстДиагностики
// Возвращаемое значение:
// 	Булево - двоичные данные записаны в файл
Функция ЗаписатьДвоичныеДанные(ДвоичныеДанные, ИмяФайла, КонтекстДиагностики) Экспорт
	
	Если Не ДлинаФайлаДопустима(ИмяФайла, КонтекстДиагностики) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДвоичныеДанные.Записать(ИмяФайла);
	
	Возврат Истина;
	
КонецФункции

// Возвращает пустую структуру описания файла.
// 
// Возвращаемое значение:
//  См. РаботаСФайламиБЭДКлиентСервер.НовоеОписаниеФайла
//
Функция НовоеОписаниеФайла() Экспорт
	
	Возврат РаботаСФайламиБЭДКлиентСервер.НовоеОписаниеФайла();
		
КонецФункции

// Возвращает данные файла.
//
// Параметры:
// 	Файл - Файл, Строка - Файл или полное имя файла.
//
// Возвращаемое значение:
// 	Структура - Данные файла:
// 	 * ИмяФайла - Строка - Имя файла.
//   * ИмяБезРасширения - Строка - Имя файла без расширения.
//   * Расширение - Строка - Расширение файла.
//   * Размер - Число - Размер файла в байтах.
//
Функция ДанныеФайла(Знач Файл) Экспорт
	
	Если ТипЗнч(Файл) = Тип("Строка") Тогда
		Файл = Новый Файл(Файл);
	КонецЕсли;
	
	ДанныеФайла = Новый Структура;
	ДанныеФайла.Вставить("ИмяФайла", Файл.Имя);
	ДанныеФайла.Вставить("ИмяБезРасширения", Файл.ИмяБезРасширения);
	ДанныеФайла.Вставить("Расширение", Сред(Файл.Расширение, 2));
	ДанныеФайла.Вставить("Размер", Файл.Размер());
	
	Возврат ДанныеФайла;
	
КонецФункции

// Параметры:
//  ПомещенныйФайл - Структура - результат выполнения функции БСП См. ФайловаяСистемаКлиент.ЗагрузитьФайл:
//  * Хранение - Строка - расположение данных во временном хранилище.
//  * Имя - Строка - в тонком клиенте и в веб-клиенте с установленным
//                   расширением работы с файлами - локальный путь, по которому
//                   был получен файл. В веб-клиенте без расширения для работы с 1С:Предприятием
//                   передается имя файла с расширением.
// 
// Возвращаемое значение:
//  См. НовоеОписаниеФайла
Функция ОписаниеФайлаПоДаннымПомещенногоФайла(ПомещенныйФайл) Экспорт
	
	ОписаниеФайла = НовоеОписаниеФайла();

	СтруктураИмениВыбранногоФайла = ОбщегоНазначенияКлиентСервер.РазложитьПолноеИмяФайла(ПомещенныйФайл.Имя);
	
	ОписаниеФайла.ДвоичныеДанные = ПолучитьИзВременногоХранилища(ПомещенныйФайл.Хранение);
	ОписаниеФайла.ИмяФайла = СтруктураИмениВыбранногоФайла.Имя;
	
	Возврат ОписаниеФайла;
	
КонецФункции

#КонецОбласти

#Область Архивы

// Определяет возможно ли без ошибки извлечь файлы из архива.
// Проверяется максимальная длина полного имени файла в 255 символов.
// 
// Параметры:
//  АрхивЧтение - ЧтениеZIPФайла - открытый zip архив.
//  КаталогРаспаковки - Строка - папка, в которую будут извлечены данные.
//
// Возвращаемое значение:
//  Булево - если возможно то Истина, иначе Ложь.
//
Функция ВозможноИзвлечьФайлы(АрхивЧтение, КаталогРаспаковки) Экспорт
	
	ДлинаПутиПапки = СтрДлина(КаталогРаспаковки);
	
	Для Каждого Элемент Из АрхивЧтение.Элементы Цикл
		ИмяФайла = Элемент.ПолноеИмя;
		ДлинаИмениФайла = СтрДлина(ИмяФайла);
		ПолнаяДлина = ДлинаПутиПапки + ДлинаИмениФайла + 1;
		// Для некоторых файловых систем ограничение длины имени измеряется не в символах, а в байтах.
		// При этом:
		// 1. Кодирование символа может занимать от 1 до 4х байт в зависимости от кодировки.
		// 2. Излишне усложнять алгоритм, вычисляя точное количество байт в имени файла, в данном случае нецелесообразно.
		// 3. Для подавляющего большинства случаев в среднем 2х байт на 1 символ будет достаточно.
		// Поэтому максимальная длина в символах делится на условные 2 байта на символ.
		Если ПолнаяДлина > МаксимальнаяДлинаИмениФайла()/2 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Извлекает файлы из архива.
// 
// Параметры:
// 	Архив - ДвоичныеДанные
// 	КаталогРаспаковки - Строка
// 	КонтекстДиагностики - см. ОбработкаНеисправностейБЭД.НовыйКонтекстДиагностики
// 	                    - Неопределено - контекст диагностики не используется, ошибка будет выведена в сообщении.
// 	ВидОперации - Строка - операция, в рамках которой происходит распаковка
// 	ПараметрыРаспаковки - см. НовыеПараметрыРаспаковкиАрхива
// 	ДополнительныеСвойстваОшибки - Произвольный - дополнительные свойства, которые будут присвоены ошибке, возникшей
// 	                                              при распаковке.
// Возвращаемое значение:
// 	- Массив из Файл - распакованные файлы
// 	- Неопределено - если архив распаковать не удалось
Функция РаспаковатьАрхив(Архив, КаталогРаспаковки, КонтекстДиагностики, ВидОперации = "",
	ПараметрыРаспаковки = Неопределено, ДополнительныеСвойстваОшибки = Неопределено) Экспорт
	
	ЕстьОшибка = Ложь;
	ДополнительныеПараметрыОшибки = Новый Структура;
	ДополнительныеПараметрыОшибки.Вставить("ДополнительныеДанные", ДополнительныеСвойстваОшибки);
		
	Если ПараметрыРаспаковки = Неопределено Тогда
		ПараметрыРаспаковки = НовыеПараметрыРаспаковкиАрхива();
	КонецЕсли;
	Если ВидОперации = "" Тогда
		ВидОперации = НСтр("ru = 'Распаковка zip-архива'");
	КонецЕсли;
	
	Поток = Новый ПотокВПамяти;
	Архив.Записать(Поток);
	ЧтениеZip = Новый ЧтениеZipФайла(Поток);
	
	Если ЕстьОдинаковыеИменаФайловСНедопустимымиСимволамиВАрхиве(ЧтениеZip) Тогда
		ЕстьОшибка = Истина;
		ТекстОшибки = НСтр("ru = 'Архив содержит файлы с недопустимыми символами. Распаковка невозможна.'");
		
		ВидОшибки = ОбработкаНеисправностейБЭДКлиентСервер.ВидОшибкиНеизвестнаяОшибка();
		Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(ВидОперации,
			ВидОшибки, ТекстОшибки, ТекстОшибки, ДополнительныеПараметрыОшибки);
		ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
			ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().ОбменСКонтрагентами);
	КонецЕсли;
	
	Если Не ЕстьОшибка Тогда
		Попытка
			ЧтениеZip.ИзвлечьВсе(КаталогРаспаковки, ПараметрыРаспаковки.ВосстанавливатьКаталоги);
		Исключение
			ЕстьОшибка = Истина;
			ТекстОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
			ТекстСообщения = НСтр("ru = 'Невозможно распаковать zip-архив.'");
			
			ВидОшибки = ОбработкаНеисправностейБЭДКлиентСервер.ВидОшибкиНеизвестнаяОшибка();
			Если ЧтениеZip <> Неопределено Тогда
				Если Не ВозможноИзвлечьФайлы(ЧтениеZip, КаталогРаспаковки) Тогда
					Если ТипЗнч(ДополнительныеСвойстваОшибки) = Тип("Структура")
						И ДополнительныеСвойстваОшибки.Свойство("ТекстСообщения") Тогда
						ТекстСообщения = ТекстСообщения + Символы.ПС + НСтр("ru = 'Имя файла превысило максимально допустимую длину.'");
						ТекстСообщения = ТекстСообщения + Символы.ПС + ДополнительныеСвойстваОшибки.ТекстСообщения;
					Иначе 
						ТекстСообщения = ОбработкаНеисправностейБЭД.ПолучитьСообщениеОбОшибкеДругойСистемы("006");
					КонецЕсли;
					ВидОшибки = РаботаСФайламиБЭДКлиентСервер.ВидОшибкиРаботаСФайлами();
				КонецЕсли;
			КонецЕсли;
		
			Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(ВидОперации, ВидОшибки, ТекстОшибки, ТекстСообщения,
				ДополнительныеПараметрыОшибки);
			ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
				ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
		КонецПопытки;
	КонецЕсли;
	
	Если ЧтениеZip <> Неопределено Тогда
		ЧтениеZip.Закрыть();
	КонецЕсли;
	Если Поток <> Неопределено Тогда
		Поток.Закрыть();
	КонецЕсли;
	
	Если ЕстьОшибка Тогда
		Возврат Неопределено;
	Иначе
		Возврат НайтиФайлы(КаталогРаспаковки, ПолучитьМаскуВсеФайлы(), Истина);
	КонецЕсли;
	
КонецФункции

// Возвращает параметры распаковки архива, см. РаспаковатьАрхив.
// 
// Возвращаемое значение:
// 	Структура:
// * ВосстанавливатьКаталоги - РежимВосстановленияПутейФайловZIP
Функция НовыеПараметрыРаспаковкиАрхива() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ВосстанавливатьКаталоги", РежимВосстановленияПутейФайловZIP.Восстанавливать);
	
	Возврат Параметры;
	
КонецФункции

// Исправляет значение полей архива для возможности чтения на Linux
//
// Параметры:
//  ДанныеАрхива - ДвоичныеДанные - данные zip архива.
//  
// Возвращаемое значение:
// - ДвоичныеДанные - исправленный архив
// - Строка - описание ошибки, если таковая происходит при чтении архива
//
Функция ИсправитьСигнатуруАрхиваДляЧтенияВLinux(ДанныеАрхива) Экспорт
	
	// Значение поля "ВнутренниеАтрибуты" для архива (число 16 бит без знака)
	ЗначениеВнутреннихАтрибутов = 0;
	// Значение поля "ВнешниеАтрибуты" для архива (число 32 бита)
	ЗначениеВнешнихАтрибутов = 2176843776;
	
	Если ТипЗнч(ДанныеАрхива) <> Тип("ДвоичныеДанные") Тогда
		ТекстСообщения = СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для двоичных данных архива.'"),
			Строка(ТипЗнч(ДанныеАрхива)));
		Возврат ТекстСообщения;
	КонецЕсли;
	
	Попытка
		Поток = ДанныеАрхива.ОткрытьПотокДляЧтения();
		ПотокРезультата = Новый ПотокВПамяти;
		
		ПозицияНачалаБлока = 0;
		
		ТекущаяСигнатура = ПрочитатьНатуральноеЧислоИзПотока(Поток, 4);
		ЗаписатьНатуральноеЧислоВПоток(ПотокРезультата, ТекущаяСигнатура, 4);
		
		Если ТекущаяСигнатура <> 67324752 Тогда
			ВызватьИсключение НСтр("ru = 'Неверная сигнатура архива:'") + Строка(ТекущаяСигнатура);
		КонецЕсли;
	
	
		МассивФайлов = Новый Массив;
	
		Пока Истина Цикл
			// Заголовок файла архива:
			// (1) Минимальная версия: 2 байта
			// (2) Регистр флагов: 2 байта
			// (3) Метод сжатия: 2 байта
			// (4) Время модификации файла: 2 байта
			// (5) Дата модификации файла: 2 байта
			// (6) Контрольная сумма: 4 байта
			// (7) Сжатый размер: 4 байта
			// (8) Несжатый размер: 4 байта
			// (9) Длина имени файла: 2 байта
			// (10) Длина поля дополнительных данных: 2 байта
		
			БуферЗаголовка = ПрочитатьБуферИзПотока(Поток, 26);
		
			Попытка
				// Минимальная версия
				МинимальнаяВерсия = БуферЗаголовка.ПрочитатьЦелое16(0, ПорядокБайтов.LittleEndian);
				// Регистр флагов
				РегистрФлагов = БуферЗаголовка.ПрочитатьЦелое16(2, ПорядокБайтов.LittleEndian);
				// Метод сжатия
				МетодСжатия = БуферЗаголовка.ПрочитатьЦелое16(4, ПорядокБайтов.LittleEndian);
				// Время модификации файла
				ВремяМодификацииФайла = БуферЗаголовка.ПрочитатьЦелое16(6, ПорядокБайтов.LittleEndian);
				// Дата модификации файла
				ДатаМодификацииФайла = БуферЗаголовка.ПрочитатьЦелое16(8, ПорядокБайтов.LittleEndian);
				// Контрольная сумма файла
				КонтрольнаяСумма = БуферЗаголовка.ПрочитатьЦелое32(10, ПорядокБайтов.LittleEndian);
				// Сжатый размер
				СжатыйРазмер = БуферЗаголовка.ПрочитатьЦелое32(14, ПорядокБайтов.LittleEndian);
				// Несжатый размер
				НесжатыйРазмер = БуферЗаголовка.ПрочитатьЦелое32(18, ПорядокБайтов.LittleEndian);
				// Длина имени файла
				ДлинаИмениФайла = БуферЗаголовка.ПрочитатьЦелое16(22, ПорядокБайтов.LittleEndian);
				// Длина дополнительных данных
				ДлинаДополнительныхДанных = БуферЗаголовка.ПрочитатьЦелое16(24, ПорядокБайтов.LittleEndian);
			Исключение
				ВызватьИсключение НСтр("ru = 'Ошибка при получении значений из структуры заголовка файла:'")
					+ Символы.ПС + ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			КонецПопытки;
		
			Если МетодСжатия = 0 Тогда
				ЕстьСжатие = Ложь;
			ИначеЕсли МетодСжатия = 8 Тогда
				ЕстьСжатие = Истина;
			Иначе
				ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверное значение: %1 для метода сжатия.'"), Строка(МетодСжатия));
			КонецЕсли;
		
			Если ДлинаИмениФайла < 1 Тогда
				ВызватьИсключение НСтр("ru = 'Нулевая длина имени файла недопустима.'");
			КонецЕсли;
		
			БуферИмени = ПрочитатьБуферИзПотока(Поток, ДлинаИмениФайла);
			
			Если ДлинаДополнительныхДанных > 0 Тогда
				БуферДополнительныхДанных = ПрочитатьБуферИзПотока(Поток, ДлинаДополнительныхДанных);
			Иначе
				БуферДополнительныхДанных = Неопределено;
			КонецЕсли;
			
			ЗаписатьБуферВПоток(ПотокРезультата, БуферЗаголовка);
			ЗаписатьБуферВПоток(ПотокРезультата, БуферИмени);
			
			Если БуферДополнительныхДанных <> Неопределено Тогда
				ЗаписатьБуферВПоток(ПотокРезультата, БуферДополнительныхДанных);
			КонецЕсли;
		
			Если ЕстьСжатие Тогда
				РазмерДанныхФайла = СжатыйРазмер;
			Иначе
				РазмерДанныхФайла = НесжатыйРазмер;
			КонецЕсли;
			
			Если РазмерДанныхФайла > 0 Тогда
				ПрямоеКопированиеВПоток(Поток, ПотокРезультата, РазмерДанныхФайла);
			КонецЕсли;
			
			ДанныеФайла = Новый Структура;
			ДанныеФайла.Вставить("Offset", ПозицияНачалаБлока);
			ДанныеФайла.Вставить("Compress", ЕстьСжатие);
			ДанныеФайла.Вставить("MinVer", МинимальнаяВерсия);
			ДанныеФайла.Вставить("Flags", РегистрФлагов);
			ДанныеФайла.Вставить("Date", ДатаМодификацииФайла);
			ДанныеФайла.Вставить("Time", ВремяМодификацииФайла);
			ДанныеФайла.Вставить("CRC32", КонтрольнаяСумма);
			ДанныеФайла.Вставить("Name", БуферИмени);
			ДанныеФайла.Вставить("Extra", БуферДополнительныхДанных);
			
			МассивФайлов.Добавить(ДанныеФайла);
			
			ПозицияНачалаБлока = Поток.ТекущаяПозиция();
			
			ТекущаяСигнатура = ПрочитатьНатуральноеЧислоИзПотока(Поток, 4);
			ЗаписатьНатуральноеЧислоВПоток(ПотокРезультата, ТекущаяСигнатура, 4);
			
			Если ТекущаяСигнатура = 67324752 Тогда
				Продолжить;
			ИначеЕсли ТекущаяСигнатура = 33639248 Тогда
				Прервать;
			Иначе
				ВызватьИсключение НСтр("ru = 'Неизвестная структура по сигнатуре:'") + Строка(ТекущаяСигнатура);
			КонецЕсли;
		КонецЦикла;
		
		НомерФайла = 0;
		МассивПроверки = Новый Массив;
		НачалоКаталога = ПозицияНачалаБлока;
		
		Пока Истина Цикл
			// (1) Версия для создания: 2 байта
			// (2) Минимальная версия: 2 байта
			// (3) Регистр флагов: 2 байта
			// (4) Метод сжатия: 2 байта
			// (5) Время модификации файла: 2 байта
			// (6) Дата модификации файла: 2 байта
			// (7) Контрольная сумма: 4 байта
			// (8) Сжатый размер: 4 байта
			// (9) Несжатый размер: 4 байта
			// (10) Длина имени файла: 2 байта
			// (11) Длина дополнительных данных: 2 байта
			// (12) Длина комментария: 2 байта
			// (13) Номер диска: 2 байта
			// (14) Внутренние атрибуты файла: 2 байта
			// (15) Внешние атрибуты файла: 4 байта
			// (16) Смещение до начала записи файла: 4 байта
			
			БуферЗаголовка = ПрочитатьБуферИзПотока(Поток, 42);
			
			Попытка
				// (1) Версия для создания: 2 байта
				ВерсияСозданияФайла = БуферЗаголовка.ПрочитатьЦелое16(0, ПорядокБайтов.LittleEndian);
				// (2) Минимальная версия: 2 байта
				МинимальнаяВерсия = БуферЗаголовка.ПрочитатьЦелое16(2, ПорядокБайтов.LittleEndian);
				// (3) Регистр флагов: 2 байта
				РегистрФлагов = БуферЗаголовка.ПрочитатьЦелое16(4, ПорядокБайтов.LittleEndian);
				// (4) Метод сжатия: 2 байта
				МетодСжатия = БуферЗаголовка.ПрочитатьЦелое16(6, ПорядокБайтов.LittleEndian);
				// (5) Время модификации файла: 2 байта
				ВремяМодификацииФайла = БуферЗаголовка.ПрочитатьЦелое16(8, ПорядокБайтов.LittleEndian);
				// (6) Дата модификации файла: 2 байта
				ДатаМодификацииФайла = БуферЗаголовка.ПрочитатьЦелое16(10, ПорядокБайтов.LittleEndian);
				// (7) Контрольная сумма: 4 байта
				КонтрольнаяСумма = БуферЗаголовка.ПрочитатьЦелое32(12, ПорядокБайтов.LittleEndian);
				// (8) Сжатый размер: 4 байта
				СжатыйРазмер = БуферЗаголовка.ПрочитатьЦелое32(16, ПорядокБайтов.LittleEndian);
				// (9) Несжатый размер: 4 байта
				НесжатыйРазмер = БуферЗаголовка.ПрочитатьЦелое32(20, ПорядокБайтов.LittleEndian);
				// (10) Длина имени файла: 2 байта
				ДлинаИмениФайла = БуферЗаголовка.ПрочитатьЦелое16(24, ПорядокБайтов.LittleEndian);
				// (11) Длина дополнительных данных: 2 байта
				ДлинаДополнительныхДанных = БуферЗаголовка.ПрочитатьЦелое16(26, ПорядокБайтов.LittleEndian);
				// (12) Длина комментария: 2 байта
				ДлинаКомментария = БуферЗаголовка.ПрочитатьЦелое16(28, ПорядокБайтов.LittleEndian);
				// (13) Номер диска: 2 байта
				НомерДиска = БуферЗаголовка.ПрочитатьЦелое16(30, ПорядокБайтов.LittleEndian);
				// (14) Внутренние атрибуты файла: 2 байта
				ВнутренниеАтрибуты = БуферЗаголовка.ПрочитатьЦелое16(32, ПорядокБайтов.LittleEndian);
				// (15) Внешние атрибуты файла: 4 байта
				ВнешниеАтрибуты = БуферЗаголовка.ПрочитатьЦелое32(34, ПорядокБайтов.LittleEndian);
				// (16) Смещение до начала записи файла: 4 байта
				СмещениеДоНачала = БуферЗаголовка.ПрочитатьЦелое32(38, ПорядокБайтов.LittleEndian);
			Исключение
				ВызватьИсключение НСтр("ru = 'Ошибка при чтении полей структуры каталога для файла:'")
					+ Символы.ПС + ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			КонецПопытки;
			
			Если МетодСжатия = 0 Тогда
				ЕстьСжатие = Ложь;
			ИначеЕсли МетодСжатия = 8 Тогда
				ЕстьСжатие = Истина;
			Иначе
				ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверное значение: %1 для метода сжатия в каталоге файла.'"),
					Строка(МетодСжатия));
			КонецЕсли;
			
			Если ДлинаИмениФайла < 1 Тогда
				ВызватьИсключение НСтр("ru = 'Указана нулевая длина имени файла.'");
			КонецЕсли;
			
			БуферИмени = ПрочитатьБуферИзПотока(Поток, ДлинаИмениФайла);
			
			Если ДлинаДополнительныхДанных > 0 Тогда
				БуферДополнительныхДанных = ПрочитатьБуферИзПотока(Поток, ДлинаДополнительныхДанных);
			Иначе
				БуферДополнительныхДанных = Неопределено;
			КонецЕсли;
			
			Если ДлинаКомментария > 0 Тогда
				БуферКомментария = ПрочитатьБуферИзПотока(Поток, ДлинаКомментария);
			Иначе
				БуферКомментария = Неопределено;
			КонецЕсли;
			
			Если МассивФайлов.Количество() <= НомерФайла Тогда
				ВызватьИсключение СтрШаблон(НСтр("ru = 'Обнаружено файлов: %1, но найдена запись каталога файла: %2.'"),
					Строка(МассивФайлов.Количество()), Строка(НомерФайла));
			КонецЕсли;
			
			ДанныеФайла = МассивФайлов[НомерФайла];
			НомерФайла = НомерФайла + 1;
			
			ДанныеФайла.Вставить("Ver", ВерсияСозданияФайла);
			ДанныеФайла.Вставить("Comment", БуферКомментария);
			ДанныеФайла.Вставить("IntAttr", ВнутренниеАтрибуты);
			ДанныеФайла.Вставить("ExtAttr", ВнешниеАтрибуты);
			
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Offset", СмещениеДоНачала, МассивПроверки);
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "MinVer", МинимальнаяВерсия, МассивПроверки);
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Compress", ЕстьСжатие, МассивПроверки);
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Flags", РегистрФлагов, МассивПроверки);
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Date", ДатаМодификацииФайла, МассивПроверки);
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Time", ВремяМодификацииФайла, МассивПроверки);
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "CRC32", КонтрольнаяСумма, МассивПроверки);
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Name", БуферИмени, МассивПроверки);
			ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Extra", БуферДополнительныхДанных, МассивПроверки);
			
			Если МассивПроверки.Количество() > 0 Тогда
				ВызватьИсключение НСтр("ru = 'Ошибка при сравнении записи файла и записи каталога файла:'")
					+ Символы.ПС + СтрСоединить(МассивПроверки, Символы.ПС);
			КонецЕсли;
			
			// (14) Внутренние атрибуты файла: 2 байта
			БуферЗаголовка.ЗаписатьЦелое16(32, ЗначениеВнутреннихАтрибутов, ПорядокБайтов.LittleEndian);
			// (15) Внешние атрибуты файла: 4 байта
			БуферЗаголовка.ЗаписатьЦелое32(34, ЗначениеВнешнихАтрибутов, ПорядокБайтов.LittleEndian);
			
			ЗаписатьБуферВПоток(ПотокРезультата, БуферЗаголовка);
			ЗаписатьБуферВПоток(ПотокРезультата, БуферИмени);
			
			Если БуферДополнительныхДанных <> Неопределено Тогда
				ЗаписатьБуферВПоток(ПотокРезультата, БуферДополнительныхДанных);
			КонецЕсли;
			
			Если БуферКомментария <> Неопределено Тогда
				ЗаписатьБуферВПоток(ПотокРезультата, БуферКомментария);
			КонецЕсли;
			
			ПозицияНачалаБлока = Поток.ТекущаяПозиция();
			
			ТекущаяСигнатура = ПрочитатьНатуральноеЧислоИзПотока(Поток, 4);
			ЗаписатьНатуральноеЧислоВПоток(ПотокРезультата, ТекущаяСигнатура, 4);
			
			Если ТекущаяСигнатура = 33639248 Тогда
				Продолжить;
			ИначеЕсли ТекущаяСигнатура = 101010256 Тогда
				Прервать;
			Иначе
				ВызватьИсключение НСтр("ru = 'Неизвестная структура по сигнатуре:'") + Строка(ТекущаяСигнатура);
			КонецЕсли;
		КонецЦикла;
		
		// Номер диска: 2 байта
		// Номер диска начала директории: 2 байта
		// Количество записей текущего диска: 2 байта
		// Всего записей: 2 байта
		// Размер директории: 4 байта
		// Смещение директории: 4 байта
		// Длина комментария: 2 байта
		
		БуферЗаголовка = ПрочитатьБуферИзПотока(Поток, 18);
		
		Попытка
			// Номер диска: 2 байта
			НомерДиска = БуферЗаголовка.ПрочитатьЦелое16(0, ПорядокБайтов.LittleEndian);
			// Номер диска начала директории: 2 байта
			НомерДискаНачала = БуферЗаголовка.ПрочитатьЦелое16(2, ПорядокБайтов.LittleEndian);
			// Количество записей текущего диска: 2 байта
			КоличествоЗаписейТекущегоДиска = БуферЗаголовка.ПрочитатьЦелое16(4, ПорядокБайтов.LittleEndian);
			// Всего записей: 2 байта
			КоличествоЗаписей = БуферЗаголовка.ПрочитатьЦелое16(6, ПорядокБайтов.LittleEndian);
			// Размер директории: 4 байта
			ОбщийРазмерДиректории = БуферЗаголовка.ПрочитатьЦелое32(8, ПорядокБайтов.LittleEndian);
			// Смещение директории: 4 байта
			СмещениеДиректории = БуферЗаголовка.ПрочитатьЦелое32(12, ПорядокБайтов.LittleEndian);
			// Длина комментария: 2 байта
			ДлинаКомментария = БуферЗаголовка.ПрочитатьЦелое16(16, ПорядокБайтов.LittleEndian);
		Исключение
			ВызватьИсключение НСтр("ru = 'Ошибка при чтении полей из буфера окончания:'")
				+ Символы.ПС + ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		КонецПопытки;
		
		Если ДлинаКомментария > 0 Тогда
			БуферКомментария = ПрочитатьБуферИзПотока(Поток, ДлинаКомментария);
		Иначе
			БуферКомментария = Неопределено;
		КонецЕсли;
		
		ЗаписатьБуферВПоток(ПотокРезультата, БуферЗаголовка);
		
		Если БуферКомментария <> Неопределено Тогда
			ЗаписатьБуферВПоток(ПотокРезультата, БуферКомментария);
		КонецЕсли;
		
		Если СмещениеДиректории <> НачалоКаталога Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Указанное начало каталога: %1 отличается от обнаруженного: %2.'"),
				Строка(СмещениеДиректории), Строка(НачалоКаталога));
		КонецЕсли;
		
		Если ПозицияНачалаБлока - НачалоКаталога <> ОбщийРазмерДиректории Тогда
			ВызватьИсключение СтрШаблон(
				НСтр("ru = 'Рассчитанный общий размер каталога: %1 отличается от указанного: %2.'"),
				Строка(ПозицияНачалаБлока - НачалоКаталога), Строка(ОбщийРазмерДиректории));
		КонецЕсли;
		
		Если Поток.Размер() <> Поток.ТекущаяПозиция() Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'После окончания чтения данных позиция: %1 отличается от размера: %2.'"),
				Строка(Поток.ТекущаяПозиция()), Строка(Поток.Размер()));
		КонецЕсли;
		
		Если КоличествоЗаписей <> НомерФайла Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Указанное количество записей: %1 отличается от найденного: %2.'"),
				Строка(КоличествоЗаписей), Строка(НомерФайла));
		КонецЕсли;
		
		Если НомерФайла <> МассивФайлов.Количество() Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Количество записей каталога: %1 отличается от количества файлов: %2.'"),
				 Строка(НомерФайла), Строка(МассивФайлов.Количество()));
		КонецЕсли;
	Исключение
		ТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		Поток.Закрыть();
		ПотокРезультата.Закрыть();
		
		Возврат ТекстОшибки;
	КонецПопытки;
	
	Поток.Закрыть();
	
	НовыеДанные = ПотокРезультата.ЗакрытьИПолучитьДвоичныеДанные();
	
	Возврат НовыеДанные;
КонецФункции

// Читает архив на низком уровне и возвращает его содержимое.
// ВАЖНО. Не реализована распаковка Deflate потока файла.
//
// Параметры:
//  ДанныеАрхива - ДвоичныеДанные - Данные zip архива.
//  
// Возвращаемое значение:
//  см. НовыйРезультатЧтенияАрхива
//
Функция ПрочитатьАрхив(ДанныеАрхива) Экспорт
	
	Результат = НовыйРезультатЧтенияАрхива();
	
	Если ТипЗнч(ДанныеАрхива) <> Тип("ДвоичныеДанные") Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для двоичных данных архива.'"), 
			Строка(ТипЗнч(ДанныеАрхива)));
		Возврат Результат
	КонецЕсли;
	
	Поток = ДанныеАрхива.ОткрытьПотокДляЧтения();
	
	ПозицияНачалаБлока = 0;
	
	ТекущаяСигнатура = ПрочитатьНатуральноеЧислоИзПотока(Поток, 4);
	
	Если ТипЗнч(ТекущаяСигнатура) <> Тип("Число") Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Ошибка при чтении сигнатуры архива: %1'"),
			Строка(ТекущаяСигнатура));
		Возврат Результат;
	КонецЕсли;
	
	Если ТекущаяСигнатура <> 67324752 Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Неверная сигнатура архива: %1'"),
			Строка(ТекущаяСигнатура));
		Возврат Результат;
	КонецЕсли;
	
	МассивФайлов = Результат.Файлы;
	
	Пока Истина Цикл
		// Заголовок файла архива:
		// (1) Минимальная версия: 2 байта
		// (2) Регистр флагов: 2 байта
		// (3) Метод сжатия: 2 байта
		// (4) Время модификации файла: 2 байта
		// (5) Дата модификации файла: 2 байта
		// (6) Контрольная сумма: 4 байта
		// (7) Сжатый размер: 4 байта
		// (8) Несжатый размер: 4 байта
		// (9) Длина имени файла: 2 байта
		// (10) Длина поля дополнительных данных: 2 байта
	
		БуферЗаголовка = ПрочитатьБуферИзПотока(Поток, 26);
	
		Если ТипЗнч(БуферЗаголовка) <> Тип("БуферДвоичныхДанных") Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Ошибка при чтении заголовка файла: %1'"),
				Строка(БуферЗаголовка));
			Возврат Результат;
		КонецЕсли;
	
		Попытка
			// Минимальная версия
			МинимальнаяВерсия = БуферЗаголовка.ПрочитатьЦелое16(0, ПорядокБайтов.LittleEndian);
			// Регистр флагов
			РегистрФлагов = БуферЗаголовка.ПрочитатьЦелое16(2, ПорядокБайтов.LittleEndian);
			// Метод сжатия
			МетодСжатия = БуферЗаголовка.ПрочитатьЦелое16(4, ПорядокБайтов.LittleEndian);
			// Время модификации файла
			ВремяМодификацииФайла = БуферЗаголовка.ПрочитатьЦелое16(6, ПорядокБайтов.LittleEndian);
			// Дата модификации файла
			ДатаМодификацииФайла = БуферЗаголовка.ПрочитатьЦелое16(8, ПорядокБайтов.LittleEndian);
			// Контрольная сумма файла
			КонтрольнаяСумма = БуферЗаголовка.ПрочитатьЦелое32(10, ПорядокБайтов.LittleEndian);
			// Сжатый размер
			СжатыйРазмер = БуферЗаголовка.ПрочитатьЦелое32(14, ПорядокБайтов.LittleEndian);
			// Несжатый размер
			НесжатыйРазмер = БуферЗаголовка.ПрочитатьЦелое32(18, ПорядокБайтов.LittleEndian);
			// Длина имени файла
			ДлинаИмениФайла = БуферЗаголовка.ПрочитатьЦелое16(22, ПорядокБайтов.LittleEndian);
			// Длина дополнительных данных
			ДлинаДополнительныхДанных = БуферЗаголовка.ПрочитатьЦелое16(24, ПорядокБайтов.LittleEndian);
		Исключение
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка при получении значений из структуры заголовка файла:'"),
				Символы.ПС,
				ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			Возврат Результат;
		КонецПопытки;
	
		Если МетодСжатия = 0 Тогда
			ЕстьСжатие = Ложь;
		ИначеЕсли МетодСжатия = 8 Тогда
			ЕстьСжатие = Истина;
		Иначе
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Неверное значение: %1 для метода сжатия.'"),
				Строка(МетодСжатия));
			Возврат Результат;
		КонецЕсли;
	
		Если ДлинаИмениФайла < 1 Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = НСтр("ru = 'Нулевая длина имени файла недопустима.'");
			Возврат Результат;
		КонецЕсли;
	
		БуферИмени = ПрочитатьБуферИзПотока(Поток, ДлинаИмениФайла);
		
		Если ТипЗнч(БуферИмени) <> Тип("БуферДвоичныхДанных") Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка при чтении имени файла:'"),
				Символы.ПС,
				Строка(БуферИмени));
			Возврат Результат;
		КонецЕсли;
	
		Если ДлинаДополнительныхДанных > 0 Тогда
			БуферДополнительныхДанных = ПрочитатьБуферИзПотока(Поток, ДлинаДополнительныхДанных);
			
			Если ТипЗнч(БуферДополнительныхДанных) <> Тип("БуферДвоичныхДанных") Тогда
				Результат.ЕстьОшибка = Истина;
				Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
					НСтр("ru = 'Ошибка при чтении дополнительных данных:'"),
					Символы.ПС,
					Строка(БуферДополнительныхДанных));
				Возврат Результат;
			КонецЕсли;
		Иначе
			БуферДополнительныхДанных = Неопределено;
		КонецЕсли;
	
		Если ЕстьСжатие Тогда
			ПотокАрхива = СкопироватьВНовыйПоток(Поток, СжатыйРазмер);
			
			Если ТипЗнч(ПотокАрхива) <> Тип("ПотокВПамяти") Тогда
				Результат.ЕстьОшибка = Истина;
				Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
					НСтр("ru = 'Ошибка при чтении сжатых данных файла:'"),
					Символы.ПС,
					Строка(ПотокАрхива));
				Возврат Результат;
			КонецЕсли;
			
			ПотокФайла = РаскодироватьDeflateПоток(ПотокАрхива);
			
			Если ТипЗнч(ПотокФайла) <> Тип("ПотокВПамяти") Тогда
				Результат.ЕстьОшибка = Истина;
				Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
					НСтр("ru = 'Ошибка при раскодировании архива:'"),
					Символы.ПС,
					Строка(ПотокФайла));
				Возврат Результат;
			КонецЕсли;
		Иначе
			ПотокФайла = СкопироватьВНовыйПоток(Поток, НесжатыйРазмер);
			
			Если ТипЗнч(ПотокФайла) <> Тип("ПотокВПамяти") Тогда
				Результат.ЕстьОшибка = Истина;
				Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
					НСтр("ru = 'Ошибка при чтении потока несжатого файла:'"),
					Символы.ПС,
					Строка(ПотокФайла));
				Возврат Результат;
			КонецЕсли;
		КонецЕсли;
		
		ДанныеФайла = НовыеДанныеФайлаПриЧтенииАрхива();
		ДанныеФайла.Offset = ПозицияНачалаБлока;
		ДанныеФайла.Compress = ЕстьСжатие;
		ДанныеФайла.MinVer = МинимальнаяВерсия;
		ДанныеФайла.Flags = РегистрФлагов;
		ДанныеФайла.Date = ДатаМодификацииФайла;
		ДанныеФайла.Time = ВремяМодификацииФайла;
		ДанныеФайла.CRC32 = КонтрольнаяСумма;
		ДанныеФайла.Name = БуферИмени;
		ДанныеФайла.Extra = БуферДополнительныхДанных;
		ДанныеФайла.Body = ПотокФайла;
		
		МассивФайлов.Добавить(ДанныеФайла);
		
		ПозицияНачалаБлока = Поток.ТекущаяПозиция();
		
		ТекущаяСигнатура = ПрочитатьНатуральноеЧислоИзПотока(Поток, 4);
		
		Если ТипЗнч(ТекущаяСигнатура) <> Тип("Число") Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка при чтении сигнатуры следующей записи:'"),
				Символы.ПС,
				Строка(ТекущаяСигнатура));
			Возврат Результат;
		КонецЕсли;
		
		Если ТекущаяСигнатура = 67324752 Тогда
			Продолжить;
		ИначеЕсли ТекущаяСигнатура = 33639248 Тогда
			Прервать;
		Иначе
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Неизвестная структура по сигнатуре: %1'"),
				Строка(ТекущаяСигнатура));
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	НомерФайла = 0;
	МассивПроверки = Новый Массив;
	НачалоКаталога = ПозицияНачалаБлока;
	
	Пока Истина Цикл
		// (1) Версия для создания: 2 байта
		// (2) Минимальная версия: 2 байта
		// (3) Регистр флагов: 2 байта
		// (4) Метод сжатия: 2 байта
		// (5) Время модификации файла: 2 байта
		// (6) Дата модификации файла: 2 байта
		// (7) Контрольная сумма: 4 байта
		// (8) Сжатый размер: 4 байта
		// (9) Несжатый размер: 4 байта
		// (10) Длина имени файла: 2 байта
		// (11) Длина дополнительных данных: 2 байта
		// (12) Длина комментария: 2 байта
		// (13) Номер диска: 2 байта
		// (14) Внутренние атрибуты файла: 2 байта
		// (15) Внешние атрибуты файла: 4 байта
		// (16) Смещение до начала записи файла: 4 байта
		
		БуферЗаголовка = ПрочитатьБуферИзПотока(Поток, 42);
		
		Если ТипЗнч(БуферЗаголовка) <> Тип("БуферДвоичныхДанных") Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка при чтении записи каталога для файла:'"),
				Символы.ПС,
				Строка(БуферЗаголовка));
			Возврат Результат;
		КонецЕсли;
		
		Попытка
			
			// (1) Версия для создания: 2 байта
			ВерсияСозданияФайла = БуферЗаголовка.ПрочитатьЦелое16(0, ПорядокБайтов.LittleEndian);
			// (2) Минимальная версия: 2 байта
			МинимальнаяВерсия = БуферЗаголовка.ПрочитатьЦелое16(2, ПорядокБайтов.LittleEndian);
			// (3) Регистр флагов: 2 байта
			РегистрФлагов = БуферЗаголовка.ПрочитатьЦелое16(4, ПорядокБайтов.LittleEndian);
			// (4) Метод сжатия: 2 байта
			МетодСжатия = БуферЗаголовка.ПрочитатьЦелое16(6, ПорядокБайтов.LittleEndian);
			// (5) Время модификации файла: 2 байта
			ВремяМодификацииФайла = БуферЗаголовка.ПрочитатьЦелое16(8, ПорядокБайтов.LittleEndian);
			// (6) Дата модификации файла: 2 байта
			ДатаМодификацииФайла = БуферЗаголовка.ПрочитатьЦелое16(10, ПорядокБайтов.LittleEndian);
			// (7) Контрольная сумма: 4 байта
			КонтрольнаяСумма = БуферЗаголовка.ПрочитатьЦелое32(12, ПорядокБайтов.LittleEndian);
			// (8) Сжатый размер: 4 байта
			СжатыйРазмер = БуферЗаголовка.ПрочитатьЦелое32(16, ПорядокБайтов.LittleEndian);
			// (9) Несжатый размер: 4 байта
			НесжатыйРазмер = БуферЗаголовка.ПрочитатьЦелое32(20, ПорядокБайтов.LittleEndian);
			// (10) Длина имени файла: 2 байта
			ДлинаИмениФайла = БуферЗаголовка.ПрочитатьЦелое16(24, ПорядокБайтов.LittleEndian);
			// (11) Длина дополнительных данных: 2 байта
			ДлинаДополнительныхДанных = БуферЗаголовка.ПрочитатьЦелое16(26, ПорядокБайтов.LittleEndian);
			// (12) Длина комментария: 2 байта
			ДлинаКомментария = БуферЗаголовка.ПрочитатьЦелое16(28, ПорядокБайтов.LittleEndian);
			// (13) Номер диска: 2 байта
			НомерДиска = БуферЗаголовка.ПрочитатьЦелое16(30, ПорядокБайтов.LittleEndian);
			// (14) Внутренние атрибуты файла: 2 байта
			ВнутренниеАтрибуты = БуферЗаголовка.ПрочитатьЦелое16(32, ПорядокБайтов.LittleEndian);
			// (15) Внешние атрибуты файла: 4 байта
			ВнешниеАтрибуты = БуферЗаголовка.ПрочитатьЦелое32(34, ПорядокБайтов.LittleEndian);
			// (16) Смещение до начала записи файла: 4 байта
			СмещениеДоНачала = БуферЗаголовка.ПрочитатьЦелое32(38, ПорядокБайтов.LittleEndian);
		Исключение
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка при чтении полей структуры каталога для файла:'"),
				Символы.ПС,
				ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			Возврат Результат;
		КонецПопытки;
		
		Если МетодСжатия = 0 Тогда
			ЕстьСжатие = Ложь;
		ИначеЕсли МетодСжатия = 8 Тогда
			ЕстьСжатие = Истина;
		Иначе
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Неверное значение: %1 для метода сжатия в каталоге файла.'"),
				Строка(МетодСжатия));
			Возврат Результат;
		КонецЕсли;
		
		Если ДлинаИмениФайла < 1 Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = НСтр("ru = 'Указана нулевая длина имени файла.'");
			Возврат Результат;
		КонецЕсли;
		
		БуферИмени = ПрочитатьБуферИзПотока(Поток, ДлинаИмениФайла);
		
		Если ТипЗнч(БуферИмени) <> Тип("БуферДвоичныхДанных") Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка чтения имени файла в данных каталога файла:'"),
				Символы.ПС,
				Строка(БуферИмени));
			Возврат Результат;
		КонецЕсли;
		
		Если ДлинаДополнительныхДанных > 0 Тогда
			БуферДополнительныхДанных = ПрочитатьБуферИзПотока(Поток, ДлинаДополнительныхДанных);
			
			Если ТипЗнч(БуферДополнительныхДанных) <> Тип("БуферДвоичныхДанных") Тогда
				Результат.ЕстьОшибка = Истина;
				Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
					НСтр("ru = 'Ошибка чтения дополнительных данных файла:'"),
					Символы.ПС,
					Строка(БуферДополнительныхДанных));
				Возврат Результат;
			КонецЕсли;
		Иначе
			БуферДополнительныхДанных = Неопределено;
		КонецЕсли;
		
		Если ДлинаКомментария > 0 Тогда
			БуферКомментария = ПрочитатьБуферИзПотока(Поток, ДлинаКомментария);
			
			Если ТипЗнч(БуферКомментария) <> Тип("БуферДвоичныхДанных") Тогда
				Результат.ЕстьОшибка = Истина;
				Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
					НСтр("ru = 'Ошибка при чтении комментария из каталога файла:'"),
					Символы.ПС,
					Строка(БуферКомментария));
				Возврат Результат;
			КонецЕсли;
		Иначе
			БуферКомментария = Неопределено;
		КонецЕсли;
		
		Если МассивФайлов.Количество() <= НомерФайла Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон(
				НСтр("ru = 'Обнаружено файлов: %1, но найдена запись каталога файла: %2'"),
				Строка(МассивФайлов.Количество()),
				Строка(НомерФайла));
			Возврат Результат;
		КонецЕсли;
		
		ДанныеФайла = МассивФайлов[НомерФайла];
		НомерФайла = НомерФайла + 1;
		
		ДанныеФайла.Вставить("Ver", ВерсияСозданияФайла);
		ДанныеФайла.Вставить("Comment", БуферКомментария);
		ДанныеФайла.Вставить("IntAttr", ВнутренниеАтрибуты);
		ДанныеФайла.Вставить("ExtAttr", ВнешниеАтрибуты);
		
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Offset", СмещениеДоНачала, МассивПроверки);
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "MinVer", МинимальнаяВерсия, МассивПроверки);
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Compress", ЕстьСжатие, МассивПроверки);
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Flags", РегистрФлагов, МассивПроверки);
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Date", ДатаМодификацииФайла, МассивПроверки);
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Time", ВремяМодификацииФайла, МассивПроверки);
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "CRC32", КонтрольнаяСумма, МассивПроверки);
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Name", БуферИмени, МассивПроверки);
		ПроверитьПолеСтруктурыАрхива(ДанныеФайла, "Extra", БуферДополнительныхДанных, МассивПроверки);
		
		Если МассивПроверки.Количество() > 0 Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка при сравнении записи файла и записи каталога файла:'"),
				Символы.ПС,
				СтрСоединить(МассивПроверки, Символы.ПС));
			Возврат Результат;
		КонецЕсли;
		
		ПозицияНачалаБлока = Поток.ТекущаяПозиция();
		
		ТекущаяСигнатура = ПрочитатьНатуральноеЧислоИзПотока(Поток, 4);
		
		Если ТипЗнч(ТекущаяСигнатура) <> Тип("Число") Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка при чтении сигнатуры следующей записи:'"),
				Символы.ПС,
				Строка(ТекущаяСигнатура));
			Возврат Результат;
		КонецЕсли;
		
		Если ТекущаяСигнатура = 33639248 Тогда
			Продолжить;
		ИначеЕсли ТекущаяСигнатура = 101010256 Тогда
			Прервать;
		Иначе
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Неизвестная структура по сигнатуре: %1'"),
				Строка(ТекущаяСигнатура));
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	
	// Номер диска: 2 байта
	// Номер диска начала директории: 2 байта
	// Количество записей текущего диска: 2 байта
	// Всего записей: 2 байта
	// Размер директории: 4 байта
	// Смещение директории: 4 байта
	// Длина комментария: 2 байта
	
	БуферЗаголовка = ПрочитатьБуферИзПотока(Поток, 18);
	
	Если ТипЗнч(БуферЗаголовка) <> Тип("БуферДвоичныхДанных") Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
			НСтр("ru = 'Не удалось прочитать запись окончания:'"),
			Символы.ПС,
			Строка(БуферЗаголовка));
		Возврат Результат;
	КонецЕсли;
	
	Попытка
		// Номер диска: 2 байта
		НомерДиска = БуферЗаголовка.ПрочитатьЦелое16(0, ПорядокБайтов.LittleEndian);
		// Номер диска начала директории: 2 байта
		НомерДискаНачала = БуферЗаголовка.ПрочитатьЦелое16(2, ПорядокБайтов.LittleEndian);
		// Количество записей текущего диска: 2 байта
		КоличествоЗаписейТекущегоДиска = БуферЗаголовка.ПрочитатьЦелое16(4, ПорядокБайтов.LittleEndian);
		// Всего записей: 2 байта
		КоличествоЗаписей = БуферЗаголовка.ПрочитатьЦелое16(6, ПорядокБайтов.LittleEndian);
		// Размер директории: 4 байта
		ОбщийРазмерДиректории = БуферЗаголовка.ПрочитатьЦелое32(8, ПорядокБайтов.LittleEndian);
		// Смещение директории: 4 байта
		СмещениеДиректории = БуферЗаголовка.ПрочитатьЦелое32(12, ПорядокБайтов.LittleEndian);
		// Длина комментария: 2 байта
		ДлинаКомментария = БуферЗаголовка.ПрочитатьЦелое16(16, ПорядокБайтов.LittleEndian);
	Исключение
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
			НСтр("ru = 'Ошибка при чтении полей из буфера окончания:'"),
			Символы.ПС,
			ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат Результат;
	КонецПопытки;
	
	Если ДлинаКомментария > 0 Тогда
		БуферКомментария = ПрочитатьБуферИзПотока(Поток, ДлинаКомментария);
		
		Если ТипЗнч(БуферКомментария) <> Тип("БуферДвоичныхДанных") Тогда
			Результат.ЕстьОшибка = Истина;
			Результат.ТекстОшибки = СтрШаблон("%1%2%3", 
				НСтр("ru = 'Ошибка при чтении комментария архива:'"),
				Символы.ПС,
				Строка(БуферКомментария));
			Возврат Результат;
		КонецЕсли;
	Иначе
		БуферКомментария = Неопределено;
	КонецЕсли;
	
	Если СмещениеДиректории <> НачалоКаталога Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Указанное начало каталога: %1 отличается от обнаруженного: %2'"),
			Строка(СмещениеДиректории),
			Строка(НачалоКаталога));
		Возврат Результат;
	КонецЕсли;
	
	Если ПозицияНачалаБлока - НачалоКаталога <> ОбщийРазмерДиректории Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Рассчитанный общий размер каталога: %1 отличается от указанного: %2'"),
			Строка(ПозицияНачалаБлока - НачалоКаталога),
			Строка(ОбщийРазмерДиректории));
		Возврат Результат;
	КонецЕсли;
	
	Если Поток.Размер() <> Поток.ТекущаяПозиция() Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'После окончания чтения данных позиция: %1 отличается от размера: %2'"),
			Строка(Поток.ТекущаяПозиция()),
			Строка(Поток.Размер()));
		Возврат Результат;
	КонецЕсли;
	
	Если КоличествоЗаписей <> НомерФайла Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Указанное количество записей: %1 отличается от найденного: %2'"),
			Строка(КоличествоЗаписей),
			Строка(НомерФайла));
		Возврат Результат;
	КонецЕсли;
	
	Если НомерФайла <> МассивФайлов.Количество() Тогда
		Результат.ЕстьОшибка = Истина;
		Результат.ТекстОшибки = СтрШаблон(НСтр("ru = 'Количество записей каталога: %1 отличается от количества файлов: %2'"),
			Строка(НомерФайла),
			Строка(МассивФайлов.Количество()));
		Возврат Результат;
	КонецЕсли;
	
	Результат.Тип = "Архив";
	Результат.Комментарий = БуферКомментария;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область XDTO

// Сохраняет объект XDTO в файл.
//
// Параметры:
//  XDTO - ЗначениеXDTO, ОбъектXDTO, Неопределено - Записываемое значение.
//  ИмяФайла - Строка - путь к файлу, в который сохраняются данные;
//  УказаниеТипа - НазначениеТипаXML - вариант назначения типа элемента данных XDTO.
//  ТипКодировки - Строка - файл будет записан в соответствующей кодировке.
//
Процедура СохранитьXDTO(XDTO, ИмяФайла, УказаниеТипа = Истина, ТипКодировки = "windows-1251") Экспорт
	
	НоваяЗаписьXML = Новый ЗаписьXML;
	НоваяЗаписьXML.ОткрытьФайл(ИмяФайла, ТипКодировки);
	НоваяЗаписьXML.ЗаписатьОбъявлениеXML();
	ФабрикаXDTO.ЗаписатьXML(НоваяЗаписьXML, XDTO, , , , ?(УказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное));
	НоваяЗаписьXML.Закрыть();
	
КонецПроцедуры

// Возвращает результат чтения XML.
// 
// Параметры:
// 	Данные - Поток - поток для чтения.
// 	       - Строка - имя файла.
// 	ТипЗначения - ТипЗначенияXDTO
// Возвращаемое значение:
// 	ОбъектXDTO
Функция ПрочитатьXDTO(Данные, ТипЗначения = Неопределено) Экспорт
	
	ОбъектXML = Новый ЧтениеXML;
	Если ТипЗнч(Данные) = Тип("Поток") Тогда
		ОбъектXML.ОткрытьПоток(Данные);
	Иначе
		ОбъектXML.ОткрытьФайл(Данные);
	КонецЕсли;
	РезультатЧтения = ФабрикаXDTO.ПрочитатьXML(ОбъектXML, ТипЗначения);
	ОбъектXML.Закрыть();
	
	Возврат РезультатЧтения;
	
КонецФункции

// Возвращает значение свойства XDTO.
// 
// Параметры:
// 	ОбъектXDTO - ОбъектXDTO
// 	ИмяСвойства - Строка
// 	ЗначениеПоУмолчанию - Произвольный - значение, которое будет возвращено, в случае отсутствия значения
// 	Тип - Строка - тип, к которому будет приведено возвращаемое значение
// 	ЭтоСписок - Булево
// 	НеопределеноПоУмолчанию - Булево - не приводить к значению по умолчанию типа, указанного в параметре Тип.
// 	                          В случае отсутствия значения, будет возвращено Неопределено.
// Возвращаемое значение:
// 	Произвольный
Функция ЗначениеСвойстваXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеПоУмолчанию = Неопределено, Тип = Неопределено,
	ЭтоСписок = Ложь, НеопределеноПоУмолчанию = Ложь) Экспорт
	
	Значение = РаботаСФайламиБЭДСлужебный.ЗначениеСвойстваXDTO(ОбъектXDTO, ИмяСвойства);
	
	Если Тип <> Неопределено Тогда
		
		Если Значение <> Неопределено Тогда
			Если Тип = "Число" Тогда
				Значение = Число(Значение);
			ИначеЕсли Тип = "Дата" Тогда
				Значение = ДатаИзСтроки(Значение);
			ИначеЕсли Тип = "Время" Тогда
				Значение = ВремяИзСтроки(Значение);
			ИначеЕсли Тип = "XMLДата" Тогда
				Значение = XMLЗначение(Тип("Дата"),Значение);
			ИначеЕсли Тип = "Булево" Тогда
				Значение = Булево(Значение);
			КонецЕсли;
			
		ИначеЕсли НеопределеноПоУмолчанию Тогда
			Значение = Неопределено;
		ИначеЕсли Тип = "Число" Тогда
			Значение = 0;
		ИначеЕсли Тип = "Дата" Тогда
			Значение = '00010101';
		ИначеЕсли Тип = "XMLДата" Тогда
			Значение = '00010101';
		ИначеЕсли Тип = "Булево" Тогда
			Значение = Ложь;
		ИначеЕсли Тип = "Строка" Тогда
			Значение = "";
		КонецЕсли;
		
	ИначеЕсли ЭтоСписок И ТипЗнч(Значение) <> Тип("СписокXDTO") И Значение <> Неопределено Тогда
		
		// При чтении xml файла фабрикой XDTO без указания типа, если в СпискеXDTO только 1 строка,
		// то список конвертируется в ОбъектXDTO. Вернем его в массиве, чтобы
		// всегда обходить в цикле, вне зависимости от количества строк.
		
		Коллекция = Новый Массив;
		Коллекция.Добавить(Значение);
		
		Значение = Коллекция;
		
	КонецЕсли;
	
	Если Значение = Неопределено И ЗначениеПоУмолчанию <> Неопределено Тогда
		Значение = ЗначениеПоУмолчанию;
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Заполняет свойство объекта XDTO.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект заполнения
//  ИмяСвойства - Строка - свойство объекта
//  Значение - Произвольный - устанавливаемое значение
//  Обязательное - Булево - свойство обязательно для заполнения
//  Ошибки - Массив из Строка - коллекция ошибок
//  УстанавливатьПустыеЗначения - Булево - если Истина, то пустое значение будет записано в ОбъектXDTO
Процедура ЗаполнитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, Значение, Обязательное = Ложь, Ошибки = Неопределено,
	УстанавливатьПустыеЗначения = Ложь) Экспорт
	
	Если ТипЗнч(Значение) = Тип("ЗначениеXDTO") ИЛИ ТипЗнч(Значение) = Тип("ОбъектXDTO") Тогда
		УстановитьЗначениеXDTO(ОбъектXDTO, ИмяСвойства, Значение, Ошибки);
	Иначе
		Если Обязательное ИЛИ ЗначениеЗаполнено(Значение) ИЛИ УстанавливатьПустыеЗначения Тогда
			УстановитьЗначениеXDTO(ОбъектXDTO, ИмяСвойства, Значение, Ошибки);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Сбрасывает свойство объекта XDTO.
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект заполнения
//  ИмяСвойства - Строка - свойство объекта
//  Ошибки - Массив из Строка - коллекция ошибок
Процедура СброситьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, Ошибки) Экспорт
	
	Попытка
		ОбъектXDTO.Сбросить(ИмяСвойства);
	Исключение
		ШаблонСообщения = НСтр("ru = 'Выполнение операции: Очистка XDTO.
			|Ошибка сброса значения свойства ""%1"".'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИмяСвойства);
		
		ОбщегоНазначенияБЭД.ДобавитьОшибку(Ошибки, ТекстСообщения);
		ОбщегоНазначенияБЭД.ЗаписатьВЖурналРегистрации(ТекстСообщения + Символы.ПС
			+ ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
		
	КонецПопытки
	
КонецПроцедуры


// Заполняет свойства XDTO на основании дерева данных.
// 
// Параметры:
// 	ОбъектXDTO - ОбъектXDTO
// 	ЗначенияСвойств - Соответствие из КлючИЗначение:
// 	  * Ключ - Строка - имя свойства XDTO
// 	  * Значение - Строка - путь к значению в дереве
// 	ДеревоДанных - ДеревоЗначений
// 	Ошибки - Массив из Строка - коллекция ошибок
// 	ПараметрыЗаполнения - см. НовыеПараметрыЗаполненияXDTO
Процедура ЗаполнитьСвойстваXDTOИзДерева(ОбъектXDTO, ЗначенияСвойств, ДеревоДанных, Ошибки,
	ПараметрыЗаполнения = Неопределено) Экспорт
	
	Если ПараметрыЗаполнения = Неопределено Тогда
		ПараметрыЗаполнения = НовыеПараметрыЗаполненияXDTO();
	ИначеЕсли ЗначениеЗаполнено(ПараметрыЗаполнения.ОбязательныеСвойства)
		И ЗначениеЗаполнено(ПараметрыЗаполнения.НеобязательныеСвойства) Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка заполнения свойств параметра ПараметрыЗаполнения метода
		|ЗаполнитьСвойстваXDTOИзДерева: должно быть заполнено только одно из свойств:
		| ОбязательныеСвойства, НеобязательныеСвойства'");
	КонецЕсли;
	
	СпискиСвойств = Новый Структура;
	ИменаСвойствСоЗначениямиДата = СтрЗаменить(ПараметрыЗаполнения.СвойстваСоЗначениямиДата, " ", "");
	ИменаСвойствСоЗначениямиДата = СтрРазделить(ИменаСвойствСоЗначениямиДата, ",");
	ПропускаемыеНезаполненныеСвойства = СтрЗаменить(ПараметрыЗаполнения.ПропускаемыеНезаполненныеСвойства, " ", "");
	ПропускаемыеНезаполненныеСвойства = СтрРазделить(ПропускаемыеНезаполненныеСвойства, ",");
	
	ОбязательныеСвойства = Новый Массив;
	НеобязательныеСвойства = Новый Массив;
	Если ЗначениеЗаполнено(ПараметрыЗаполнения.ОбязательныеСвойства) Тогда
		ОбязательныеСвойства = СтрЗаменить(ПараметрыЗаполнения.ОбязательныеСвойства, " ", "");
		ОбязательныеСвойства = СтрРазделить(ПараметрыЗаполнения.ОбязательныеСвойства, ",");
	ИначеЕсли ЗначениеЗаполнено(ПараметрыЗаполнения.НеобязательныеСвойства) Тогда
		НеобязательныеСвойства = СтрЗаменить(ПараметрыЗаполнения.НеобязательныеСвойства, " ", "");
		НеобязательныеСвойства = СтрРазделить(ПараметрыЗаполнения.НеобязательныеСвойства, ",");
	КонецЕсли;
	
	СпискиСвойств.Вставить("ИменаСвойствСоЗначениямиДата", ИменаСвойствСоЗначениямиДата);
	СпискиСвойств.Вставить("ПропускаемыеНезаполненныеСвойства", ПропускаемыеНезаполненныеСвойства);
	СпискиСвойств.Вставить("ОбязательныеСвойства", ОбязательныеСвойства);
	СпискиСвойств.Вставить("НеобязательныеСвойства", НеобязательныеСвойства);
	
	Для Каждого КлючИЗначение Из ЗначенияСвойств Цикл
		ЗаполнитьСвойствоXDTOИзДерева(ОбъектXDTO, КлючИЗначение.Ключ, ДеревоДанных, КлючИЗначение.Значение, Ошибки,
			СпискиСвойств);
	КонецЦикла;
	
КонецПроцедуры

// Возвращает параметры заполнения XDTO. См. ЗаполнитьСвойстваXDTOИзДерева.
// 
// Возвращаемое значение:
// 	Структура:
// * ОбязательныеСвойства - Строка - имена свойств через запятую, которые являются обязательными для заполнения.
//                          Строка должна быть пустой, если заполнены НеобязательныеСвойства.
// * НеобязательныеСвойства - Строка - имена свойств через запятую, которые не являются обязательными для заполнения.
//                            Строка должна быть пустой, если заполнены ОбязательныеСвойства.
// * СвойстваСоЗначениямиДата - Строка - имена свойств, к значениям которых будет применено форматирование
// * ПропускаемыеНезаполненныеСвойства - Строка - имена свойств, которые будут заполнены, только если заполнены их значения
Функция НовыеПараметрыЗаполненияXDTO() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("ОбязательныеСвойства", "");
	Параметры.Вставить("НеобязательныеСвойства", "");
	Параметры.Вставить("СвойстваСоЗначениямиДата", "");
	Параметры.Вставить("ПропускаемыеНезаполненныеСвойства", "");
	
	Возврат Параметры;
	
КонецФункции

// Преобразует ОбъектXDTO в двоичные данные в формате XML.
//
// Параметры:
//  ОбъектXDTO - ЗначениеXDTO, ОбъектXDTO, Неопределено - Записываемое значение.
//  УказаниеТипа - Булево - вариант назначения типа элемента данных XDTO, если истина, то явное.
//  ТипКодировки - Строка - файл будет записан в соответствующей кодировке.
//  ЛокальноеИмя - Строка - локальное имя записываемого элемента данных.
// Возвращаемое значение:
// 	ДвоичныеДанные
Функция XDTOВДвоичныеДанные(ОбъектXDTO, УказаниеТипа = Истина, ТипКодировки = "windows-1251", ЛокальноеИмя = "") Экспорт
	
	Поток = Новый ПотокВПамяти();
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьПоток(Поток, ТипКодировки);
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	НазначениеТипа = ?(УказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное);
	Если ПустаяСтрока(ЛокальноеИмя) Тогда
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбъектXDTO,,,, НазначениеТипа);
	Иначе
		ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбъектXDTO, ЛокальноеИмя,,, НазначениеТипа);
	КонецЕсли;
	ЗаписьXML.Закрыть();
	
	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
КонецФункции

// Получение объекта типа CML.
//
// Параметры:
//  Тип - Строка, ТипЗначенияXDTO, ТипОбъектаXDTO  - тип данных.
//  ВерсияСхемы - Строка - версия схемы.
// 
// Возвращаемое значение:
//  - ОбъектXDTO
//  - ЗначениеXDTO
//
Функция ПолучитьОбъектТипаCML(Тип, ВерсияСхемы = "4.01") Экспорт
	
	Если ТипЗнч(Тип) = Тип("Строка") Тогда
		ТипОбъекта = ПолучитьТипОбъектаCML(Тип, ВерсияСхемы);
	Иначе
		ТипОбъекта = Тип;
	КонецЕсли;
	
	Если ТипОбъекта = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НовыйОбъект = ФабрикаXDTO.Создать(ТипОбъекта);
	
	Возврат НовыйОбъект;
	
КонецФункции

// Функция получает тип значения CML.
//
// Параметры:
//  Тип - Тип - исходный тип.
//  ВерсияСхемы - Строка - версия схемы CML.
//
// Возвращаемое значение:
//  ТипЗначения - тип значения CML.
//
Функция ПолучитьТипЗначенияCML(Тип, ВерсияСхемы = "4.02") Экспорт
	
	Попытка
		Если ВерсияСхемы <> "4.02" Тогда
			ТипЗначения = ФабрикаXDTO.Тип(ВерсияСхемы, Тип);
		Иначе
			ТипЗначения = ФабрикаXDTO.Тип("http://v8.1c.ru/edi/edi_stnd", Тип);
		КонецЕсли
	Исключение
		
		ТипЗначения = Неопределено;
	КонецПопытки;
	
	Возврат ТипЗначения;
	
КонецФункции

// Разделяет тип XDTO на составляющие.
//
// Параметры:
//  Строка		 - Строка - строка для разделения.
//  Разделитель	 - Строка - разделитель.
// 
// Возвращаемое значение:
//  Массив - результат разделения.
//
Функция ЭлементыПутиТипаXDTO(Знач Строка, Разделитель) Экспорт
	
	Результат = Новый Массив;
	Если ПустаяСтрока(Строка) Тогда
		Возврат Результат;
	КонецЕсли;
	
	НачПозицияПервогоЭлемента = СтрНайти(Строка, "{");
	КонПозицияПервогоЭлемента = СтрНайти(Строка, "}");
	Если НачПозицияПервогоЭлемента > 0 И КонПозицияПервогоЭлемента > 0 Тогда
		ПервыйЭлемент = Сред(Строка, НачПозицияПервогоЭлемента, КонПозицияПервогоЭлемента);
		Результат.Добавить(СокрЛП(ПервыйЭлемент));
		Строка = СокрЛП(Сред(Строка,КонПозицияПервогоЭлемента + 2));
	КонецЕсли;
	
	Пока Истина Цикл
		Позиция = СтрНайти(Строка, Разделитель);
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Результат.Добавить(СокрЛП(Лев(Строка,Позиция - 1)));
		Строка = СокрЛП(Сред(Строка,Позиция + 1));
	КонецЦикла;
	
	Результат.Добавить(СокрЛП(Строка));
	
	Возврат Результат;
	
КонецФункции 

#КонецОбласти

#Область Прочее

// Заменяет символы, отсутствующие в кодировке текста.
// 
// Параметры:
// 	ИсходнаяСтрока - Строка - в которой требуется замена
// 	Кодировка - Строка
// 	НаЧтоМенять - Строка
// Возвращаемое значение:
// 	Строка
Функция ЗаменитьСимволыОтсутствующиеВКодировкеТекста(ИсходнаяСтрока, Кодировка = "windows-1251", НаЧтоМенять = "") Экспорт
	
	Поток = Новый ПотокВПамяти;
	
	ЗаписьТекста = Новый ЗаписьТекста(Поток, Кодировка);
	ЗаписьТекста.ЗаписатьСтроку(ИсходнаяСтрока);
	ЗаписьТекста.Закрыть();
	
	Поток.Перейти(0, ПозицияВПотоке.Начало);
	
	ЧтениеТекста = Новый ЧтениеТекста(Поток, Кодировка);
	СтрокаТекста = ЧтениеТекста.ПрочитатьСтроку();
	
	ЧтениеТекста.Закрыть();
	Поток.Закрыть();
	
	Если ЗначениеЗаполнено(СтрокаТекста) Тогда
		Возврат СтрЗаменить(СтрокаТекста, "?", НаЧтоМенять);
	Иначе
		Возврат ИсходнаяСтрока;
	КонецЕсли;
	
КонецФункции

// Выполняет преобразование имени файла в латиницу, если это требуется 
//
// Параметры:
//  ИмяФайла - Строка
//  ОтключитьТранслитерацию - Булево - Истина, если не переводить в латиницу.
//  
//  Возвращаемое значение:
//   Строка - Имя файла после преобразования.
//
Функция ПреобразоватьИмяФайлаСУчетомТранслитерации(ИмяФайла, ОтключитьТранслитерацию) Экспорт
	
	Результат = ОбщегоНазначенияКлиентСервер.ЗаменитьНедопустимыеСимволыВИмениФайла(ИмяФайла, "_");

	Если Не ОтключитьТранслитерацию Тогда
		Результат = СтроковыеФункции.СтрокаЛатиницей(Результат);
		Результат = СтрЗаменить(Результат, " ", "_");
	КонецЕсли;

	Возврат Результат;
	
КонецФункции

// Строка из буфера двоичных данных в указанной кодировке.
// 
// Параметры:
//  Буфер - БуферДвоичныхДанных
//  Кодировка - Строка, КодировкаТекста -
// 
// Возвращаемое значение:
//  Строка - Полученная строка
//
Функция БуферВСтрокуВКодировке(Буфер, Кодировка) Экспорт
	
	Если Буфер = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Если ТипЗнч(Буфер) <> Тип("БуферДвоичныхДанных") Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru='Это не буфер:%1'"), Строка(ТипЗнч(Буфер)));
	КонецЕсли;
	
	Если Кодировка = Неопределено Тогда
		Кодировка = КодировкаТекста.UTF8;
	КонецЕсли;
	
	ПотокДляЧтения = Новый ПотокВПамяти;
	ПотокДляЧтения.Записать(Буфер, 0, Буфер.Размер);
	ПотокДляЧтения.Перейти(0, ПозицияВПотоке.Начало);
	
	ЧтениеИзПотока = Новый ЧтениеТекста(ПотокДляЧтения, Кодировка);
	
	ПрочитанныйТекст = ЧтениеИзПотока.Прочитать();
	
	ЧтениеИзПотока.Закрыть();
	ПотокДляЧтения.Закрыть();
	
	Возврат ?(ПрочитанныйТекст = Неопределено, "", ПрочитанныйТекст);
	
КонецФункции

#КонецОбласти

#Область ВизуализацияЭП

// Возвращает преобразованный в pdf файл, с нанесенным на него штампом об отметках ЭП.
// 
// Параметры:
//  СсылкаНаДвоичныеДанныеФайла - Строка - Адрес во временном хранилище, содержащий двоичные данные файла
//  ШтампЭП - Картинка - Картинка штампа электронной подписи
//  Расширение - Строка - Расширение файла, поддерживаемые форматы:
//   "pdf"
//   "odt"
//   "doc"
//   "docx"
//   "xls"
//   "xlsx"
// 
// Возвращаемое значение:
//  Неопределено, Строка - Адрес во временном хранилище, содержащий двоичные данные созданного файла
//
Функция ВизуализацияДокументаСШтампомЭП(СсылкаНаДвоичныеДанныеФайла, ШтампЭП, Расширение) Экспорт
	
	Результат = Неопределено;
	ДвоичныеДанныеФайлаPdf = Неопределено;
	НормализованноеРасширение = НРег(Расширение);
	
	Если НЕ ОбщегоНазначения.ЭтоWindowsСервер()
		И НормализованноеРасширение <> "pdf" Тогда
		Возврат Результат; // работа с офис поддерживается только в OS Windows
	КонецЕсли;
		
	ДвоичныеДанныИсходногоФайла = ПолучитьИзВременногоХранилища(СсылкаНаДвоичныеДанныеФайла);
		
	Если НормализованноеРасширение = "pdf" Тогда
		ДвоичныеДанныеФайлаPdf = ДвоичныеДанныИсходногоФайла;
	КонецЕсли;
		
	Если НормализованноеРасширение = "odt" Тогда
		ДвоичныеДанныеФайлаPdf = ПреобразоватьOpenOfficeВPdf(ДвоичныеДанныИсходногоФайла, НормализованноеРасширение);
	КонецЕсли;
	
	Если НормализованноеРасширение = "doc"
		ИЛИ НормализованноеРасширение = "docx" Тогда
		ДвоичныеДанныеФайлаPdf = ПреобразоватьWordВPdf(ДвоичныеДанныИсходногоФайла, НормализованноеРасширение);
	КонецЕсли;
	
	Если НормализованноеРасширение = "xls" 
		ИЛИ НормализованноеРасширение = "xlsx" Тогда
		ДвоичныеДанныеФайлаPdf = ПреобразоватьExcelВPdf(ДвоичныеДанныИсходногоФайла, НормализованноеРасширение);
	КонецЕсли;

	Если ДвоичныеДанныеФайлаPdf <> Неопределено Тогда
		Результат = ДобавитьШтампЭПВФайлPDF(ДвоичныеДанныеФайлаPdf, ШтампЭП, Новый УникальныйИдентификатор);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает информацию о возможности добавить в файл штамп ЭП по переданному расширению.
// 
// Параметры:
//  Расширение - Строка - Расширение файла
// 
// Возвращаемое значение:
//  Булево - В файл возможно добавить штамп ЭП
//
Функция ВозможноДобавитьШтампЭП(Расширение) Экспорт
	ПоддерживаемыеРасширения = "PDF DOC DOCX ODT XLS XLSX";
	МассивРасширений = СтрРазделить(ПоддерживаемыеРасширения, " ");
	Возврат МассивРасширений.Найти(ВРег(Расширение)) <> Неопределено;
КонецФункции

// Возвращает информацию о возможности распечатать файл по переданному расширению.
// 
// Параметры:
//  Расширение - Строка - Расширение файла
// 
// Возвращаемое значение:
//  Булево - Файл возможно распечатать
//
Функция ФайлПодлежитПечати(Расширение) Экспорт
	
	РасширенияИзображений = "JPG JPEG JP2 JPG2 PNG BMP TIFF TIF GIF WMF EMF PDF";
	РасширенияОфисныхДокументов = "DOC DOCX DOCM DOT DOTX DOTM RTF XLS XLSX XLSM XLT XLTM XLSB PPT PPTX PPTM PPS " 
		+ "PPSX PPSM POT POTX POTM ODT OTT ODP OTP ODS OTS ODC OTC ODF OTF ODM OTH SDW STW SXW STC SXC SDC SDD STI";

	МассивРасширений = СтрРазделить(РасширенияИзображений, " ");
	МассивРасширенийОфисныхДокументов = СтрРазделить(РасширенияОфисныхДокументов, " ");
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(МассивРасширений, МассивРасширенийОфисныхДокументов, Истина);
	
	Возврат МассивРасширений.Найти(ВРег(Расширение)) <> Неопределено;

КонецФункции

// Возвращает информацию, является ли формат файла PDF стандартом PDF/A-3, доступен начиная с версии платформы 8.3.21.
// 
// Параметры:
//  СсылкаНаДвоичныеДанныеФайла - Строка - ссылка на двоичные данные файла во временном хранилище
// 
// Возвращаемое значение:
//  Структура:
// * Результат - Булево - это pdf/a-3
// * ТекстОшибки - Строка - текст ошибки проверки
//
Функция ЭтоФайлФорматаPDFА3(СсылкаНаДвоичныеДанныеФайла) Экспорт

	Результат = Новый Структура("Результат, ТекстОшибки", Ложь, "");
	
#Если Не ВнешнееСоединение Тогда	
	
	СистемнаяИнформация = Новый СистемнаяИнформация();
	ВерсияПлатформы = СистемнаяИнформация.ВерсияПриложения;
	ВерсияПлатформыБезНомераСборки = ОбщегоНазначенияКлиентСервер.ВерсияКонфигурацииБезНомераСборки(ВерсияПлатформы);
	Если ОбщегоНазначенияКлиентСервер.СравнитьВерсииБезНомераСборки(ВерсияПлатформыБезНомераСборки, "8.3.21") < 0 Тогда
		ШаблонОшибки = НСтр("ru='Версия платформы %1 не поддерживает работу с документом PDF'");
		Результат.Результат = Ложь;
		Результат.ТекстОшибки = СтрШаблон(ШаблонОшибки, ВерсияПлатформы);
		Возврат Результат;
	КонецЕсли;
	
	ДвоичныеДанныИсходногоФайла = ПолучитьИзВременногоХранилища(СсылкаНаДвоичныеДанныеФайла);

	ПотокДанныхФайла = Новый ПотокВПамяти;
	ДвоичныеДанныИсходногоФайла.Записать(ПотокДанныхФайла);
	КодДляВыполнения = 
		"ПроверяемыйДокумент = Новый ДокументPDF;
		|ПроверяемыйДокумент.Прочитать(ПотокДанныхФайла);
		|ТипФайлаPDF = ПроверяемыйДокумент.ТипФайла;
		|Результат.Результат = ТипФайлаPDF = ТипФайлаДокументаPDF.PDF_A_3;";
	
	Попытка 
		Выполнить(КодДляВыполнения); // АПК:487 Исполняемый код безопасен.
	Исключение 
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПодробныйТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		Результат.ТекстОшибки = ПодробныйТекстОшибки;
		Результат.Результат = Ложь;
	КонецПопытки;
	
	ПотокДанныхФайла.Закрыть();
	ПотокДанныхФайла = Неопределено;
	
#КонецЕсли

	Возврат Результат;

КонецФункции

// Добавляет штамп ЭП в данные файла pdf, возвращает двоичные данные или адрес во временном хранилище с обработанным файлом.
// 
// Параметры:
//  ДвоичныеДанныеФайлаPdf - ДвоичныеДанные - двоичные данные файла pdf
//  ШтампЭП - Картинка - картинка штампа ЭП
//  УникальныйИдентификатор - УникальныйИдентификатор
//  ВернутьАдресВХранилище - Булево - Истина, если нужно вернуть адрес в хранилище, иначе возвращает двоичные данные
// 
// Возвращаемое значение:
//  Неопределено,Строка,ДвоичныеДанные - адрес во временном хранилище или двоичные данные
// 
Функция ДобавитьШтампЭПВФайлPDF(ДвоичныеДанныеФайлаPdf, ШтампЭП, УникальныйИдентификатор, ВернутьАдресВХранилище = Истина) Экспорт

	Результат = Неопределено;
	
#Если Не ВнешнееСоединение Тогда

	ПотокДанныхФайла = Новый ПотокВПамяти;
	ДвоичныеДанныеФайлаPdf.Записать(ПотокДанныхФайла);

	СмещениеОтКрая = 10;
	
	КодДляВыполнения = 
		"ЗаписьPDF = Новый ЗаписьPDF(ПотокДанныхФайла);
		|Описание = Новый ОписаниеОтображаемогоОбъектаPDF;
		|Описание.Объект = ШтампЭП;
		|Описание.Лево = СмещениеОтКрая;
		|ЗаписьPDF.ЗаписатьОтображаемыйОбъект(Описание);
		|ЗаписьPDF.Закрыть();";
	
	Попытка 
		Выполнить(КодДляВыполнения); // АПК:487 Исполняемый код безопасен.
		ДвоичныеДанные = ПотокДанныхФайла.ЗакрытьИПолучитьДвоичныеДанные();
		Если ВернутьАдресВХранилище Тогда
			Результат = ПоместитьВоВременноеХранилище(ДвоичныеДанные, УникальныйИдентификатор);
		Иначе
			Результат = ДвоичныеДанные;
		КонецЕсли;
	Исключение 
		ПотокДанныхФайла.Закрыть();
		ПотокДанныхФайла = Неопределено;
		ИнформацияОбОшибке = ИнформацияОбОшибке();
		ПодробныйТекстОшибки = ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
		ЗаписьЖурналаРегистрации(
			НСтр("ru = 'Вставка штампа ЭП'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Ошибка,,, ПодробныйТекстОшибки);
	КонецПопытки;
		
#КонецЕсли

	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ФорматироватьДату(ДатаВремя)
	
	Если ТипЗнч(ДатаВремя) = Тип("Дата") Тогда
		Значение = Формат(ДатаВремя, "ДФ=dd.MM.yyyy");
	Иначе
		Значение = Лев(ДатаВремя, 10);
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

Процедура ЗаполнитьСвойствоXDTOИзДерева(ОбъектXDTO, Свойство, ДеревоДанных, ПутьВДереве, Ошибки, СпискиСвойств)
	
	ЗначениеСвойства = ДеревоЭлектронногоДокументаБЭД.ЗначениеРеквизитаВДереве(ДеревоДанных, ПутьВДереве);

	Если ЗначениеЗаполнено(СпискиСвойств.ОбязательныеСвойства) Тогда
		СвойствоОбязательно = СпискиСвойств.ОбязательныеСвойства.Найти(Свойство) <> Неопределено;
	ИначеЕсли ЗначениеЗаполнено(СпискиСвойств.НеобязательныеСвойства) Тогда
		СвойствоОбязательно = СпискиСвойств.НеобязательныеСвойства.Найти(Свойство) = Неопределено;
	Иначе
		СвойствоОбязательно = Истина;
	КонецЕсли;
	
	Если СпискиСвойств.ИменаСвойствСоЗначениямиДата.Найти(Свойство) <> Неопределено Тогда
		ЗначениеСвойства = ФорматироватьДату(ЗначениеСвойства);
	КонецЕсли;
	Если СпискиСвойств.ПропускаемыеНезаполненныеСвойства.Найти(Свойство) = Неопределено Тогда
		ЗаполнитьСвойствоXDTO(ОбъектXDTO, Свойство, ЗначениеСвойства, СвойствоОбязательно, Ошибки);
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьЗначениеXDTO(ОбъектXDTO, ИмяСвойства, Значение, Ошибки)
	
	Попытка
		ОбъектXDTO.Установить(ИмяСвойства, Значение);
	Исключение
		ШаблонСообщения = НСтр("ru = 'Выполнение операции: Заполнение XDTO.
			|Ошибка установки значения свойства ""%1"".'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИмяСвойства);
		ОбщегоНазначенияБЭД.ДобавитьОшибку(Ошибки, ТекстСообщения);
		
		ОбщегоНазначенияБЭД.ЗаписатьВЖурналРегистрации(ТекстСообщения + Символы.ПС
			+ ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()), ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
	КонецПопытки
	
КонецПроцедуры

// Преобразует строковое представление времени в форматах HH.mm.ss в дату.
//
// Параметры:
//  ВремяСтрокой - Строка - представление времени.
//  Разделитель - Строка - разделитель часов, минут, секунд.
// Возвращаемое значение:
//  Дата - преобразованное значение.
//
Функция ВремяИзСтроки(Знач ВремяСтрокой, Знач Разделитель = ".")
	
	ЧастьДаты = "00010101";
	ЧастьВремени = СтрЗаменить(СокрЛП(ВремяСтрокой), Разделитель, "");
	
	Возврат Дата(ЧастьДаты + ЧастьВремени);
	
КонецФункции

// Преобразует строковое представление даты в форматах DD.MM.YYYY, YYYY-MM-DD в дату.
//
// Параметры:
//  Строка	 - Строка - представление даты.
// Возвращаемое значение:
//  Дата - преобразованное значение.
//
Функция ДатаИзСтроки(Строка) Экспорт
	
	Если ТипЗнч(Строка) = Тип("Дата") Тогда
		Возврат Строка;
	КонецЕсли;
	
	ЧастьДаты    = "";
	ЧастьВремени = "000000";
	Если Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(Сред(Строка, 3, 1)) Тогда
		ЧастьДаты = Сред(Строка, 7, 4) + Сред(Строка, 4, 2) + Сред(Строка, 1, 2);
		// заполним дополнительно время для формата "dd.MM.yyyy HH.mm.ss".
		Если СтрДлина(Строка) = 19 Тогда
			ЧастьВремени = СтроковыеФункцииКлиентСервер.ЗаменитьОдниСимволыДругими(".:", Сред(Строка, 12), "");
		КонецЕсли;
	Иначе
		ЧастьДаты = Сред(Строка, 1, 4) + Сред(Строка, 6, 2) + Сред(Строка, 9, 2);
		// заполним дополнительно время для формата 20 символов.
		Если СтрДлина(Строка) = 20 Тогда
			ЧастьВремени = СтроковыеФункцииКлиентСервер.ЗаменитьОдниСимволыДругими(".:", Сред(Строка, 12), "");
		КонецЕсли;
	КонецЕсли;
	
	Возврат Дата(ЧастьДаты + ЧастьВремени);
	
КонецФункции

Функция МаксимальнаяДлинаИмениФайла()
	
	Возврат 255;
	
КонецФункции

Функция ДлинаФайлаДопустима(ПолноеИмяФайла, КонтекстДиагностики, ВидОперации = "")
	
	Если СтрДлина(ПолноеИмяФайла) > МаксимальнаяДлинаИмениФайла() Тогда
		Если Не ЗначениеЗаполнено(ВидОперации) Тогда
			ВидОперации = НСтр("ru = 'Запись файла'");
		КонецЕсли;
		ТекстОшибки = ОбработкаНеисправностейБЭД.ПолучитьСообщениеОбОшибкеДругойСистемы("007");
		Ошибка = ОбработкаНеисправностейБЭД.НоваяОшибка(ВидОперации,
			РаботаСФайламиБЭДКлиентСервер.ВидОшибкиРаботаСФайлами(),
			ТекстОшибки, ТекстОшибки);
		ОбработкаНеисправностейБЭД.ДобавитьОшибку(КонтекстДиагностики, Ошибка,
			ОбщегоНазначенияБЭДКлиентСервер.ПодсистемыБЭД().РаботаСФайлами);
		Возврат Ложь;
	Иначе 
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьТипОбъектаCML(Тип, ВерсияСхемы)
	
	МассивПути = ЭлементыПутиТипаXDTO(Тип, ".");
	
	ПервыйЭлемент = МассивПути[0];
	Если Лев(ПервыйЭлемент,1) = "{" И Прав(ПервыйЭлемент,1) = "}" Тогда
		ИмяПакета = Сред(ПервыйЭлемент, 2, СтрДлина(ПервыйЭлемент) - 2);
		Коллекция = ФабрикаXDTO.Пакеты.Получить(ИмяПакета).КорневыеСвойства;
	ИначеЕсли ВерсияСхемы <> "4.02" Тогда
		ТипОбъекта = ФабрикаXDTO.Тип(ВерсияСхемы, ПервыйЭлемент);
		Коллекция = ТипОбъекта.Свойства;
	Иначе
		ТипОбъекта = ФабрикаXDTO.Тип("http://v8.1c.ru/edi/edi_stnd", ПервыйЭлемент);
		Коллекция = ТипОбъекта.Свойства;
	КонецЕсли;
	
	МассивПути.Удалить(0);
	Пока МассивПути.Количество() > 0 Цикл
		
		Если Коллекция = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Свойство = Коллекция.Получить(МассивПути[0]);
		Если Свойство = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		ТипОбъекта = Свойство.Тип;
		МассивПути.Удалить(0);
		Попытка
			Коллекция = ТипОбъекта.Свойства;
		Исключение
			Коллекция = Неопределено;
		КонецПопытки;
		
	КонецЦикла;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Проверяет в zip-архиве имена файлов (без расширения) на наличие в них недопустимых символов.
// Такие имена при распаковке обрезаются и может получиться два файла с одинаковыми именами, в результате
// один перезапишет другого.
//
// Параметры:
//  АрхивФайлов - ЧтениеZipФайла - Инициализированный объект чтения zip архива.
// 
// Возвращаемое значение - Булево - Истина, если в архиве есть файлы с недопустимыми символами в именах,
//                                  которые после обрезки становятся одинаковыми.
//
Функция ЕстьОдинаковыеИменаФайловСНедопустимымиСимволамиВАрхиве(АрхивФайлов)
	
	ФлагОшибки = Ложь;
	
	ИменаОсновныхФайлов = Новый ТаблицаЗначений;
	ИменаОсновныхФайлов.Колонки.Добавить("ИмяФайла");
	ИменаОсновныхФайлов.Колонки.Добавить("СчетчикИмен");
	ИменаОсновныхФайлов.Колонки.Добавить("ФлагНедопустимыхСимволов");
	
	Для Каждого ФайлАрхива Из АрхивФайлов.Элементы Цикл
		
		НекорректныеСимволы = ОбщегоНазначенияКлиентСервер.НайтиНедопустимыеСимволыВИмениФайла(
			ФайлАрхива.ИсходноеИмяБезРасширения);
		
		СтрокаТаблицы                          = ИменаОсновныхФайлов.Добавить();
		СтрокаТаблицы.ИмяФайла                 = ФайлАрхива.Имя;
		СтрокаТаблицы.СчетчикИмен              = 1;
		СтрокаТаблицы.ФлагНедопустимыхСимволов = НекорректныеСимволы.Количество();
		
	КонецЦикла;
	
	Если ИменаОсновныхФайлов.Количество() Тогда
		
		ИменаОсновныхФайлов.Свернуть("ИмяФайла", "СчетчикИмен, ФлагНедопустимыхСимволов");
		
		Для Каждого Строка Из ИменаОсновныхФайлов Цикл
			Если Строка.СчетчикИмен > 1 И Строка.ФлагНедопустимыхСимволов Тогда
				ФлагОшибки = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ФлагОшибки;
	
КонецФункции

#Область РаботаСАрхивомНаНизкомУровне

// Конструктор результата чтения архива.
// 
// Возвращаемое значение:
//  Структура - Результат чтения архива:
// * ЕстьОшибка - Булево - Признак наличия ошибки при чтении архива
// * ТекстОшибки - Строка - Текст ошибки при чтении архива
// * Тип - Неопределено, Строка - "Архив", если не было ошибок
// * Комментарий - Неопределено, БуферДвоичныхДанных - Буфер комментария архива, если присутствует
// * Файлы - Массив Из см. НовыеДанныеФайлаПриЧтенииАрхива - Массив данных файлов архива
//
Функция НовыйРезультатЧтенияАрхива()
	
	Результат = Новый Структура;
	Результат.Вставить("ЕстьОшибка", Ложь);
	Результат.Вставить("ТекстОшибки", "");
	Результат.Вставить("Тип", Неопределено);
	Результат.Вставить("Комментарий", Неопределено);
	Результат.Вставить("Файлы", Новый Массив);
	Возврат Результат;
	
КонецФункции

// Конструктор данных файла при чтении архива на низком уровне.
// 
// Возвращаемое значение:
//  Структура - Новые данные файла при чтении архива:
// * Offset - Неопределено, Число - 
// * Compress - Неопределено, Булево - 
// * MinVer - Неопределено, Число - 
// * Flags - Неопределено, Число -
// * Date - Неопределено, Число -
// * Time - Неопределено, Число -
// * CRC32 - Неопределено, Число -
// * Name - Неопределено, БуферДвоичныхДанных -
// * Extra - Неопределено, БуферДвоичныхДанных -
// * Body - Неопределено, ПотокВПамяти -
//
Функция НовыеДанныеФайлаПриЧтенииАрхива()
	
	ДанныеФайла = Новый Структура;
	ДанныеФайла.Вставить("Offset", Неопределено);
	ДанныеФайла.Вставить("Compress", Неопределено);
	ДанныеФайла.Вставить("MinVer", Неопределено);
	ДанныеФайла.Вставить("Flags", Неопределено);
	ДанныеФайла.Вставить("Date", Неопределено);
	ДанныеФайла.Вставить("Time", Неопределено);
	ДанныеФайла.Вставить("CRC32", Неопределено);
	ДанныеФайла.Вставить("Name", Неопределено);
	ДанныеФайла.Вставить("Extra", Неопределено);
	ДанныеФайла.Вставить("Body", Неопределено);
	Возврат ДанныеФайла;
	
КонецФункции

// Выполняет чтение натурального числа из потока (предполагается, что младший байт читается первым).
// 
// Параметры:
//  Поток - Поток,ПотокВПамяти,ФайловыйПоток - поток, из которого выполняется чтение.
//  КоличествоБайт - Число - количество байт в числе, которое будет прочитано.
// 
// Возвращаемое значение:
//  - Число - результат чтение.
// 
// Исключение:
//  В случае ошибки вызывается исключение.
Функция ПрочитатьНатуральноеЧислоИзПотока(Поток, Знач КоличествоБайт)
	
	ПроверитьПотокЧтения(Поток);
	ПроверитьЦелоеЧисло(КоличествоБайт, 1, Неопределено);
	
	Буфер = Новый БуферДвоичныхДанных(КоличествоБайт, ПорядокБайтов.LittleEndian);
	
	РазмерПотока = Поток.Размер();
	ТекущаяПозиция = Поток.ТекущаяПозиция();
	
	Если ТекущаяПозиция + КоличествоБайт > РазмерПотока Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'С позиции: %1 потока размером: %2 нельзя прочитать натуральное число длиной: %3'"),
			Строка(ТекущаяПозиция), Строка(РазмерПотока), Строка(КоличествоБайт));
	КонецЕсли;
	
	ПрочитаноБайт = Поток.Прочитать(Буфер, 0, КоличествоБайт);
	
	Если ПрочитаноБайт <> КоличествоБайт Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'С позиции: %1 потока размером: %2 было прочитано: %3 байт числа длиной: %4'"),
			Строка(ТекущаяПозиция), Строка(РазмерПотока), Строка(ПрочитаноБайт), Строка(КоличествоБайт));
	КонецЕсли;
	
	ПрочитанноеЧисло = 0;
	
	Пока КоличествоБайт > 0 Цикл
		КоличествоБайт = КоличествоБайт - 1;
		ПрочитанноеЧисло = (ПрочитанноеЧисло * 256) + Буфер[КоличествоБайт];
	КонецЦикла;
	
	Возврат ПрочитанноеЧисло;
КонецФункции

// Выполняет чтение буфера из потока (буфер создается перед чтением).
// 
// Параметры:
//  Поток - Поток - Поток, из которого будет прочитан буфер.
//  РазмерБуфера - Число - Количество байт в читаемом буфере.
// 
// Возвращаемое значение:
// - БуферДвоичныхДанных - прочитанный из потока буфер.
// 
// Исключение:
//  В случае ошибки вызывается исключение.
Функция ПрочитатьБуферИзПотока(Поток, РазмерБуфера)
	
	ПроверитьПотокЧтения(Поток);
	ПроверитьЦелоеЧисло(РазмерБуфера, 1, Неопределено);
	
	РазмерПотока = Поток.Размер();
	Позиция = Поток.ТекущаяПозиция();
	
	Если Позиция + РазмерБуфера > РазмерПотока Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'В потоке размером: %1 с позиции: %2 невозможно прочитать буфет размером: %3'"),
			Строка(РазмерПотока), Строка(Позиция), Строка(РазмерБуфера));
	КонецЕсли;
	
	Буфер = Новый БуферДвоичныхДанных(РазмерБуфера, ПорядокБайтов.LittleEndian);
	ПрочитаноБайт = Поток.Прочитать(Буфер, 0, РазмерБуфера);
	
	Если ПрочитаноБайт <> РазмерБуфера Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'При чтении буфера размером: %1 с позиции: %2 прочитали только: %3'"),
			Строка(РазмерБуфера), Строка(Позиция), Строка(ПрочитаноБайт));
	КонецЕсли;
	
	Возврат Буфер;
	
КонецФункции

// Выполняет запись натурального числа в поток.
// 
// Параметры:
//  Поток - Поток - поток, в который выполняется запись.
//  ЗначениеДляЗаписи - Число - записываемое в поток значение.
//  КоличествоБайт - Число - количество байт в записываемом числе.
// 
// Исключение:
//  В случае ошибки вызывается исключение.
Процедура ЗаписатьНатуральноеЧислоВПоток(Поток, ЗначениеДляЗаписи, КоличествоБайт)
	
	ПроверитьПотокЗаписи(Поток);
	ПроверитьЦелоеЧисло(ЗначениеДляЗаписи, 0, Неопределено);
	ПроверитьЦелоеЧисло(КоличествоБайт, 1, Неопределено);
	
	Буфер = Новый БуферДвоичныхДанных(КоличествоБайт, ПорядокБайтов.LittleEndian);
	ТекущееЗначение = ЗначениеДляЗаписи;
	
	Для ИндексБайта = 0 По КоличествоБайт - 1 Цикл
		Байт = ТекущееЗначение % 256;
		ТекущееЗначение = (ТекущееЗначение - Байт) / 256;
		Буфер[ИндексБайта] = Байт;
	КонецЦикла;
	
	Если ТекущееЗначение > 0 Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Значение: %1 нельзя записать байтами в количестве: %2'"),
			Строка(ЗначениеДляЗаписи), Строка(КоличествоБайт));
	КонецЕсли;
	
	Поток.Записать(Буфер, 0, КоличествоБайт);
	
КонецПроцедуры

// Выполняет запись буфера двоичных данных в поток.
// 
// Параметры:
//  Поток - Поток - поток, в который производится запись.
//  Буфер - БуферДвоичныхДанных - буфер, который записывается в поток.
// 
// Исключение:
//  В случае ошибки вызывается исключение.
Процедура ЗаписатьБуферВПоток(Поток, Буфер)
	
	ПроверитьПотокЗаписи(Поток);
	
	Если ТипЗнч(Буфер) <> Тип("БуферДвоичныхДанных") Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для записываемого в поток буфера двоичных данных.'"),
			Строка(ТипЗнч(Буфер)));
	КонецЕсли;
	
	Поток.Записать(Буфер, 0, Буфер.Размер);
	
КонецПроцедуры

// Выполняет прямое копирование потока чтения в поток записи.
// 
// Параметры:
//  ПотокЧтения - Поток - поток, из которого выполняется чтение.
//  ПотокЗаписи - Поток - поток, в который выполняется запись.
//  КоличествоБайт - Число - количество копируемых байт.
// 
// Исключение:
//  В случае ошибки вызывается исключение.
Процедура ПрямоеКопированиеВПоток(ПотокЧтения, ПотокЗаписи, КоличествоБайт)
	
	ПроверитьПотокЧтения(ПотокЧтения);
	ПроверитьПотокЗаписи(ПотокЗаписи);
	ПроверитьЦелоеЧисло(КоличествоБайт, 0, Неопределено);
	
	Если КоличествоБайт > 0 Тогда
		ПотокЧтения.КопироватьВ(ПотокЗаписи, КоличествоБайт);
	КонецЕсли;
	
КонецПроцедуры

// Параметры:
//  Поток - Поток
//  КоличествоБайт - Число
// 
// Возвращаемое значение:
//  Строка,ПотокВПамяти
Функция СкопироватьВНовыйПоток(Поток, КоличествоБайт)
	
	Если ТипЗнч(Поток) <> Тип("Поток") Тогда
		Возврат СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для потока, из части которого читается поток в памяти.'"),
			Строка(ТипЗнч(Поток)));
	КонецЕсли;
	
	Если ТипЗнч(КоличествоБайт) <> Тип("Число") Тогда
		Возврат СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для количества читаемых из потока байт.'"),
			Строка(ТипЗнч(КоличествоБайт)));
	ИначеЕсли Цел(КоличествоБайт) <> КоличествоБайт Тогда
		Возврат НСтр("ru = 'Количество читаемых байт указано дробным числом:'") + XMLСтрока(КоличествоБайт);
	ИначеЕсли КоличествоБайт <= 0 Тогда
		Возврат НСтр("ru = 'Указано нереальное количество читаемых байт:'") + Строка(КоличествоБайт);
	КонецЕсли;
	
	РазмерПотока = Поток.Размер();
	ТекущаяПозиция = Поток.ТекущаяПозиция();
	
	Если ТекущаяПозиция + КоличествоБайт > РазмерПотока Тогда
		Возврат СтрШаблон(НСтр("ru = 'С позиции: %1 потока размером: %2 невозможно прочитать байт: %3'"),
			Строка(ТекущаяПозиция), Строка(РазмерПотока), Строка(КоличествоБайт));
	КонецЕсли;
	
	ПотокРезультат = Новый ПотокВПамяти(КоличествоБайт);
	ПрочитаноБайт = Поток.КопироватьВ(ПотокРезультат, КоличествоБайт);
	
	Если ПрочитаноБайт <> КоличествоБайт Тогда
		Возврат СтрШаблон(НСтр("ru = 'С позиции: %1 потока размером: %2 прочитано байт: %3 вместо: %4'"),
			Строка(ТекущаяПозиция), Строка(РазмерПотока), Строка(ПрочитаноБайт), Строка(КоличествоБайт));
	КонецЕсли;
	
	Возврат ПотокРезультат;
	
КонецФункции

// Раскодировать deflate поток.
// Пока не реализовано, возвращает тот же поток.
// 
// Параметры:
//  СжатыйПоток - ПотокВПамяти - Сжатый поток в памяти
// 
// Возвращаемое значение:
//  ПотокВПамяти - Раскодированный deflate поток
//
Функция РаскодироватьDeflateПоток(СжатыйПоток)
	
	Возврат СжатыйПоток;
	
КонецФункции

// Выполняет проверку поля в структуре на равенство значению.
// 
// Параметры:
//  Структура - Структура - содержащая проверяемое поле структура.
//  ИмяПоля - Строка - имя поля в структуре, значение которого мы проверяем.
//  ЗначениеПоля - Произвольный - значение, с которым сравнивается значение поля структуры.
//  МассивПроверки - Массив из Строка- массив для записи различий при сравнении.
// 
// Исключение:
//  В случае ошибки в значениях полей вызывается исключение.
Процедура ПроверитьПолеСтруктурыАрхива(Структура, ИмяПоля, ЗначениеПоля, МассивПроверки)
	
	Если ТипЗнч(МассивПроверки) <> Тип("Массив") Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для массива записи результатов проверки.'"),
			Строка(ТипЗнч(МассивПроверки)));
	КонецЕсли;
	
	Если ТипЗнч(Структура) <> Тип("Структура") Тогда
		МассивПроверки.Добавить(СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для проверяемой структуры.'"),
			Строка(ТипЗнч(Структура))));
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ИмяПоля) <> Тип("Строка") Тогда
		МассивПроверки.Добавить(СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для имени проверяемого поля.'"),
			Строка(ТипЗнч(ИмяПоля))));
		Возврат;
	КонецЕсли;
	
	РеальноеЗначение = Неопределено;
	
	Попытка
		Если НЕ Структура.Свойство(ИмяПоля, РеальноеЗначение) Тогда
			МассивПроверки.Добавить(НСтр("ru = 'В структуре нет поля:'") + ИмяПоля);
			Возврат;
		КонецЕсли;
	Исключение
		МассивПроверки.Добавить(СтрШаблон(НСтр("ru = 'Ошибка при получении значения поля: %1 из структуры:'"), ИмяПоля)
			+ Символы.ПС + ОбработкаОшибок.ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Возврат;
	КонецПопытки;
	
	ТипЗначения = ТипЗнч(РеальноеЗначение);
	
	Если ТипЗнч(ЗначениеПоля) <> ТипЗначения Тогда
		МассивПроверки.Добавить(СтрШаблон(НСтр("ru = 'В структуре поле: %1 имеет тип: %2 отличный от: %3'"),
			ИмяПоля, Строка(ТипЗначения), Строка(ТипЗнч(ЗначениеПоля))));
		Возврат;
	КонецЕсли;
	
	Если ТипЗначения = Тип("БуферДвоичныхДанных") Тогда
		РазмерБуфера = РеальноеЗначение.Размер;
		
		Если ЗначениеПоля.Размер <> РазмерБуфера Тогда
			МассивПроверки.Добавить(СтрШаблон(НСтр("ru = 'В структуре поле: %1 содержит буфер двоичных данных размером: %2 отличный от: %3'"),
				ИмяПоля, Строка(РазмерБуфера), Строка(ЗначениеПоля.Размер)));
			Возврат;
		КонецЕсли;
		
		Для Позиция = 0 По РазмерБуфера - 1 Цикл
			Если РеальноеЗначение[Позиция] <> ЗначениеПоля[Позиция] Тогда
				МассивПроверки.Добавить(СтрШаблон(НСтр("ru = 'Байт: %1 поля: %2 в позиции: %3 отличается от: %4'"),
					Строка(РеальноеЗначение[Позиция]), ИмяПоля, Строка(Позиция), Строка(ЗначениеПоля[Позиция])));
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли РеальноеЗначение <> ЗначениеПоля Тогда
		МассивПроверки.Добавить(СтрШаблон(НСтр("ru = 'В структуре поле: %1 имеет значение: %2 отличное от: %3'"),
			ИмяПоля, Строка(РеальноеЗначение), Строка(ЗначениеПоля)));
	КонецЕсли;
КонецПроцедуры

// Проверяет, что переданный поток является потоком и готов для чтения.
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный - проверяемое значение.
// 
// Исключение:
//  В случае неправильного значения вызывается исключение.
Процедура ПроверитьПотокЧтения(ПроверяемоеЗначение)
	
	ТипЗначения = ТипЗнч(ПроверяемоеЗначение);
	
	Если ТипЗначения = Тип("Поток")
		ИЛИ ТипЗначения = Тип("ПотокВПамяти")
		ИЛИ ТипЗначения = Тип("ФайловыйПоток") Тогда
		Если НЕ ПроверяемоеЗначение.ДоступноЧтение Тогда
			ВызватьИсключение НСтр("ru = 'Из переданного потока чтение невозможно.'");
		КонецЕсли;
	Иначе
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для читаемого потока.'"), Строка(ТипЗначения));
	КонецЕсли;
	
КонецПроцедуры

// Проверяет, что переданное значение является потоком, доступным для записи.
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный - проверяемое значение.
// 
// Исключение:
//  В случае неправильного значения вызывается исключение.
Процедура ПроверитьПотокЗаписи(ПроверяемоеЗначение)
	
	ТипЗначения = ТипЗнч(ПроверяемоеЗначение);
	
	Если ТипЗначения = Тип("Поток")
		ИЛИ ТипЗначения = Тип("ПотокВПамяти")
		ИЛИ ТипЗначения = Тип("ФайловыйПоток") Тогда
		Если НЕ ПроверяемоеЗначение.ДоступнаЗапись Тогда
			ВызватьИсключение НСтр("ru = 'В переданный поток запись недоступна.'");
		КонецЕсли;
	Иначе
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для потока, в который ведется запись.'"),
			Строка(ТипЗначения));
	КонецЕсли;
	
КонецПроцедуры

// Выполняет проверку значения на то, что оно является натуральным числом в указанном диапазоне.
// 
// Параметры:
//  ПроверяемоеЗначение - Произвольный - проверяемое значение.
//  МинимальноеЗначение - Произвольный
//  МаксимальноеЗначение - Произвольный
// 
// Исключение:
//  В случае неправильного значения вызывается исключение.
Процедура ПроверитьЦелоеЧисло(ПроверяемоеЗначение, МинимальноеЗначение = Неопределено, МаксимальноеЗначение = Неопределено)
	
	Если ТипЗнч(ПроверяемоеЗначение) <> Тип("Число") Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для натурального числа.'"),
			Строка(ТипЗнч(ПроверяемоеЗначение)));
	КонецЕсли;
	
	Если Цел(ПроверяемоеЗначение) <> ПроверяемоеЗначение Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Вместо натурального числа передано вещественное: %1'"),
			XMLСтрока(ПроверяемоеЗначение));
	КонецЕсли;
	
	Если МинимальноеЗначение <> Неопределено Тогда
		Если ТипЗнч(МинимальноеЗначение) <> Тип("Число") Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для минимального значения числа.'"),
				Строка(ТипЗнч(МинимальноеЗначение)));
		КонецЕсли;
		
		Если ПроверяемоеЗначение < МинимальноеЗначение Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Проверяемое число: %1 меньше минимального значения: %2'"),
				Строка(ПроверяемоеЗначение), Строка(МинимальноеЗначение));
		КонецЕсли;
	КонецЕсли;
	
	Если МаксимальноеЗначение <> Неопределено Тогда
		Если ТипЗнч(МаксимальноеЗначение) <> Тип("Число") Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Неверный тип значения: %1 для максимального значения числа.'"),
				Строка(ТипЗнч(МаксимальноеЗначение)));
		КонецЕсли;
		
		Если ПроверяемоеЗначение > МаксимальноеЗначение Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Проверяемое число: %1 больше максимального значения: %2'"),
				Строка(ПроверяемоеЗначение), Строка(МаксимальноеЗначение));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ВизуализацияЭП

// Преобразовывает файл формата OpenOffice в pdf, возвращает двоичные данные созданного файла.
// 
// Параметры:
//  ДвоичныеДанныеФайла - ДвоичныеДанные - Двоичные данные исходного файла
//  Расширение - Строка - Расширение исходного файла
// 
// Возвращаемое значение:
//  ДвоичныеДанные - Преобразованный в pdf файл
//
Функция ПреобразоватьOpenOfficeВPdf(ДвоичныеДанныеФайла, Расширение)
	
	Если ОбщегоНазначения.ЭтоWindowsСервер() Тогда
		Попытка
			ОбъектServiceManager = Новый COMОбъект("com.sun.star.ServiceManager");
		Исключение
			ВызватьИсключение(НСтр("ru = 'Ошибка работы с приложением Open Office. 
				|Необходимо проверить правильность установки приложения.'"));
		КонецПопытки;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Работа с файлами Open Office возможна только в Windows. 
			|Обратитесь к администратору.'"));
	КонецЕсли;
	
	ИнстансDesktop = ОбъектServiceManager.createInstance("com.sun.star.frame.Desktop");
	
	РасширениеДляЗаписи = "pdf";
	
	ИмяВременногоФайлаOffice = ПолучитьИмяВременногоФайла(Расширение);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(РасширениеДляЗаписи);
	ДвоичныеДанныеФайла.Записать(ИмяВременногоФайлаOffice);
	
	// Параметры открытия: отключение исполнения макросов.
	ПараметрыДокумента = Новый COMSafeArray("VT_VARIANT", 2);
	
	РежимЗапуска = ПрисвоитьЗначениеСвойствуOpenOffice(ОбъектServiceManager,
		"MacroExecutionMode",
		0); // const short NEVER_EXECUTE = 0
	ПараметрыДокумента.SetValue(0, РежимЗапуска);

	Hidden = ПрисвоитьЗначениеСвойствуOpenOffice(ОбъектServiceManager,
		"Hidden",
		Истина); // true
	ПараметрыДокумента.SetValue(1, Hidden);
	
	// Открыть документ OpenOffice.
	Document = ИнстансDesktop.loadComponentFromURL(ПреобразоватьВURL(ИмяВременногоФайлаOffice), 
		"_blank", 0, ПараметрыДокумента);
	
	ПараметрыСохранения = Новый COMSafeArray("VT_VARIANT", 2);
	FilterName = ПрисвоитьЗначениеСвойствуOpenOffice(ОбъектServiceManager,
		"FilterName",
		"writer_pdf_Export");
	ПараметрыСохранения.SetValue(0, FilterName);
	
	SelectPdfVersion = ПрисвоитьЗначениеСвойствуOpenOffice(ОбъектServiceManager, 
		"SelectPdfVersion",
		0); // 0 = PDF 1.4 
	ПараметрыСохранения.SetValue(1, SelectPdfVersion);
	
	Document.storeToURL(ПреобразоватьВURL(НовыйПутьКФайлу), ПараметрыСохранения);
	
	Document.close(-1); // Закрыть документ
	
 	Document = Неопределено;
    ИнстансDesktop = Неопределено;
    ОбъектServiceManager = Неопределено;
		
	Результат = Новый ДвоичныеДанные(НовыйПутьКФайлу);
		
	УдалитьФайлы(ИмяВременногоФайлаOffice);
	УдалитьФайлы(НовыйПутьКФайлу);
	
	Возврат Результат;
	
КонецФункции

// Преобразовывает файл формата Word в pdf, возвращает двоичные данные созданного файла,
// экспорт в pdf поддерживается в версиях Word >= 2007 (12.0).
// 
// Параметры:
//  ДвоичныеДанныеФайла - ДвоичныеДанные - Двоичные данные исходного файла
//  Расширение - Строка - Расширение исходного файла
// 
// Возвращаемое значение:
//  Неопределено, ДвоичныеДанные - Преобразованный в pdf файл
//
Функция ПреобразоватьWordВPdf(ДвоичныеДанныеФайла, Расширение)
 
	Если ОбщегоНазначения.ЭтоWindowsСервер() Тогда
		Попытка
			WordApp = Новый COMОбъект("Word.Application");
		Исключение
			ВызватьИсключение (НСтр("ru = 'Ошибка работы с приложением MS Word. 
				|Необходимо проверить правильность установки приложения.'"));
		КонецПопытки;
	Иначе
		ВызватьИсключение (НСтр("ru = 'Работа с файлами MS Office возможна только в Windows. 
			|Обратитесь к администратору.'"));
	КонецЕсли;
	
	ВерсияWord = WordApp.Version + ".0.0";
	Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияWord, "12.0.0.0") < 0 Тогда
		Возврат Неопределено; // экспорт в pdf не поддерживается
	КонецЕсли;
		
	РасширениеДляЗаписи = "pdf";
	
	ИмяВременногоФайлаOffice = ПолучитьИмяВременногоФайла(Расширение);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(РасширениеДляЗаписи);
	ДвоичныеДанныеФайла.Записать(ИмяВременногоФайлаOffice);
	
	Док = WordApp.Documents.Add(ИмяВременногоФайлаOffice);
	
	wdExportFormatPDF = 17;
	Док.ExportAsFixedFormat(НовыйПутьКФайлу, wdExportFormatPDF);
	
	Док.Close(0); // 0 -закрыть без сохранения

	WordApp.Quit();
	WordApp = Неопределено;
	
	Результат = Новый ДвоичныеДанные(НовыйПутьКФайлу);	
		
	УдалитьФайлы(ИмяВременногоФайлаOffice);
	УдалитьФайлы(НовыйПутьКФайлу);
	
	Возврат Результат;
	
КонецФункции

// Преобразовывает файл формата Excel в pdf, возвращает двоичные данные созданного файла,
// экспорт в pdf поддерживается в версиях Excel >= 2007 (12.0).
// 
// Параметры:
//  ДвоичныеДанныеФайла - ДвоичныеДанные - Двоичные данные исходного файла
//  Расширение - Строка - Расширение исходного файла
// 
// Возвращаемое значение:
//  Неопределено, ДвоичныеДанные - Преобразованный в pdf файл
//
Функция ПреобразоватьExcelВPdf(ДвоичныеДанныеФайла, Расширение)
 
	Если ОбщегоНазначения.ЭтоWindowsСервер() Тогда
 		Попытка
			ExcelApp = Новый COMОбъект("Excel.Application");
		Исключение
			ВызватьИсключение (НСтр("ru = 'Ошибка работы с приложением MS Excel. 
				|Необходимо проверить правильность установки приложения.'"));
 		КонецПопытки;
	Иначе
		ВызватьИсключение(НСтр("ru = 'Работа с файлами MS Office возможна только в Windows. 
			|Обратитесь к администратору.'"));
	КонецЕсли;

	ВерсияExcel = ExcelApp.Version + ".0.0";
	Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияExcel, "12.0.0.0") < 0 Тогда
		Возврат Неопределено; // экспорт в pdf не поддерживается
	КонецЕсли;
	
	РасширениеДляЗаписи = "pdf";
	
	ИмяВременногоФайлаOffice = ПолучитьИмяВременногоФайла(Расширение);
	ДвоичныеДанныеФайла.Записать(ИмяВременногоФайлаOffice);
	НовыйПутьКФайлу = ПолучитьИмяВременногоФайла(РасширениеДляЗаписи);	
	
	ExcelApp.WorkBooks.Open(ИмяВременногоФайлаOffice,, 1); // 1 - только для чтения
	ExcelЛист = ExcelApp.ActiveSheet;
	
	xlTypePDF = 0;
	ExcelЛист.ExportAsFixedFormat(xlTypePDF, НовыйПутьКФайлу);
	ExcelApp.ActiveWorkbook.Close(0); // 0 - без записи изменений
	
	ExcelApp.Quit();
	ExcelApp = Неопределено;
	
	Результат = Новый ДвоичныеДанные(НовыйПутьКФайлу);
		
	УдалитьФайлы(ИмяВременногоФайлаOffice);
	УдалитьФайлы(НовыйПутьКФайлу);
	
	Возврат Результат;
	
КонецФункции

// Преобразует Windows имя файла в URL OpenOffice.
// 
// Параметры:
//  ИмяФайла - Строка - Имя файла
// 
// Возвращаемое значение:
//  Строка - Преобразованное в URL имя файла
//
Функция ПреобразоватьВURL(ИмяФайла)
	Возврат "file:///" + СтрЗаменить(ИмяФайла, "\", "/");
КонецФункции

// Формирует структуру для параметров OpenOffice.
// 
// Параметры:
//  Объект - COMОбъект - "com.sun.star.frame.Desktop"
//  ИмяСвойства - Строка - Имя свойства
//  ЗначениеСвойства - Строка - Значение свойства
// 
// Возвращаемое значение:
//  COMОбъект - заполненная структура свойства
//  
Функция ПрисвоитьЗначениеСвойствуOpenOffice(Объект, ИмяСвойства, ЗначениеСвойства)
	
	Свойства = Объект.Bridge_GetStruct("com.sun.star.beans.PropertyValue");
	Свойства.Name = ИмяСвойства;
	Свойства.Value = ЗначениеСвойства;
	
	Возврат Свойства;
	
КонецФункции

#КонецОбласти 

#КонецОбласти
