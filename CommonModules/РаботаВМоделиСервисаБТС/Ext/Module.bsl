////////////////////////////////////////////////////////////////////////////////
// Подсистема "Базовая функциональность в модели сервиса".
// Серверные процедуры и функции общего назначения:
// - Поддержка работы в модели сервиса.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Формирует подпись переданных данных с помощью переданного ключа алгоритмом HMAC-SHA256.
//
// Параметры:
//   Ключ - ДвоичныеДанные - двоичные данные ключа подписи.
//   Данные - Строка - подписываемые данные.
//
// Возвращаемое значение:
//   Строка - подпись в формате Base64.
//
Функция Подпись(Ключ, Данные) Экспорт
	
	Возврат Base64Строка(HMACSHA256(Ключ, ПолучитьДвоичныеДанныеИзСтроки(Данные)));
	
КонецФункции

#КонецОбласти 

#Область СлужебныйПрограммныйИнтерфейс

// Возвращает HMACSHA-256
// 
// Параметры: 
//  Ключ - ДвоичныеДанные
//  Данные - ДвоичныеДанные
// 
// Возвращаемое значение:
//  ДвоичныеДанные
Функция HMACSHA256(Знач Ключ, Знач Данные) Экспорт
	
	Возврат HMAC(Ключ, Данные, ХешФункция.SHA256, 64);
	
КонецФункции

// Параметры: 
//  Данные - Структура
// 
// Возвращаемое значение: 
//  Строка - строка из структуры JSON.
Функция СтрокаИзСтруктурыJSON(Данные) Экспорт
	
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписатьJSON(ЗаписьJSON, Данные, , "ПреобразованиеЗначенийJSON", РаботаВМоделиСервисаБТС);
	Возврат ЗаписьJSON.Закрыть();
	
КонецФункции

// Параметры:
// 	Строка - Строка - строка в формате JSON.
// 	СвойстваТипаДата - Массив из Строка - имена свойств с типом "Дата".
// 
// Возвращаемое значение:
// 	Произвольный, Структура - полученная Структура:
// 	* Поле - Произвольный - произвольный набор полей
//
Функция СтруктураИзСтрокиJSON(Строка, СвойстваТипаДата = Неопределено) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(Строка);
	Ответ = ПрочитатьJSON(ЧтениеJSON,, СвойстваТипаДата, ФорматДатыJSON.ISO); 
	Возврат Ответ;
	
КонецФункции

// Параметры:
// 	ПотокДанных - ФайловыйПоток, ПотокВПамяти - поток данных.
// 	СвойстваТипаДата - Массив из Строка - имена свойств с типом "Дата".
// 
// Возвращаемое значение:
// 	Произвольный, Структура - полученная Структура:
// 	* Поле - Произвольный - произвольный набор полей
//
Функция СтруктураИзПотокаJSON(ПотокДанных, СвойстваТипаДата = Неопределено) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.ОткрытьПоток(ПотокДанных);
	Ответ = ПрочитатьJSON(ЧтениеJSON, , СвойстваТипаДата, ФорматДатыJSON.ISO);
	ЧтениеJSON.Закрыть();
	Возврат Ответ;
	
КонецФункции

// Отправляет данные на указанный адрес в Менеджер сервиса.
//
// Параметры:
//  Метод - Строка - имя HTTP-метода для запроса согласно стандарту RFC7230 (https://tools.ietf.org/html/rfc7230).
//  Адрес  - Строка - адрес, на который отправляются данные, например "hs/ext_api/execute".
//  Данные - Структура - данные, отправляемые в менеджер сервиса.
//  КэшСоединения - Булево - использовать кэш соединения при отправке запросов.
//  Таймаут - Строка - время ожидания ответа от менеджера сервиса.
// 
// Возвращаемое значение:
//  HTTPОтвет - ответ HTTP-сервиса Менеджера сервиса. 
//
Функция ОтправитьЗапросВМенеджерСервиса(Метод, Адрес, Знач Данные = Неопределено, КэшСоединения = Истина, Таймаут = 60) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ПолныйАдрес = СтрШаблон("%1/%2", РаботаВМоделиСервиса.ВнутреннийАдресМенеджераСервиса(), Адрес);

	ДанныеСервера = ОбщегоНазначенияКлиентСервер.СтруктураURI(ПолныйАдрес);

	УстановитьОтключениеБезопасногоРежима(Истина);

	Если КэшСоединения Тогда
		Соединение = РаботаВМоделиСервисаБТСПовтИсп.СоединениеСМенеджеромСервиса(ДанныеСервера, Таймаут);
	Иначе
		Соединение = СоединениеСМенеджеромСервиса(ДанныеСервера, Таймаут);
	КонецЕсли;

	Запрос = Новый HTTPЗапрос(ДанныеСервера.ПутьНаСервере);
	Запрос.Заголовки.Вставить("Content-Type", "application/json; charset=utf-8");

	Если ТипЗнч(Данные) = Тип("Структура") Тогда
		Данные = СтрокаИзСтруктурыJSON(Данные);
		Запрос.УстановитьТелоИзСтроки(Данные);
	ИначеЕсли ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
		Запрос.УстановитьТелоИзДвоичныхДанных(Данные);
	ИначеЕсли ТипЗнч(Данные) = Тип("Строка") Тогда
		Запрос.УстановитьТелоИзСтроки(Данные);
	КонецЕсли;

	Возврат Соединение.ВызватьHTTPМетод(Метод, Запрос);

КонецФункции
 
// Возвращает HTTP-соединение с Менеджером сервиса.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Параметры:
//	ДанныеСервера - Структура - см ОбщегоНазначенияКлиентСервер.СтруктураURI
//	Таймаут - Число - время ожидания ответа от сервера
//	ТокенДоступа - Строка - токен доступа пользователя
// 
// Возвращаемое значение:
//  HTTPСоединение - соединение с Менеджером сервиса.
//
Функция СоединениеСМенеджеромСервиса(ДанныеСервера, Таймаут = 60) Экспорт

	СхемаSSL = "https";
	Если НРег(ДанныеСервера.Схема) = СхемаSSL Тогда
		ЗащищенноеСоединение =  ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение();
	Иначе
		ЗащищенноеСоединение = Неопределено;
	КонецЕсли;

	Соединение = Новый HTTPСоединение(ДанныеСервера.Хост, ДанныеСервера.Порт,
		РаботаВМоделиСервиса.ИмяСлужебногоПользователяМенеджераСервиса(),
		РаботаВМоделиСервиса.ПарольСлужебногоПользователяМенеджераСервиса(),
		ПолучениеФайловИзИнтернета.ПолучитьПрокси(ДанныеСервера.Схема), Таймаут, ЗащищенноеСоединение);
	
	Возврат Соединение;

КонецФункции

// Шаблон параметров действия "Прикрепить область данных".
// 
// Возвращаемое значение:
//  Структура:
//   * ЧасовойПоясПриложения - Неопределено
//   * ПредставлениеПриложения - Неопределено
//   * СписокПользователей - Неопределено
//   * КодОбластиДанных - Неопределено
//   * ВидПриложения - Неопределено
Функция НовыйПараметрыДействияПрикрепитьОбластьДанных() Экспорт
	
	Параметры = Новый Структура;
	Параметры.Вставить("КодОбластиДанных", Неопределено);
	Параметры.Вставить("СписокПользователей", Неопределено);
	Параметры.Вставить("ПредставлениеПриложения", Неопределено);
	Параметры.Вставить("ЧасовойПоясПриложения", Неопределено);
	Параметры.Вставить("ВидПриложения", Неопределено);
	
	Возврат Параметры;
	
КонецФункции

// Возвращает пользователя области по идентификатору пользователя сервиса.
// 
// Параметры: 
//  ИдентификаторПользователяСервиса - УникальныйИдентификатор
// 
// Возвращаемое значение:
//  СправочникСсылка.Пользователи - полученный пользователь.
Функция ПользовательОбластиПоИдентификаторуПользователяСервиса(Знач ИдентификаторПользователяСервиса) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Пользователи.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.Пользователи КАК Пользователи
	|ГДЕ
	|	Пользователи.ИдентификаторПользователяСервиса = &ИдентификаторПользователяСервиса";
	Запрос.УстановитьПараметр("ИдентификаторПользователяСервиса", ИдентификаторПользователяСервиса);
	
	Блокировка = Новый БлокировкаДанных;
	Блокировка.Добавить("Справочник.Пользователи");
	
	НачатьТранзакцию();
	Попытка
		Блокировка.Заблокировать();
		Результат = Запрос.Выполнить();
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если Результат.Пустой() Тогда
		ШаблонСообщения = НСтр("ru = 'Не найден пользователь с идентификатором пользователя сервиса %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИдентификаторПользователяСервиса);
		ВызватьИсключение(ТекстСообщения);
	КонецЕсли;
	
	Выборка = Результат.Выбрать();
	Выборка.Следующий();
	
	Возврат Выборка.Ссылка;
	
КонецФункции

// Вызывается при установке конечной точки Менеджера сервиса.
// @skip-warning ПустойМетод - особенность реализации.
// @skip-check module-empty-method
Процедура ПриУстановкеКонечнойТочкиМенеджераСервиса() Экспорт
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Добавляет в список процедуры-обработчики обновления данных ИБ
// для всех поддерживаемых версий библиотеки или конфигурации.
// Вызывается перед началом обновления данных ИБ для построения плана обновления.
//
// Параметры:
//  Обработчики - ТаблицаЗначений - описание полей 
//                                  см. в процедуре ОбновлениеИнформационнойБазы.НоваяТаблицаОбработчиковОбновления.
//
// Пример:
//  // Добавление обработчика в список.
//  Обработчик = Обработчики.Добавить();
//  Обработчик.Версия              = "1.0.0.0";
//  Обработчик.Процедура           = "ОбновлениеИБ.ПерейтиНаВерсию_1_0_0_0";
//  Обработчик.МонопольныйРежим    = Ложь;
//  Обработчик.Опциональный        = Истина;
// 
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Если ОбщегоНазначения.РазделениеВключено() Тогда
		
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "*";
		Обработчик.Процедура = "РаботаВМоделиСервисаБТС.СоздатьНеразделенныеПредопределенныеЭлементы";
		Обработчик.Приоритет = 99;
		Обработчик.ОбщиеДанные = Истина;
		Обработчик.МонопольныйРежим = Ложь;
				
				
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет обработчик разделенных данных, зависимый от изменения неразделенных данных.
//
// Параметры:
//   Параметры - Структура - структура параметров обработчиков:
//     * РазделенныеОбработчики - см. ОбновлениеИнформационнойБазы.НоваяТаблицаОбработчиковОбновления
// 
Процедура ЗаполнитьОбработчикиРазделенныхДанных(Параметры = Неопределено) Экспорт
	
	
КонецПроцедуры

// Вызывается при включении разделения данных по областям данных.
//
Процедура ПриВключенииРазделенияПоОбластямДанных() Экспорт
	
	СоздатьНеразделенныеПредопределенныеЭлементы();
	
КонецПроцедуры

// Формирует список параметров ИБ.
//
// Параметры:
// ТаблицаПараметров - см. РаботаВМоделиСервиса.ПараметрыИБ
//
Процедура ПриЗаполненииТаблицыПараметровИБ(Знач ТаблицаПараметров) Экспорт
	
	РаботаВМоделиСервиса.ДобавитьКонстантуВТаблицуПараметровИБ(ТаблицаПараметров, "ВнешнийАдресУправляющегоПриложения");
	
КонецПроцедуры

// Обработчик создания/обновления предопределенных элементов
// неразделенных объектов метаданных.
//
Процедура СоздатьНеразделенныеПредопределенныеЭлементы() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если ОбщегоНазначения.РазделениеВключено() И ОбщегоНазначения.ДоступноИспользованиеРазделенныхДанных() Тогда
		
		ВызватьИсключение НСтр("ru = 'Операция может быть выполнена только в сеансе, в котором не установлены значения разделителей'");
		
	КонецЕсли;
	
	ИнициализироватьПредопределенныеДанные();
	
КонецПроцедуры

// Обработчик создания/обновления групп доступа поставляемых профилей
// Параметры:
//  Параметры - Произвольный
Процедура ОбновитьГруппыДоступаПоставляемыхПрофилей(Параметры = Неопределено) Экспорт
КонецПроцедуры

// Вызывается при формировании манифеста конфигурации.
//
// Параметры:
//  РасширенныеСведения - Массив из ОбъектXDTO - внутри процедуры обработчика в данный массив требуется
//    добавить объекты типа ОбъектXDTO с ТипомXDTO, унаследованным от
//    {http://www.1c.ru/1cFresh/Application/Manifest/a.b.c.d}ExtendedInfoItem.
//
Процедура ПриФормированииМанифестаКонфигурации(РасширенныеСведения) Экспорт
	
	Если ТранзакцияАктивна() Тогда
		ВызватьИсключение НСтр("ru = 'Операция не может быть выполнена при активной внешней транзакции'");
	КонецЕсли;
	
	ВызовВНеразделеннойИБ = Не ОбщегоНазначения.РазделениеВключено();
	
	НачатьТранзакцию();
	
	Попытка
		
		ОписаниеРазрешений = ФабрикаXDTO.Создать(
			ФабрикаXDTO.Тип("http://www.1c.ru/1cFresh/Application/Permissions/Manifes/1.0.0.1", "RequiredPermissions"));
		
		ОписаниеВнешнихКомпонент = ФабрикаXDTO.Создать(
			ФабрикаXDTO.Тип("http://www.1c.ru/1cFresh/Application/Permissions/Manifes/1.0.0.1", "Addins"));
		
		МакетыВнешнихКомпонент = Новый Соответствие();
		ИспользоватьРазделениеПоОбластямДанных = Константы.ИспользоватьРазделениеПоОбластямДанных.Получить();
		ОтключитьРазделениеПоОбластямДанных = Ложь;
		
		Если ВызовВНеразделеннойИБ Тогда
			
			Если НЕ ИспользоватьРазделениеПоОбластямДанных Тогда
				Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Истина);
				ОтключитьРазделениеПоОбластямДанных = Истина;
			КонецЕсли; 
			
			ОбновитьПовторноИспользуемыеЗначения();
			
		КонецЕсли;
		
		Константы.ИспользуютсяПрофилиБезопасности.Установить(Истина);
		Константы.АвтоматическиНастраиватьРазрешенияВПрофиляхБезопасности.Установить(Истина);
		
		ИдентификаторыЗапросов = РаботаВБезопасномРежиме.ЗапросыОбновленияРазрешенийКонфигурации();
		
		МенеджерПрименения = РаботаВБезопасномРежимеСлужебныйВМоделиСервиса.МенеджерПримененияРазрешений(ИдентификаторыЗапросов);
		Дельта = МенеджерПрименения.ДельтаБезУчетаВладельцев();
		
		МакетыВнешнихКомпонент = Новый Массив();
		
		Для Каждого ЭлементДельты Из Дельта.Добавляемые Цикл
			
			Для Каждого КлючИЗначение Из ЭлементДельты.Разрешения Цикл
				
				Разрешение = ОбщегоНазначения.ОбъектXDTOИзСтрокиXML(КлючИЗначение.Значение);
				ОписаниеРазрешений.Permission.Добавить(Разрешение);
				
				Если Разрешение.Тип() = ФабрикаXDTO.Тип("http://www.1c.ru/1cFresh/Application/Permissions/1.0.0.1", "AttachAddin") Тогда
					МакетыВнешнихКомпонент.Добавить(Разрешение.TemplateName);
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
		
		Для Каждого ИмяМакета Из МакетыВнешнихКомпонент Цикл
			
			ОписаниеВнешнейКомпоненты = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип("http://www.1c.ru/1cFresh/Application/Permissions/Manifes/1.0.0.1", "AddinBundle"));
			ОписаниеВнешнейКомпоненты.TemplateName = ИмяМакета;
			
			ОписанияФайлов = РаботаВБезопасномРежиме.КонтрольныеСуммыФайловКомплектаВнешнейКомпоненты(ИмяМакета);
			
			Для Каждого КлючИЗначение Из ОписанияФайлов Цикл
				
				ОписаниеФайла = ФабрикаXDTO.Создать(ФабрикаXDTO.Тип("http://www.1c.ru/1cFresh/Application/Permissions/Manifes/1.0.0.1", "AddinFile"));
				ОписаниеФайла.FileName = КлючИЗначение.Ключ;
				ОписаниеФайла.Hash = КлючИЗначение.Значение;
				
				ОписаниеВнешнейКомпоненты.Files.Добавить(ОписаниеФайла);
				
			КонецЦикла;
			
			ОписаниеВнешнихКомпонент.Bundles.Добавить(ОписаниеВнешнейКомпоненты);
			
		КонецЦикла;
		
		РасширенныеСведения.Добавить(ОписаниеРазрешений);
		РасширенныеСведения.Добавить(ОписаниеВнешнихКомпонент);
		
		Если ОтключитьРазделениеПоОбластямДанных Тогда
			Константы.ИспользоватьРазделениеПоОбластямДанных.Установить(Ложь);
		КонецЕсли; 
		
	Исключение
		
		ОтменитьТранзакцию();
		Если ВызовВНеразделеннойИБ Тогда
			ОбновитьПовторноИспользуемыеЗначения();
		КонецЕсли;
		
		ВызватьИсключение;
		
	КонецПопытки;
	
	ОтменитьТранзакцию();
	Если ВызовВНеразделеннойИБ Тогда
		ОбновитьПовторноИспользуемыеЗначения();
	КонецЕсли;
	
КонецПроцедуры

// Возвращает внутренний адрес менеджера сервиса.
//
// Возвращаемое значение:
//  Строка - внутренний адрес менеджера сервиса.
//
Функция ВнутреннийАдресМенеджераСервиса() Экспорт
	
	Возврат Константы.ВнутреннийАдресМенеджераСервиса.Получить();
	
КонецФункции

// Устанавливает внутренний адрес менеджера сервиса.
//
// Параметры:
//  Значение - Строка - внутренний адрес менеджера сервиса.
//
Процедура УстановитьВнутреннийАдресМенеджераСервиса(Знач Значение) Экспорт
	
	Константы.ВнутреннийАдресМенеджераСервиса.Установить(Значение);
	
КонецПроцедуры

// Возвращает адрес провайдера аутентификации.
//
// Возвращаемое значение:
//  Строка - адрес провайдера аутентификации.
//
Функция АдресПровайдераАутентификации() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.АдресПровайдераАутентификации.Получить();
	
КонецФункции

// Возвращает признак аутентификации токеном доступа внутренних вызовов программного интерфейса.
// 
// Возвращаемое значение:
//  Булево
Функция АутентификацияТокеномДоступаВнутреннихВызововПрограммногоИнтерфейса() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.АутентификацияТокеномДоступаВнутреннихВызововПрограммногоИнтерфейса.Получить();
	
КонецФункции

// Устанавливает адрес провайдера аутентификации.
//
// Параметры:
//  Значение - Строка - адрес провайдера аутентификации.
//
Процедура УстановитьАдресПровайдераАутентификации(Знач Значение) Экспорт
	
	Константы.АдресПровайдераАутентификации.Установить(Значение);
	
КонецПроцедуры

Процедура УстановитьАутентификацияТокеномДоступаВнутреннихВызововПрограммногоИнтерфейса(Знач Значение) Экспорт
	
	Константы.АутентификацияТокеномДоступаВнутреннихВызововПрограммногоИнтерфейса.Установить(Значение);
	
КонецПроцедуры

// Возвращает имя служебного пользователя менеджера сервиса.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Возвращаемое значение:
//  Строка - имя служебного пользователя менеджера сервиса.
//
Функция ИмяСлужебногоПользователяМенеджераСервиса() Экспорт
	
	Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Константа.ВнутреннийАдресМенеджераСервиса");
	ИмяСлужебногоПользователя = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(Владелец, "ИмяСлужебногоПользователяМенеджераСервиса", Истина);
	
	Возврат ИмяСлужебногоПользователя;
	
КонецФункции

// Возвращает пароль служебного пользователя менеджера сервиса.
// Вызывающий код должен самостоятельно устанавливать привилегированный режим.
//
// Возвращаемое значение:
//  Строка - пароль служебного пользователя менеджера сервиса.
//
Функция ПарольСлужебногоПользователяМенеджераСервиса() Экспорт
	
	Владелец = ОбщегоНазначения.ИдентификаторОбъектаМетаданных("Константа.ВнутреннийАдресМенеджераСервиса");
	ПарольСлужебногоПользователя = ОбщегоНазначения.ПрочитатьДанныеИзБезопасногоХранилища(Владелец, "ПарольСлужебногоПользователяМенеджераСервиса", Истина);
	
	Возврат ПарольСлужебногоПользователя;
	
КонецФункции

// Возвращает конечную точку для отправки сообщений в менеджер сервиса.
//
// Возвращаемое значение:
//  ПланОбменаСсылка.ОбменСообщениями - узел соответствующий менеджеру сервиса.
//
Функция КонечнаяТочкаМенеджераСервиса() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.КонечнаяТочкаМенеджераСервиса.Получить();
	
КонецФункции

// Параметры: 
//  КодЯзыка - Строка
// 
// Возвращаемое значение: 
//  Строка - Язык по коду.
//
Функция ЯзыкПоКоду(Знач КодЯзыка) Экспорт
	
	Если ЗначениеЗаполнено(КодЯзыка) Тогда
		
		Для каждого Язык Из Метаданные.Языки Цикл
			Если Язык.КодЯзыка = КодЯзыка Тогда
				Возврат Язык.Имя;
			КонецЕсли;
		КонецЦикла;
		
		ШаблонСообщения = НСтр("ru = 'Неподдерживаемый код языка: %1'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, КодЯзыка);
		ВызватьИсключение(ТекстСообщения);
		
	Иначе
		
		Возврат Метаданные.ОсновнойЯзык.Имя;
		
	КонецЕсли;
	
КонецФункции

// Состав почтового адреса
// 
// Параметры: 
//  АдресЭП - Строка -Адрес ЭП
// 
// Возвращаемое значение:
// Структура: 
//   * Статус - Булево - успех или неуспех преобразования.
//   * Значение - Массив из Структура:
//    ** Адрес - Строка - e-mail получателя.
//    ** Представление - Строка - имя получателя.
//   * СообщениеОбОшибке - Строка - (параметр доступен, если Статус = Ложь) информация об ошибке.
// (См. ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСПочтовымиАдресами.)
Функция СоставПочтовогоАдреса(Знач АдресЭП) Экспорт
	
	Если ЗначениеЗаполнено(АдресЭП) Тогда
		
		Попытка
			СтруктураАдресаЭП = ОбщегоНазначенияКлиентСервер.РазобратьСтрокуСПочтовымиАдресами(АдресЭП);
		Исключение
			ШаблонСообщения = НСтр("ru = 'Указан некорректный адрес электронной почты: %1
				|Ошибка: %2'");
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, АдресЭП, ИнформацияОбОшибке().Описание);
			ВызватьИсключение(ТекстСообщения);
		КонецПопытки;
		
		Возврат СтруктураАдресаЭП;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

Процедура ОбновитьАдресЭлектроннойПочты(Знач ПользовательОбъект, Знач Адрес, Знач СтруктураАдресаЭП) Экспорт
	
	ВидКИ = Справочники.ВидыКонтактнойИнформации.EmailПользователя;
	
	Если СтруктураАдресаЭП = Неопределено Тогда
		СтрокаТабличнойЧасти = ПользовательОбъект.КонтактнаяИнформация.Найти(ВидКИ, "Вид");
		Если СтрокаТабличнойЧасти <> Неопределено Тогда
			ПользовательОбъект.КонтактнаяИнформация.Удалить(СтрокаТабличнойЧасти);
		КонецЕсли;
	Иначе
		УправлениеКонтактнойИнформацией.ДобавитьКонтактнуюИнформацию(ПользовательОбъект, Адрес, ВидКИ);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьТелефон(Знач ПользовательОбъект, Знач Телефон) Экспорт
	
	ВидКИ = Справочники.ВидыКонтактнойИнформации.ТелефонПользователя;
	
	Если ПустаяСтрока(Телефон) Тогда
		СтрокаТабличнойЧасти = ПользовательОбъект.КонтактнаяИнформация.Найти(ВидКИ, "Вид");
		Если СтрокаТабличнойЧасти <> Неопределено Тогда
			ПользовательОбъект.КонтактнаяИнформация.Удалить(СтрокаТабличнойЧасти);
		КонецЕсли;
	Иначе
		УправлениеКонтактнойИнформацией.ДобавитьКонтактнуюИнформацию(ПользовательОбъект, Телефон, ВидКИ);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбновитьСвойстваПредопределенныхУзлов(Знач Наименование) Экспорт

	Если Не ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОбменДанными") Тогда
		
		Возврат;
		
	КонецЕсли;
	
	МодульОбменДаннымиПовтИсп = ОбщегоНазначения.ОбщийМодуль("ОбменДаннымиПовтИсп");
	
	Для Каждого ПланОбмена Из Метаданные.ПланыОбмена Цикл
		
		Если РаботаВМоделиСервиса.ЭтоРазделенныйОбъектМетаданных(ПланОбмена) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	ИСТИНА
			|ИЗ
			|	&ИмяТаблицыПланаОбмена КАК ПланОбмена
			|ГДЕ
			|	ПланОбмена.ЭтотУзел");
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяТаблицыПланаОбмена", "ПланОбмена." + ПланОбмена.Имя);
			
			Если Запрос.Выполнить().Пустой() Тогда
				
				НовыйУзелОбъект = ПланыОбмена[ПланОбмена.Имя].СоздатьУзел();
				НовыйУзелОбъект.ЭтотУзел = Истина;
				НовыйУзелОбъект.ОбменДанными.Загрузка = Истина;
				НовыйУзелОбъект.Записать();
				
			КонецЕсли;
			
		КонецЕсли;
			
		Если МодульОбменДаннымиПовтИсп.ПланОбменаИспользуетсяВМоделиСервиса(ПланОбмена.Имя) Тогда
			
			ЭтотУзел = ПланыОбмена[ПланОбмена.Имя].ЭтотУзел();
			НаименованиеУзла = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ЭтотУзел, "Наименование");
			
			Если НаименованиеУзла <> Наименование Тогда
				
				ЭтотУзелОбъект = ЭтотУзел.ПолучитьОбъект();
				ЭтотУзелОбъект.Наименование = Наименование;
				ЭтотУзелОбъект.Записать();
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;

КонецПроцедуры

Процедура ОбновитьКодПредопределенныхУзлов() Экспорт
	
	Если Не ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ОбменДанными") Тогда
		
		Возврат;
		
	КонецЕсли;
	
	МодульОбменДаннымиПовтИсп = ОбщегоНазначения.ОбщийМодуль("ОбменДаннымиПовтИсп");
	
	Для Каждого ПланОбмена Из Метаданные.ПланыОбмена Цикл
		
		Если РаботаВМоделиСервиса.ЭтоРазделенныйОбъектМетаданных(ПланОбмена) Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	ИСТИНА
			|ИЗ
			|	&ИмяТаблицыПланаОбмена КАК ПланОбмена
			|ГДЕ
			|	ПланОбмена.ЭтотУзел");
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяТаблицыПланаОбмена", "ПланОбмена." + ПланОбмена.Имя);
			
			Если Запрос.Выполнить().Пустой() Тогда
				
				НовыйУзел = ПланыОбмена[ПланОбмена.Имя].СоздатьУзел();
				НовыйУзел.ЭтотУзел = Истина;
				НовыйУзел.ОбменДанными.Загрузка = Истина;
				НовыйУзел.Записать();
				
			КонецЕсли;
			
		КонецЕсли;
			
		Если МодульОбменДаннымиПовтИсп.ПланОбменаИспользуетсяВМоделиСервиса(ПланОбмена.Имя) Тогда
			
			ЭтотУзел = ПланыОбмена[ПланОбмена.Имя].ЭтотУзел();
			КодУзла = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ЭтотУзел, "Код");
			
			Если ОбменДаннымиСервер.ЭтоПланОбменаXDTO(ПланОбмена.Имя) Тогда
				
				НовыйКодУзла = Строка(ЭтотУзел.УникальныйИдентификатор());
				
			Иначе
				
				НовыйКодУзла = СообщенияУдаленногоАдминистрированияРеализация.КодУзлаПланаОбменаВСервисе(РаботаВМоделиСервиса.ЗначениеРазделителяСеанса());
				
			КонецЕсли;
			
			Если КодУзла <> НовыйКодУзла Тогда
				
				ЭтотУзелОбъект = ЭтотУзел.ПолучитьОбъект();
				ЭтотУзелОбъект.Код = НовыйКодУзла;
				ЭтотУзелОбъект.Записать();
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбновитьПараметрыТекущейОбластиДанных(Знач Представление, Знач ЧасовойПояс) Экспорт
	
	Константы.ПредставлениеОбластиДанных.Установить(Представление);
	Константы.ЧасовойПоясОбластиДанных.Установить(ЧасовойПояс);
	
	Если ПолучитьЧасовойПоясИнформационнойБазы() <> ЧасовойПояс Тогда
	
		МодульРаботаВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("РаботаВМоделиСервиса");
		
		НачатьТранзакцию();
		
		КаналСообщения = "МонопольныйРежим\УстановитьЧасовойПоясИБ";
		ТелоСообщения = Новый Структура;
		ТелоСообщения.Вставить("ЧасовойПояс", ЧасовойПояс);
		ТелоСообщения.Вставить("ОбластьДанных", МодульРаботаВМоделиСервиса.ЗначениеРазделителяСеанса());
		
		ОбменСообщениями.ОтправитьСообщение(
			КаналСообщения,
			ТелоСообщения,
			ОбменСообщениямиВнутренний.ЭтотУзел());
			
		ЗафиксироватьТранзакцию();
		
	КонецЕсли;
	
КонецПроцедуры

#Область Криптография

Функция Хеш(ДвоичныеДанные, Тип)
	
	Хеширование = Новый ХешированиеДанных(Тип);
	Хеширование.Добавить(ДвоичныеДанные);
	
	Возврат Хеширование.ХешСумма;
		
КонецФункции

Функция HMAC(Знач Ключ, Знач Данные, Тип, РазмерБлока)
	
	Если Ключ.Размер() > РазмерБлока Тогда
		Ключ = Хеш(Ключ, Тип);
	КонецЕсли;
	
	Если Ключ.Размер() < РазмерБлока Тогда
		Ключ = ПолучитьHexСтрокуИзДвоичныхДанных(Ключ);
		Ключ = Лев(Ключ + ПовторитьСтроку("00", РазмерБлока), РазмерБлока * 2);
	КонецЕсли;
	
	Ключ = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ПолучитьДвоичныеДанныеИзHexСтроки(Ключ));
	
	ipad = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("36", РазмерБлока));
	opad = ПолучитьБуферДвоичныхДанныхИзHexСтроки(ПовторитьСтроку("5c", РазмерБлока));
	
	ipad.ЗаписатьПобитовоеИсключительноеИли(0, Ключ);
	ikeypad = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(ipad);
	
	opad.ЗаписатьПобитовоеИсключительноеИли(0, Ключ);
	okeypad = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(opad);
	
	Возврат Хеш(СклеитьДвоичныеДанные(okeypad, Хеш(СклеитьДвоичныеДанные(ikeypad, Данные), Тип)), Тип);
	
КонецФункции

Функция СклеитьДвоичныеДанные(ДвоичныеДанные1, ДвоичныеДанные2)
	
	МассивДвоичныхДанных = Новый Массив;
	МассивДвоичныхДанных.Добавить(ДвоичныеДанные1);
	МассивДвоичныхДанных.Добавить(ДвоичныеДанные2);
	
	Возврат СоединитьДвоичныеДанные(МассивДвоичныхДанных);
	
КонецФункции

Функция ПовторитьСтроку(Строка, Количество)
	
	Части = Новый Массив(Количество);
	Для к = 1 По Количество Цикл
		Части.Добавить(Строка);
	КонецЦикла;
	
	Возврат СтрСоединить(Части, "");
	
КонецФункции

#КонецОбласти

// Функция преобразования значений JSON
// см. функцию глобального контекста - ЗаписатьJSON.
//
// Возвращаемое значение:
//  Строка - УникальныйИдентификатор -> Строка(УникальныйИдентификатор)
//
Функция ПреобразованиеЗначенийJSON(Свойство, Значение, ДополнительныеПараметры, Отказ) Экспорт 
	
    Если ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
        Возврат Строка(Значение);
    КонецЕсли; 
    
    Возврат Значение;
	
КонецФункции

#Область Проверки

// Контроль исключения разделенных объектов в контролирующих подписках.
// 
// Параметры: 
//  ВызыватьИсключение - Булево
// 
// Возвращаемое значение:
//  Неопределено, Структура - если нет ошибок, то Неопределено:
//  * ОбъектыМетаданных - Массив из ОбъектМетаданных
//  * ТекстИсключения - Строка
Функция КонтрольИсключенияРазделенныхОбъектовВКонтролирующихПодписках(ВызыватьИсключение = Истина) Экспорт
	
	ПравилаКонтроляМетаданных = Новый Соответствие;
	
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Константы, "КонстантаМенеджерЗначения.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Справочники, "СправочникОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Документы, "ДокументОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.БизнесПроцессы, "БизнесПроцессОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.Задачи, "ЗадачаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыВидовРасчета, "ПланВидовРасчетаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыВидовХарактеристик, "ПланВидовХарактеристикОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыОбмена, "ПланОбменаОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.ПланыСчетов, "ПланСчетовОбъект.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыБухгалтерии, "РегистрБухгалтерииНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыНакопления, "РегистрНакопленияНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыРасчета, "РегистрРасчетаНаборЗаписей.%1");
	ПравилаКонтроляМетаданных.Вставить(Метаданные.РегистрыСведений, "РегистрСведенийНаборЗаписей.%1");
	
	СтандартныеРазделители = Новый Массив; // Массив Из ОбъектМетаданных
	СтандартныеРазделители.Добавить(Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные);
	СтандартныеРазделители.Добавить(Метаданные.ОбщиеРеквизиты.ОбластьДанныхВспомогательныеДанные);
	
	КонтрольныеПроцедуры = Новый Массив;
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхНаборовЗаписейПриЗаписиТехнологияСервиса.Обработчик);
	КонтрольныеПроцедуры.Добавить(Метаданные.ПодпискиНаСобытия.КонтрольНеразделенныхОбъектовПриЗаписиТехнологияСервиса.Обработчик);
	
	КонтролирующиеПодписки = Новый Массив; // Массив Из ОбъектМетаданныхПодпискаНаСобытие
	Для Каждого ПодпискаНаСобытие Из Метаданные.ПодпискиНаСобытия Цикл
		Если КонтрольныеПроцедуры.Найти(ПодпискаНаСобытие.Обработчик) <> Неопределено Тогда
			КонтролирующиеПодписки.Добавить(ПодпискаНаСобытие);
		КонецЕсли;
	КонецЦикла;
	
	НарушенияКонтроляИсключенияРазделенныхОбъектовВКонтролирующихПодписках = Новый Массив();
	
	ОбъектыМетаданныхСНарушениями = Новый Массив;
	
	Для Каждого ПравилоКонтроляМетаданных Из ПравилаКонтроляМетаданных Цикл
		
		КонтролируемыеОбъектыМетаданных = ПравилоКонтроляМетаданных.Ключ; // Массив Из ОбъектМетаданных
		КонструкторТипаОбъектовМетаданных = ПравилоКонтроляМетаданных.Значение;
		
		Для Каждого КонтролируемыйОбъектМетаданных Из КонтролируемыеОбъектыМетаданных Цикл
			
			
			// 2. Проверка неразделенных объектов метаданных на включение в состав контролирующих
			// подписок на события.
			
			Если ЗначениеЗаполнено(КонструкторТипаОбъектовМетаданных) Тогда
				
				ТипОбъектаМетаданных = Тип(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(КонструкторТипаОбъектовМетаданных, КонтролируемыйОбъектМетаданных.Имя));
				
				ОбеспеченКонтрольИсключенияРазделенныхОбъектовВНеразделенныеПодписки = Истина;
				
				Для Каждого КонтролирующаяПодписка Из КонтролирующиеПодписки Цикл
					
					Если КонтролирующаяПодписка.Источник.СодержитТип(ТипОбъектаМетаданных) Тогда
						Для Каждого СтандартныйРазделитель Из СтандартныеРазделители Цикл
							Если РаботаВМоделиСервиса.ЭтоРазделенныйОбъектМетаданных(КонтролируемыйОбъектМетаданных, СтандартныйРазделитель.Имя) Тогда
								ОбеспеченКонтрольИсключенияРазделенныхОбъектовВНеразделенныеПодписки = Ложь;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					
				КонецЦикла;
				
				Если Не ОбеспеченКонтрольИсключенияРазделенныхОбъектовВНеразделенныеПодписки Тогда
					НарушенияКонтроляИсключенияРазделенныхОбъектовВКонтролирующихПодписках.Добавить(КонтролируемыйОбъектМетаданных);
					ОбъектыМетаданныхСНарушениями.Добавить(КонтролируемыйОбъектМетаданных);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ВызываемыеИсключения = Новый Массив();
	
	Если НарушенияКонтроляИсключенияРазделенныхОбъектовВКонтролирующихПодписках.Количество() > 0 Тогда
		
		ТекстИсключения = "";
		
		Для Каждого НарушающийОбъектМетаданных Из НарушенияКонтроляИсключенияРазделенныхОбъектовВКонтролирующихПодписках Цикл
			
			Если Не ПустаяСтрока(ТекстИсключения) Тогда
				ТекстИсключения = ТекстИсключения + ", ";
			КонецЕсли;
			
			ТекстИсключения = ТекстИсключения + НарушающийОбъектМетаданных.ПолноеИмя();
			
		КонецЦикла;
		
		ТекстПодписок = "";
		Для Каждого КонтролирующаяПодписка Из КонтролирующиеПодписки Цикл
			
			Если Не ПустаяСтрока(ТекстПодписок) Тогда
				ТекстПодписок = ТекстПодписок + ", ";
			КонецЕсли;
			
			ТекстПодписок = ТекстПодписок + КонтролирующаяПодписка.Имя;
			
		КонецЦикла;
		
		ВызываемыеИсключения.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Разделенные объекты метаданных конфигурации не должны входить в состав подписок на события (%1).
                  |Следующие объекты не удовлетворяют этому критерию: %2'"),
			ТекстПодписок, ТекстИсключения));
		
	КонецЕсли;
	
	РезультирующееИсключение = "";
	Итератор = 1;
	
	Для Каждого ВызываемоеИсключение Из ВызываемыеИсключения Цикл
		
		Если Не ПустаяСтрока(РезультирующееИсключение) Тогда
			РезультирующееИсключение = РезультирующееИсключение + Символы.ПС + Символы.ВК;
		КонецЕсли;
		
		РезультирующееИсключение = РезультирующееИсключение + Формат(Итератор, "ЧДЦ=0; ЧГ=0") + ". " + ВызываемоеИсключение;
		Итератор = Итератор + 1;
		
	КонецЦикла;
	
	Если Не ПустаяСтрока(РезультирующееИсключение) Тогда
		
		РезультирующееИсключение = НСтр("ru = 'Обнаружены ошибки в структуре метаданных конфигурации:'") + Символы.ПС + Символы.ВК + РезультирующееИсключение;
		
		Если ВызыватьИсключение Тогда
			
			ВызватьИсключение РезультирующееИсключение;
			
		Иначе
			
			Возврат Новый Структура("ОбъектыМетаданных, ТекстИсключения", ОбъектыМетаданныхСНарушениями, РезультирующееИсключение);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#КонецОбласти
