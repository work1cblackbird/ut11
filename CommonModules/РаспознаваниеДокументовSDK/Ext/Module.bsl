#Область ПрограммныйИнтерфейс

// Выполняет запрос к серверу распознавания документов для получения состояния текущего баланса.
//
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакСостояниеТекущегоБаланса.
//
Функция ТекущийБаланс() Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Таймаут", 2);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/users/balance/struct_docs",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200  Тогда
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка получения свойств текущего баланса.'")
		);
	КонецЕсли;
	
	Возврат КакСостояниеТекущегоБаланса(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для установки адреса электронной почты.
// Этот адрес будет использоваться для уведомления об активации учетной записи
// и для сообщений об изменении баланса.
//
// Параметры:
//  АдресЭлПочты - Строка - Адрес электронной почты клиента.
//
Процедура УстановитьАдресЭлектроннойПочты(АдресЭлПочты) Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	Заголовки.Вставить("Content-Type", "application/json");
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Таймаут", 2);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/users/notification_email",
		"""" + АдресЭлПочты + """",
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Адрес электронной почты не установлен.'")
		);
	КонецЕсли;
	
КонецПроцедуры

// Выполняет запрос к серверу распознавания документов для получения предложений клиенту.
//
// Параметры:
//  Пользователь - Строка - Уникальный идентификатор пользователя ИБ
//  Размещение - Строка - Код места размещения баннера
//  ЗакрытыеБаннеры - Соответствие- Список идентификаторов закрытых баннеров, Ключ - Идентификатор, Значение - Дата
//
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакПерсонализированныеПредложения.
//
Функция ТекущиеПерсонализированныеПредложения(Пользователь = Неопределено, Размещение = Неопределено, ЗакрытыеБаннеры = Неопределено) Экспорт 
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	Заголовки.Вставить("X-appname", ВРег(Метаданные.Имя));
	
	ПараметрыЗапроса = Новый Соответствие;
	Если ЗначениеЗаполнено(Размещение) Тогда
		ПараметрыЗапроса.Вставить("origin", Размещение);
	КонецЕсли;
	Если ЗначениеЗаполнено(ЗакрытыеБаннеры) Тогда
		ИдентификаторыЗакрытыхБаннеров = Новый Массив;
		Для Каждого Баннер Из ЗакрытыеБаннеры Цикл
			ИдентификаторыЗакрытыхБаннеров.Добавить(Баннер.Ключ);
		КонецЦикла;
		ПараметрыЗапроса.Вставить("closed_banners", СтрСоединить(ИдентификаторыЗакрытыхБаннеров, "|"));
	КонецЕсли;
	Если ЗначениеЗаполнено(Пользователь) Тогда
		ПараметрыЗапроса.Вставить("usr_uuid", Пользователь);
	КонецЕсли;
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Таймаут", 2);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/users/special_offers",
		ПараметрыЗапроса,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200  Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка получения персонализированных предложений.'")
		);
	КонецЕсли;
	
	Возврат КакПерсонализированныеПредложения(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для проверки допустимых действий при авторизации.
//
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакДопустимыеДействияПриАвторизации.
//
Функция ТекущиеДопустимыеДействияПриАвторизации() Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	Заголовки.Вставить("X-appname", ВРег(Метаданные.Имя));
	Заголовки.Вставить("Content-Type", "application/json");
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Таймаут", 2);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/users/active_promos",
		,
		Параметры
	);
	
	Возврат КакДопустимыеДействияПриАвторизации(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для активации промокода.
//
// Параметры:
//  Промокод - Строка
//
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакРезультатАктивацииПромокода.
//
Функция АктивироватьПромокод(Промокод) Экспорт
	
	Данные = Новый Структура;
	Данные.Вставить("promocode", Промокод);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	Заголовки.Вставить("X-appname", ВРег(Метаданные.Имя));
	Заголовки.Вставить("Content-Type", "application/json");
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Json", Данные);
	Параметры.Вставить("Таймаут", 2);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/users/activate_promocode",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Возврат КакРезультатАктивацииПромокода(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для создания задания распознавания.
//
// Параметры:
//  ИменаФайлов - Массив из Строка - Имена файлов, которые необходимо отправить на распознавание.
//  ДатаСоздания - Дата - Дата создания задания распознавания, если не указана - текущая дата сеанса.
//
// Возвращаемое значение:
//  Строка - Идентификатор задания распознавания.
//
Функция СоздатьЗаданиеРаспознавания(ИменаФайлов, ДатаСоздания = Неопределено) Экспорт
	
	Если ДатаСоздания = Неопределено Тогда
		ДатаСоздания = ТекущаяДатаСеанса();
	КонецЕсли;
	
	Данные = Новый Структура;
	Данные.Вставить("files", ИменаФайлов);
	Данные.Вставить("create_time", ДатаСоздания);
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Charset", "utf-8");
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Json", Данные);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1/ocr/models/" + НомерМодели() + "/new_task?async=1&lang=rus&api_version=v2",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка создания задания распознавания.'")
		);
	КонецЕсли;
	
	Возврат РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для получения состояния обработки задания распознавания.
//
// Параметры:
//  ИдентификаторЗадания - Строка - Задание состояние которого необходимо получить.
//    Получается с помощью метода См. РаспознаваниеДокументовSDK.СоздатьЗаданиеРаспознавания.
//
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакСостояниеОбработкиЗадания.
//
Функция ПолучитьСостояниеОбработкиЗадания(ИдентификаторЗадания) Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Таймаут", 120);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/ocr/models/" + НомерМодели() + "/result/" + ИдентификаторЗадания + "?only_summary=1&api_version=v2",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200
	   И Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Принято_202
	   И Ответ.КодСостояния < РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ВнутренняяОшибкаСервера_500 Тогда
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка получения результата обработки задания.'")
		);
	КонецЕсли;
	
	Возврат КакСостояниеОбработкиЗадания(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для загрузки файла по выделенному адресу.
//
// Параметры:
//  АдресЗагрузкиФайла - Строка - Адрес, выданный сервером распознавания для загрузки файла.
//    Получается с помощью метода См. РаспознаваниеДокументовSDK.ПолучитьСостояниеОбработкиЗадания.
//  Данные - ДвоичныеДанные - Данные загружаемого файла.
//
// Возвращаемое значение:
//  Строка - Идентификатор файла.
//
Функция ЗагрузкаФайлаПоАдресу(АдресЗагрузкиФайла, Данные) Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type", "application/octet-stream");
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Таймаут", 600);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Post(
		АдресСервисаРаспознавания() + "/api/v1" + АдресЗагрузкиФайла,
		Данные,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200
	   И Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Принято_202 Тогда 
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка при загрузке файла на сервер.'")
		);
	КонецЕсли;
	
	Возврат РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для отмены загрузки файла по адресу.
//
// Метод предназначен для отмены загрузки в случае, когда клиентское приложение понимает, что запросило слишком много
// слотов для загрузки файлов и в процессе отправки какой-либо из файлов больше отправлять не требуется.
//
// Параметры:
//  АдресЗагрузкиФайла - Строка - Адрес, выданный сервером распознавания для загрузки файла.
//                                Получается с помощью метода См. РаспознаваниеДокументовSDK.ПолучитьСостояниеОбработкиЗадания.
//
Процедура ОтменаЗагрузкиФайлаПоАдресу(АдресЗагрузкиФайла) Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	РаспознаваниеДокументовHTTP.Delete(
		АдресСервисаРаспознавания() + "/api/v1" + АдресЗагрузкиФайла,
		,
		Параметры
	);
	
КонецПроцедуры

// Выполняет запрос к серверу распознавания документов для загрузки файла по выделенному адресу.
//
// Параметры:
//  ИдентификаторФайла - Строка - Идентификатор файла.
//   Получается с помощью метода См. РаспознаваниеДокументовSDK.ЗагрузкаФайлаПоАдресу.
//
// Возвращаемое значение:
// ДвоичныеДанные - Данные исходного файла.
//
Функция ПолучитьИсходныйФайл(ИдентификаторФайла) Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Таймаут", 120);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/ocr/file_info/" + ИдентификаторФайла,
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200  Тогда
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка получения исходного файла.'")
		);
	КонецЕсли;
	
	Возврат РаспознаваниеДокументовHTTP.КакДвоичныеДанные(Ответ);
	
КонецФункции

// Выполняет запрос к серверу распознавания документов для получения свойств распознанного документа.
//
// Параметры:
//  ИдентификаторДокумента - Документ свойства которого необходимо получить.
//    Получается с помощью метода См. РаспознаваниеДокументовSDK.ПолучитьСостояниеОбработкиЗадания.
//
//
// Возвращаемое значение:
//  См. РаспознаваниеДокументовSDK.КакСвойстваРаспознанногоДокумента.
//
Функция ПолучитьСвойстваРаспознанногоДокумента(ИдентификаторДокумента) Экспорт
	
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("X-Auth-Token", РаспознаваниеДокументовSDKПовтИсп.ИдентификаторКлиента());
	
	Параметры = Новый Структура;
	Параметры.Вставить("Заголовки", Заголовки);
	Параметры.Вставить("Таймаут", 120);
	Параметры.Вставить("МаксимальноеКоличествоПовторов", 3);
	
	Ответ = РаспознаваниеДокументовHTTP.Get(
		АдресСервисаРаспознавания() + "/api/v1/ocr/models/" + НомерМодели() + "/result/" + ИдентификаторДокумента + "?only_summary=1&api_version=v2",
		,
		Параметры
	);
	
	ПроверитьКодСостоянияОтвета(Ответ);
	
	Если Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200
	   И Ответ.КодСостояния <> РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Принято_202 Тогда
		
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка получения свойств распознанного документа.'")
		);
	КонецЕсли;
	
	Возврат КакСвойстваРаспознанногоДокумента(Ответ);
	
КонецФункции

// Структура статусов документа.
//
// Возвращаемое значение:
//   Структура
//
Функция СтатусыДокумента() Экспорт
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.СтатусыДокумента();
	
КонецФункции

// Структура типов документа.
//
// Возвращаемое значение:
//   Структура
//
Функция ТипыДокумента() Экспорт
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТипыДокумента();
	
КонецФункции

// Структура классов документа.
//
// Возвращаемое значение:
//   Структура
//
Функция КлассыДокумента() Экспорт
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.КлассыДокумента();
	
КонецФункции

// Структура типов сущностей.
//
// Возвращаемое значение:
//   Структура
//
Функция ТипыСущностей() Экспорт
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТипыСущностей();
	
КонецФункции

// Структура классов сущностей.
//
// Возвращаемое значение:
//   Структура
//
Функция КлассыСущностей() Экспорт
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.КлассыСущностей();
	
КонецФункции

// Структура свойств сущностей.
//
// Возвращаемое значение:
//   Структура
//
Функция СвойстваСущностей() Экспорт
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.СвойстваСущностей();
	
КонецФункции

// Структура подвалов таблиц.
//
// Возвращаемое значение:
//   Структура
//
Функция ПодвалыТаблицы() Экспорт
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ПодвалыТаблицы();
	
КонецФункции

#Область УстаревшиеПроцедурыИФункции

// Выполняет запрос к серверу распознавания документов для проверки нужно ли предлагать ввести промокод.
//
// Возвращаемое значение:
//  Булево
//
Функция ПредлагатьВводПромокодаПриАвторизации() Экспорт
	
	ДопустимыеДействия = ТекущиеДопустимыеДействияПриАвторизации();
	Возврат ДопустимыеДействия.ПоказатьВводПромокода;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область Парсеры

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - Результат HTTP запроса.
//
// Возвращаемое значение:
//  ФиксированнаяСтруктура - где:
//    * АвторизацияТикетИТС - Булево - Является ли текущий пользователь пилотом.
//    * ДатаОкончания - Дата - Дата отключения пилотной программы или последнего пакета баланса.
//    * ТарификацияВключена - Булево - Для пользователя активирована тарификация.
//    * Баланс - Число - Количество оплаченных страниц.
//    * Лимит - Число - Количество страниц, которые еще можно распознать.
//    * ИспользованоСегодня - Число - Количество страниц, распознанных сегодня.
//
Функция КакСостояниеТекущегоБаланса(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("АвторизацияТикетИТС", (ОтветJson["is_its_user"] = Истина));
		Результат.Вставить("ДатаОкончания", ПрочитатьДату(ОтветJson["expiration_date"]));
		Результат.Вставить("ТарификацияВключена", (ОтветJson["billing"] = "enabled"));
		Результат.Вставить("Баланс", ПрочитатьЧисло(ОтветJson["balance"]));
		Результат.Вставить("Лимит", ПрочитатьЧисло(ОтветJson["limit"]));
		Результат.Вставить("ИспользованоСегодня", ПрочитатьЧисло(ОтветJson["used_today"]));
		
		Возврат Новый ФиксированнаяСтруктура(Результат);
		
	Исключение
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			СтрШаблон(
				НСтр("ru = 'Ошибка при чтении состояния текущего баланса:
				           |%1'"),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
			)
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - Результат HTTP запроса.
//
// Возвращаемое значение:
//  ФиксированнаяСтруктура - где:
//    * Баннеры - Массив Из Структура:
//      ** Идентификатор - Строка
//      ** ЗаголовокБаннера - Строка
//      ** ТекстБаннера - Строка
//      ** Картинка - ДвоичныеДанные
//      ** ТолькоДляПолныхПрав - Булево
//      ** ТекстКнопкиПоказатьБаннер - Строка
//    * Страницы - Соответствие:
//      ** Ключ - Строка - Идентификатор
//      ** Значение - Структура:
//         ** Заголовок - Строка
//         ** СтраницаHTML - Строка
//    * ПриЗагрузкеФайла - Структура:
//      ** Страница - См. КакПерсонализированныеПредложения.Страницы.Значение, Неопределено
//      ** ПоведениеСтраницы - Строка - "ПоказатьПриОтправке", "ПоказатьДоЗакрытия", "НеПоказывать"
//
Функция КакПерсонализированныеПредложения(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("Баннеры", Новый Массив);
		Результат.Вставить("Страницы", Новый Соответствие);
		Результат.Вставить("ПриЗагрузкеФайла", Новый Структура);
		Результат.ПриЗагрузкеФайла.Вставить("Страница", Неопределено);
		Результат.ПриЗагрузкеФайла.Вставить("ПоведениеСтраницы", "НеПоказывать");
		
		Для Каждого БаннерыJson из ОтветJson["banners"] Цикл
			Баннер = Новый Структура;
			Баннер.Вставить("Идентификатор", БаннерыJson["id"]);
			Баннер.Вставить("ЗаголовокБаннера", БаннерыJson["banner_title"]);
			Баннер.Вставить("ТекстБаннера", БаннерыJson["banner_text"]);
			Баннер.Вставить("Картинка", ПрочитатьДвоичныеДанныеКартинки(БаннерыJson["banner_image"]));
			Баннер.Вставить("ТолькоДляПолныхПрав", (БаннерыJson["full_access"] = Истина));
			Баннер.Вставить("ТекстКнопкиПоказатьБаннер", БаннерыJson["show_banner_text"]);
			
			Результат.Баннеры.Добавить(Баннер);
		КонецЦикла;
		
		Для Каждого СтраницаJson из ОтветJson["info_pages"] Цикл
			Страница = Новый Структура;
			Страница.Вставить("Заголовок", СтраницаJson.Значение["title"]);
			Страница.Вставить("СтраницаHTML", СтраницаJson.Значение["body"]);
			Результат.Страницы.Вставить("#" + СтраницаJson.Ключ, Страница);
		КонецЦикла;
		
		Если ОтветJson["on_file_upload"] <> Неопределено Тогда
			Страница = Результат.Страницы["#" + ОтветJson["on_file_upload"]["info_page"]];
			Если Страница <> Неопределено Тогда 
				Результат.ПриЗагрузкеФайла.Страница = Страница;
				ПоведениеСтраницыJson = ОтветJson["on_file_upload"]["info_page_behavior"];
				Если ПоведениеСтраницыJson = "show" Тогда
					ПоведениеСтраницы = "ПоказатьПриОтправке";
				ИначеЕсли ПоведениеСтраницыJson = "wait_to_close" Тогда
					ПоведениеСтраницы = "ПоказатьДоЗакрытия";
				Иначе
					ПоведениеСтраницы = "НеПоказывать";
				КонецЕсли;
				Результат.ПриЗагрузкеФайла.ПоведениеСтраницы = ПоведениеСтраницы;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Новый ФиксированнаяСтруктура(Результат);
		
	Исключение
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			СтрШаблон(
				НСтр("ru = 'Ошибка при чтении текущих персонализированных предложений:
				           |%1'"),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
			)
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - Результат HTTP запроса.
//
// Возвращаемое значение:
//  ФиксированнаяСтруктура - где:
//    ** ПоказатьВводПромокода - Булево
//    ** АктивироватьТестовыйПакет - Булево
//
Функция КакДопустимыеДействияПриАвторизации(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("ПоказатьВводПромокода", (ОтветJson["auth_promocode"] = Истина));
		Результат.Вставить("АктивироватьТестовыйПакет", (ОтветJson["activate_test"] = Истина));
		
		Возврат Новый ФиксированнаяСтруктура(Результат);
		
	Исключение
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			СтрШаблон(
				НСтр("ru = 'Ошибка при чтении текущих персонализированных предложений:
				           |%1'"),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
			)
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - Результат HTTP запроса.
//
// Возвращаемое значение:
//  ФиксированнаяСтруктура - где:
//    * Применен - Булево
//    * ТекстПользователю - Строка
//
Функция КакРезультатАктивацииПромокода(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("Применен", (ОтветJson["result"] = "applied"));
		Результат.Вставить("ТекстПользователю", ОтветJson["message"]);
		
		Возврат Новый ФиксированнаяСтруктура(Результат);
		
	Исключение
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			СтрШаблон(
				НСтр("ru = 'Ошибка при чтении текущих персонализированных предложений:
				           |%1'"),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
			)
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - Результат HTTP запроса.
//
// Возвращаемое значение:
//  Структура - где:
//    * ОбработкаЗавершена - Булево - Завершена ли работа с заданием на сервере распознавания.
//    * ДатаСоздания - Дата - Дата отправки задания распознавания на сервер.
//    * АдресаЗагрузкиФайлов - Массив из Строка - Относительные пути для загрузки файлов на сервис
//        для использования в См. РаспознаваниеДокументовSDK.ЗагрузкаФайлаПоАдресу.
//    * ИдентификаторПриложения - Строка = идентификатор приложенения.
//    * ИдентификаторМобильногоПриложения - Строка = идентификатор мобильного приложенения.
//    * РаспознанныеДокументы - Массив из Структура - где:
//      ** ИдентификаторДокумента - Строка - Идентификатор обнаруженного документа в задании распознавания.
//      ** Тип - Строка - Тип формата документа
//      ** ОшибкаРаспознавания - Булево - Документ является ошибкой распознавания.
//      ** ТекстОшибки - Строка - Подробное описание ошибки распознавания.
//      ** ИдентификаторыФайлов - Массив Из Строка - список идентификаторов файлов, объединенных в один документ
//      ** ИменаФайлов - Массив Из Строка - список имен файлов, объединенных в один документ
//      ** Страницы - Массив Из Структура - список страниц всех файлов из которых составлен документ:
//           *** ИдентификаторФайла - Строка - Идентификатор, соответствующий результату загрузки файла.
//           *** ИмяФайла - Строка - Имя обработанного файла.
//           *** НомерСтраницы - Число - Номер страницы обработанного файла.
//
Функция КакСостояниеОбработкиЗадания(Ответ) Экспорт
	
	ОбработкаЗавершена = (Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ОК_200);
	ОшибкаПолученияСостояния =
		(Ответ.КодСостояния >= РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().ВнутренняяОшибкаСервера_500);
	
	Результат = Новый Структура;
	Результат.Вставить("ОбработкаЗавершена", ОбработкаЗавершена);
	Результат.Вставить("ДатаСоздания", Дата("00010101"));
	Результат.Вставить("АдресаЗагрузкиФайлов", Новый Массив);
	Результат.Вставить("ИдентификаторПриложения", "");
	Результат.Вставить("ИдентификаторМобильногоПриложения", "");
	Результат.Вставить("РаспознанныеДокументы", Новый Массив);
	
	Если ОшибкаПолученияСостояния Тогда
		Возврат Результат;
	КонецЕсли;
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		ЗаполнитьСостояниеОбработкиЗадания(Результат, ОтветJson);
		
		Возврат Результат;
		
	Исключение
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			СтрШаблон(
				НСтр("ru = 'Ошибка при чтении состояния обработки задания:
				           |%1'"),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
			)
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  Ответ - Структура - Результат HTTP запроса.
//
// Возвращаемое значение:
//  Структура - где:
//    * Статус - Строка - Статус обработки документа.
//    * Тип - Строка - Тип формата документа
//    * Класс - Строка - Предполагаемый класс документа.
//    * ПредставлениеДокумента - Строка - Представление документа.
//    * ОшибкаРаспознавания - Булево - Документ является ошибкой распознавания.
//    * ТекстОшибки - Строка - Подробное описание ошибки распознавания.
//    * Страницы - Соответствие:
//        ** Ключ - Строка - Имя страницы, например "0", "1"...
//        ** Значение - Структура:
//             *** Картинка - ДвоичныеДанные
//             *** Миниатюра - ДвоичныеДанные
//             *** Высота - Число
//             *** Ширина - Число
//             *** Сущности -  См. РаспознаваниеДокументовSDK.ПрочитатьСущности.
//             *** Печати - Массив Из Структура:
//                 **** Картинка - ДвоичныеДанные - Вырезанная картинка печати.
//                 **** Область - Строка, Неопределено - Координаты области на картинке в которой найдена печать.
//             *** Подписи - Массив Из Структура:
//                 **** Картинка - ДвоичныеДанные - Вырезанная картинка подписи.
//                 **** Область - Строка, Неопределено - Координаты области на картинке в которой найдена подпись.
//
Функция КакСвойстваРаспознанногоДокумента(Ответ) Экспорт
	
	ОтветJson = РаспознаваниеДокументовHTTP.КакJson(Ответ);
	
	Попытка
		
		Результат = Новый Структура;
		Результат.Вставить("Статус", "");
		Результат.Вставить("Тип", "");
		Результат.Вставить("Класс", "");
		Результат.Вставить("ПредставлениеДокумента", "");
		Результат.Вставить("ОшибкаРаспознавания", Истина);
		Результат.Вставить("ТекстОшибки", "");
		Результат.Вставить("Страницы", Новый Соответствие);
		
		ЗаполнитьСвойстваРаспознанногоДокумента(Результат, ОтветJson);
		
		Возврат Результат;
		
	Исключение
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			СтрШаблон(
				НСтр("ru = 'Ошибка при чтении свойств распознанного документа:
				           |%1'"),
				ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())
			)
		);
	КонецПопытки;
	
КонецФункции

// Преобразует ответ сервиса в объект.
//
// Параметры:
//  СущностьJson - Структура - Десериализованное значение прочитанного json фрагмента.
//
// Возвращаемое значение:
//  Соответствие:
//    * Ключ - Уникальный идентификатору сущности в коллекции.
//        Может быть строковым уникальным идентификатором или.именем изаевестного класса.
//    * Значение - См. НоваяСущность.
//
Функция ПрочитатьСущности(СущностиJson) Экспорт
	
	Сущности = Новый Соответствие;
	
	Для Каждого СущностьJson из СущностиJson Цикл
		
		Сущность = ПрочитатьСвойстваСущности(СущностьJson.Ключ, СущностьJson.Значение);
		Сущности.Вставить(Сущность.Ключ, Сущность);
		
	КонецЦикла;
	
	Возврат Сущности;
	
КонецФункции

// Конструктор новой сущности.
//
// Возвращаемое значение:
//  Структура - где:
//    * Ключ - Строка - Ключ сущности, дублирует значение ключа коллекци.
//    * Класс - Строка, Неопределено - Имя одного из классов известных сущностей.
//    * УникальныйИдентификатор - Строка, Неопределено - Уникальный идентификатор х сущности.
//    * Тип - Строка, Неопределено - Имя типа одного из известных типов.
//    * ЭтоТипСоставной - Булево - Истина, если это составной тип. См. поле Свойства.
//    * ЭтоТипИдентификатор - Булево - Истина, если это тип идентификатор. См. поле Значение.
//    * ЭтоТипТекст - Булево - Истина, если это тип текст. См. поле Значение.
//    * ЭтоТипЧисло - Булево - Истина, если это тип числа. См. поле Значение.
//    * ЭтоТипДата - Булево - Истина, если это тип даты. См. поле Значение.
//    * ЭтоТипТаблица - Булево - Истина, если это табличный тип. См поле Таблица.
//    * ЭтотТипСтроковой - Булево - Истина, если это тип хранящий строковые данные. См. поле Значение.
//    * ЭтотТипПримитивный - Булево - Истина, если это примитивный тип. См. поле Значение.
//    * Уверенность - Число, Неопределено - Уверенность найденного значения в промежутке от 0 до 1.
//    * НомерСтраницы - Число, Неопределено - Страница, на которой найдена сущность.
//    * Область - Строка, Неопределено - Координаты области на картинке в которой найдена сущность.
//    * Картинка - ДвоичныеДанные - Вырезанный фрагмент картинки, соответствующий сущности.
//    * КоличествоСтрок - Число - Количество строк изначального фрашмента в обнаруженной сущности.
//    * РаспознанныйТекст - Строка - Текстовое представление распознанного значения.
//    * Значение - Строка, Число, ДатаВремя, Неопределено - Значение для примитивного типа.
//    * Свойства - Соответствие, Неопределено - Свойства составного типа.
//        ** Ключ - Строка - Имя известного свойства
//        ** Значение - Строка - Уникальный идентификатор сущности в которой хранится значение.
//    * Таблица - Структура, Неопределено - Данные табличного типа:
//        ** Колонки - См. РаспознаваниеДокументовSDK.ПрочитатьСущности.
//        ** Строки - Массив Из См. РаспознаваниеДокументовSDK.ПрочитатьСущности.
//        ** Подвалы - Соответствие - Данные табличного типа:
//             *** Ключ - Строка - Имя известного класса футера.
//             *** Значение - Массив Из См. РаспознаваниеДокументовSDK.ПрочитатьСущности.
//
Функция НоваяСущность() Экспорт
	
	Сущность = Новый Структура;
	Сущность.Вставить("Ключ", "");
	Сущность.Вставить("УникальныйИдентификатор", "");
	Сущность.Вставить("Класс", "");
	Сущность.Вставить("Тип", "");
	Сущность.Вставить("ЭтоТипСоставной", Ложь);
	Сущность.Вставить("ЭтоТипИдентификатор", Ложь);
	Сущность.Вставить("ЭтоТипТекст", Ложь);
	Сущность.Вставить("ЭтоТипЧисло", Ложь);
	Сущность.Вставить("ЭтоТипДата", Ложь);
	Сущность.Вставить("ЭтоТипТаблица", Ложь);
	Сущность.Вставить("ЭтотТипСтроковой", Ложь);
	Сущность.Вставить("ЭтотТипПримитивный", Ложь);
	Сущность.Вставить("Уверенность", 0);
	Сущность.Вставить("НомерСтраницы", 0);
	Сущность.Вставить("Область", Неопределено);
	Сущность.Вставить("Картинка", Base64Значение(""));
	Сущность.Вставить("КоличествоСтрок", 0);
	Сущность.Вставить("РаспознанныйТекст", "");
	Сущность.Вставить("Значение", Неопределено);
	Сущность.Вставить("Свойства", Неопределено);
	Сущность.Вставить("Таблица", Неопределено);
	
	Возврат Сущность;
	
КонецФункции

#КонецОбласти

#Область Переопределяемый

// Для быстрой подмены адреса сервиса распознавания.
// Исп. в расширении.
//
// Возвращаемое значение:
//   Строка
//
Функция АдресСервисаРаспознавания() Экспорт
	
	Возврат "https://ocr.1c.ai";
	
КонецФункции

// Для быстрой подмены номера модели распознавания.
// Исп. в расширении.
//
// Возвращаемое значение:
//   Строка
//
Функция НомерМодели() Экспорт
	
	Возврат "5";
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ОбработкаОшибок

Процедура ПроверитьКодСостоянияОтвета(Ответ)
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().НеАвторизован_401 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка авторизации. Скорее всего ключ пользователя устарел.
			         |Попробуйте выйти и авторизоваться с новым идентификатором.'")
		);
	КонецЕсли;
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().НеобходимаОплата_402 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Недостаточно средств для выполнения распознавания.
			         |Пополните баланс.'")
		);
	КонецЕсли;
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Запрещено_403 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru = 'Ошибка доступа. Скорее всего ключ пользователя устарел.
			         |Попробуйте выйти и авторизоваться с новым идентификатором.'")
		);
	КонецЕсли;
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().Заблокировано_423 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Пилотное использование сервиса распознавания документов завершено.
			         |Для продолжения работы, пожалуйста, войдите с помощью учетной записи 1С:ИТС.'")
		);
	КонецЕсли;
	
	Если Ответ.КодСостояния = РаспознаваниеДокументовHTTP.КодыСостоянияHTTP().НевыполненнаяЗависимость_424 Тогда
		ВызватьИсключение РаспознаваниеДокументовHTTP.КакИсключение(Ответ,
			НСтр("ru='Заявка на подключение сервиса распознавания документов отправлена
			         |и будет обработана в ближайшее время.'")
		);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область Парсеры

Процедура ЗаполнитьСостояниеОбработкиЗадания(Результат, ОтветJson)
	
	Результат.ДатаСоздания =  ПрочитатьДату(ОтветJson["info"]["create_time"]);
	Результат.АдресаЗагрузкиФайлов    = ОтветJson["info"]["upload_path"];
	Результат.ИдентификаторПриложения = ОтветJson["client_id"];
	Результат.ИдентификаторМобильногоПриложения = ОтветJson["sub_client_id"];
	
	РезультатСуществует = Ложь;
	
	РезультатJson = ОтветJson.Получить("result");
	Если ЗначениеЗаполнено(РезультатJson) Тогда
		РезультатСуществует = Истина;
	КонецЕсли;
	
	Если РезультатСуществует Тогда
		
		ДокументыJson = РезультатJson["documents"];
		
		Для Каждого ДокументJson Из ДокументыJson Цикл
			
			ИдентификаторДокумента = ДокументJson["id"];
			
			Тип = ТипДокумента(ДокументJson["type"]);
			
			КодОшибки = ДокументJson["error"];
			ОшибкаРаспознавания = ЗначениеЗаполнено(КодОшибки);
			ТекстОшибки = ТекстОшибкиПоКоду(КодОшибки);
			
			РаспознанныйДокумент = Новый Структура;
			РаспознанныйДокумент.Вставить("ИдентификаторДокумента", ИдентификаторДокумента);
			РаспознанныйДокумент.Вставить("Тип", Тип);
			РаспознанныйДокумент.Вставить("ОшибкаРаспознавания", ОшибкаРаспознавания);
			РаспознанныйДокумент.Вставить("ТекстОшибки", ТекстОшибки);
			РаспознанныйДокумент.Вставить("ИдентификаторыФайлов", Новый Массив);
			РаспознанныйДокумент.Вставить("ИменаФайлов", Новый Массив);
			РаспознанныйДокумент.Вставить("Страницы", Новый Массив);
			
			СтраницыJson = ДокументJson["pages_info"];
			Для Каждого СтраницаДокумента Из СтраницыJson Цикл
				
				ИдентификаторФайла = СтраницаДокумента["file_id"];
				ИмяФайла = СтраницаДокумента["file"];
				НомерСтраницы = СтраницаДокумента["page_index"];
				
				Страница = Новый Структура;
				Страница.Вставить("ИдентификаторФайла", ИдентификаторФайла);
				Страница.Вставить("ИмяФайла", ИмяФайла);
				Страница.Вставить("НомерСтраницы", НомерСтраницы);
				
				РаспознанныйДокумент.Страницы.Добавить(Страница);
				
				НеВключенВСписокФайлов = (РаспознанныйДокумент.ИдентификаторыФайлов.Найти(ИдентификаторФайла) = Неопределено);
				Если НеВключенВСписокФайлов Тогда
					РаспознанныйДокумент.ИдентификаторыФайлов.Добавить(ИдентификаторФайла);
					РаспознанныйДокумент.ИменаФайлов.Добавить(ИмяФайла);
				КонецЕсли;
				
			КонецЦикла;
			
			Результат.РаспознанныеДокументы.Добавить(РаспознанныйДокумент);
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьСвойстваРаспознанногоДокумента(Результат, ОтветJson)
	
	Результат.Статус = СтатусДокумента(ОтветJson["status"]);
	Результат.Тип    = ТипДокумента(ОтветJson["result"]["document"]["type"]);
	Результат.Класс  = КлассДокумента(ОтветJson["result"]["document"]["class"]);
	Результат.ПредставлениеДокумента = ОтветJson["result"]["document"]["name"];
	
	КодОшибки = ОтветJson["result"]["document"]["error"];
	Результат.ОшибкаРаспознавания = ЗначениеЗаполнено(КодОшибки);
	Результат.ТекстОшибки         = ТекстОшибкиПоКоду(КодОшибки);
	
	Для Каждого СтраницаJson из ОтветJson["result"]["data"]["pages"] Цикл
		
		Картинка = ПрочитатьДвоичныеДанныеКартинки(СтраницаJson.Значение["page_info"]["image"]);
		Миниатюра = ПрочитатьДвоичныеДанныеКартинки(СтраницаJson.Значение["page_info"]["thumbnail"]);
		Высота = СтраницаJson.Значение["page_info"]["width"];
		Ширина = СтраницаJson.Значение["page_info"]["height"];
		
		СущностиJson = СтраницаJson.Значение["entities"];
		Сущности = ПрочитатьСущности(СущностиJson);
		
		Страница = Новый Структура;
		Страница.Вставить("Картинка", Картинка);
		Страница.Вставить("Миниатюра", Миниатюра);
		Страница.Вставить("Высота", ПрочитатьЧисло(Высота));
		Страница.Вставить("Ширина", ПрочитатьЧисло(Ширина));
		Страница.Вставить("Сущности", Сущности);
		Страница.Вставить("Печати", Новый Массив);
		Страница.Вставить("Подписи", Новый Массив);
		
		СтруктурыJson = СтраницаJson.Значение["structures"];
		Если ЗначениеЗаполнено(СтруктурыJson) Тогда
			ЗаполнитьПечатиПодписи(Страница.Печати, СтруктурыJson["stamps"]);
			ЗаполнитьПечатиПодписи(Страница.Подписи, СтруктурыJson["signatures"]);
		КонецЕсли;
		
		Результат.Страницы.Вставить(СтраницаJson.Ключ, Страница);
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьПечатиПодписи(Список, СписокJson)
	
	Если Не ЗначениеЗаполнено(СписокJson) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ОбъектJson из СписокJson Цикл
		Область = ПрочитатьОбласть(ОбъектJson["bbox"]);
		Картинка = ПрочитатьДвоичныеДанныеКартинки(ОбъектJson["chunk_img"]);
		
		Объект = Новый Структура;
		Объект.Вставить("Область", Область);
		Объект.Вставить("Картинка", Картинка);
		
		Список.Добавить(Объект);
	КонецЦикла;

КонецПроцедуры

Функция ПрочитатьСвойстваСущности(Ключ, СущностьJson)
	
	Сущность = НоваяСущность();
	Сущность.Ключ = Ключ;
	
	Сущность.УникальныйИдентификатор = СущностьJson["uuid"];
	Сущность.Тип = ТипСущности(СущностьJson["type"]);
	Сущность.Класс = КлассСущности(СущностьJson["class"]);
	Сущность.Уверенность = СущностьJson["confidence"];
	Сущность.НомерСтраницы = СущностьJson["page_index"];
	Сущность.Область = ПрочитатьОбласть(СущностьJson["bbox"]);
	Сущность.Картинка = ПрочитатьДвоичныеДанныеКартинки(СущностьJson["chunk_img"]);
	Сущность.КоличествоСтрок = СущностьJson["num_lines"];
	
	Сущность.ЭтоТипСоставной     = (Сущность.Тип = "Составной");
	Сущность.ЭтоТипИдентификатор = (Сущность.Тип = "Идентификатор");
	Сущность.ЭтоТипТекст         = (Сущность.Тип = "Текст");
	Сущность.ЭтоТипЧисло         = (Сущность.Тип = "Число");
	Сущность.ЭтоТипДата          = (Сущность.Тип = "Дата");
	Сущность.ЭтоТипТаблица       = (Сущность.Тип = "Таблица");
	
	Сущность.ЭтотТипСтроковой   = Сущность.ЭтоТипИдентификатор Или Сущность.ЭтоТипТекст;
	Сущность.ЭтотТипПримитивный = Сущность.ЭтоТипИдентификатор Или Сущность.ЭтоТипТекст
	                                  Или Сущность.ЭтоТипЧисло Или Сущность.ЭтоТипДата;
	
	Если Сущность.ЭтотТипПримитивный Тогда
		Возврат ПрочитатьСвойстваСущностиПримитивногоТипа(Сущность, СущностьJson);
	ИначеЕсли Сущность.ЭтоТипСоставной Тогда
		Возврат ПрочитатьСвойстваСущностиСоставногоТипа(Сущность, СущностьJson);
	ИначеЕсли Сущность.ЭтоТипТаблица Тогда
		Возврат ПрочитатьСвойстваСущностиТабличногоТипа(Сущность, СущностьJson);
	Иначе
		Возврат Сущность; // Сущность неопознанного типа
	КонецЕсли;
	
КонецФункции

Функция ПрочитатьСвойстваСущностиПримитивногоТипа(Сущность, СущностьJson)
	
	Значение = СущностьJson["value"];
	
	Если Сущность.ЭтотТипСтроковой Тогда
		Сущность.Значение = Значение;
		Сущность.РаспознанныйТекст = Значение;
	ИначеЕсли Сущность.ЭтоТипЧисло Тогда
		Сущность.Значение = ПрочитатьЧисло(Значение);
		Сущность.РаспознанныйТекст = XMLСтрока(Значение);
	ИначеЕсли Сущность.ЭтоТипДата Тогда
		Сущность.Значение = ПрочитатьДату(Значение);
		Сущность.РаспознанныйТекст = Значение;
	Иначе
		Сущность.Значение = Неопределено;
		Сущность.РаспознанныйТекст = "";
	КонецЕсли;
	
	Возврат Сущность;
	
КонецФункции

Функция ПрочитатьСвойстваСущностиСоставногоТипа(Сущность, СущностьJson)
	
	СвойстваJson = СущностьJson["fields"];
	Сущность.Свойства = Новый Соответствие;
	
	Для Каждого СвойствоJson Из СвойстваJson Цикл
		КлючСвойства = СвойствоСущности(СвойствоJson.Ключ);
		Сущность.Свойства.Вставить(КлючСвойства, СвойствоJson.Значение);
	КонецЦикла;
	
	Возврат Сущность;
	
КонецФункции

Функция ПрочитатьСвойстваСущностиТабличногоТипа(Сущность, СущностьJson)
	
	Сущность.Таблица = Новый Структура;
	Сущность.Таблица.Вставить("Колонки", Неопределено);
	Сущность.Таблица.Вставить("Строки", Новый Массив);
	Сущность.Таблица.Вставить("Подвалы", Новый Соответствие);
	
	КолонкиJson = СущностьJson["header"];
	Сущность.Таблица.Колонки = ПрочитатьКолонкиТаблицы(КолонкиJson);
	
	СтрокиJson = СущностьJson["body"];
	Для Каждого СтрокаJson Из СтрокиJson Цикл
		Строка = ПрочитатьСтрокуТаблицы(СтрокаJson);
		Сущность.Таблица.Строки.Добавить(Строка);
	КонецЦикла;
	
	ПодвалыJson = СущностьJson["footer"];
	Для Каждого ПодвалJson Из ПодвалыJson Цикл
		КлючПодвала = ПодвалТаблицы(ПодвалJson.Ключ);
		СущностиПодвала = ПрочитатьСтрокуТаблицы(ПодвалJson.Значение);
		Сущность.Таблица.Подвалы.Вставить(КлючПодвала, СущностиПодвала);
	КонецЦикла;
	
	Возврат Сущность;
	
КонецФункции

Функция ПрочитатьКолонкиТаблицы(КолонкиJson)
	
	Сущности = Новый Соответствие;
	
	Для Каждого СущностьJson из КолонкиJson Цикл
		
		Сущность = ПрочитатьСвойстваСущности(Неопределено, СущностьJson);
		Сущности.Вставить(Сущность.Класс, Сущность);
		
	КонецЦикла;
	
	Возврат Сущности;
	
КонецФункции

Функция ПрочитатьСтрокуТаблицы(СтрокаJson)
	
	Сущности = Новый Соответствие;
	
	Для Каждого СущностьJson из СтрокаJson Цикл
		
		Сущность = ПрочитатьСвойстваСущности(СущностьJson.Ключ, СущностьJson.Значение);
		Сущности.Вставить(Сущность.Класс, Сущность);
		
	КонецЦикла;
	
	Возврат Сущности;
	
КонецФункции

Функция ПрочитатьОбласть(ОбластьJson)
	
	Если Не ЗначениеЗаполнено(ОбластьJson) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Координаты = Новый Массив;
	
	Для Каждого Координата Из ОбластьJson Цикл
		Координаты.Добавить(XMLСтрока(Координата));
	КонецЦикла;
	
	Возврат СтрСоединить(Координаты, ",");
	
КонецФункции

Функция ПрочитатьДвоичныеДанныеКартинки(Знач СтрокаBase64)
	
	Если ЗначениеЗаполнено(СтрокаBase64) Тогда
		СтрокаBase64 = СтрЗаменить(СтрокаBase64, "data:image/png;base64,", "");
		СтрокаBase64 = СтрЗаменить(СтрокаBase64, "data:image/jpeg;base64,", "");
	Иначе
		СтрокаBase64 = "";
	КонецЕсли;
	
	Возврат Base64Значение(СтрокаBase64);
	
КонецФункции

Функция ПрочитатьЧисло(Значение)
	
	ОписаниеТипа = Новый ОписаниеТипов("Число");
	Возврат ОписаниеТипа.ПривестиЗначение(Значение);
	
КонецФункции

Функция ПрочитатьДату(Значение)
	
	ПустаяДата = Дата("00010101");
	Попытка
		Если Не ЗначениеЗаполнено(Значение) Тогда
			Дата = ПустаяДата;
		Иначе
			Дата = ПрочитатьДатуJSON(Значение, ФорматДатыJSON.ISO);
			Если Год(Дата) > 3999 Тогда
				Дата = ПустаяДата;
			КонецЕсли;
		КонецЕсли;
		Возврат Дата;
	Исключение
		Возврат ПустаяДата;
	КонецПопытки;
	
КонецФункции

#КонецОбласти

#Область ПовтИсп

Функция ТекстОшибкиПоКоду(КодОшибки)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТекстОшибкиПоКоду(КодОшибки);
	
КонецФункции

Функция СтатусДокумента(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.СтатусДокумента(Ключ);
	
КонецФункции

Функция ТипДокумента(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТипДокумента(Ключ);
	
КонецФункции

Функция КлассДокумента(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.КлассДокумента(Ключ);
	
КонецФункции

Функция ТипСущности(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ТипСущности(Ключ);
	
КонецФункции

Функция КлассСущности(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.КлассСущности(Ключ);
	
КонецФункции

Функция СвойствоСущности(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.СвойствоСущности(Ключ);
	
КонецФункции

Функция ПодвалТаблицы(Ключ)
	
	Возврат РаспознаваниеДокументовSDKПовтИсп.ПодвалТаблицы(Ключ);
	
КонецФункции

#КонецОбласти

#КонецОбласти
