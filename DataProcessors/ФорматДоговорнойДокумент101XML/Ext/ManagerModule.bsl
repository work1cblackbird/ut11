#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда

#Область ПрограммныйИнтерфейс

// Создает пустую таблицу фрагментов для заполнения.
//
// Возвращаемое значение:
//  ТаблицаЗначений:
//   * ТиповойФрагмент - Булево - является фрагмент типовым
//   * ОписаниеТиповогоЭлемента - Строка - описание типового элемента для представления при редактировании
//   * ПорядковыйНомер - Число - номер фрагмента
//   * СсылкаНаНомерФрагмента - Число - номер фрагмента, с которым связан данный фрагмент
//   * ЦифровойКодТиповогоНаименования - Строка - код типового элемента
//   * БуквенныйКодТиповогоНаименования - Строка - имя типового элемента
//   * Выравнивание - Строка - вариант выравнивания фрагмента
//   * СодержаниеФрагмента - Строка - текстовое содержание фрагмента
//   * ИностранноеСодержаниеФрагмента - Строка - текстовое содержание фрагмента на иностранном языке
//   * ВизуализацияТекста - Массив Из Строка - коды визуализации для текста
//   * ВизуализацияСодержанияТаблиц - Массив Из Строка - коды визуализации для таблицы
//   * СтильФрагмента - Соответствие из КлючИЗначение - результат подключения компоненты:
	//   ** Ключ - Строка - имя атрибута стиля:
	//        # name - имя стиля.
	//        # font_family - имя шрифта.
	//        # font_weight - жирность шрифта.
	//        # font_style - стиль шрифта.
	//        # сolor - цвет шрифта.
	//        # font_size - размер шрифта.
	//   ** Значение - Строка - значение атрибута стиля.
//   * Параметр - Строка - имя параметра в макете
//   * Связан - Строка - имя типового элемента, с которым связан данный фрагмент
//   * Родитель - Строка - имя параметра макета, который является родителем данного фрагмента.
//
Функция НоваяТаблицаФрагментов() Экспорт
	
	МассивТиповСтиль = Новый Массив();
	МассивТиповСтиль.Добавить(Тип("Соответствие"));
	
	МассивТиповВизуализации = Новый Массив();
	МассивТиповВизуализации.Добавить(Тип("Массив"));
	
	ТаблицаФрагментов = Новый ТаблицаЗначений;
	ТаблицаФрагментов.Колонки.Добавить("ТиповойФрагмент", Новый ОписаниеТипов("Булево"));
	ТаблицаФрагментов.Колонки.Добавить("ОписаниеТиповогоЭлемента", ОбщегоНазначения.ОписаниеТипаСтрока(0));
	
	ТаблицаФрагментов.Колонки.Добавить("ПорядковыйНомер", ОбщегоНазначения.ОписаниеТипаЧисло(15)); //НомерФрагмента
	ТаблицаФрагментов.Колонки.Добавить("СсылкаНаНомерФрагмента", ОбщегоНазначения.ОписаниеТипаЧисло(6)); //СсылБлок
	ТаблицаФрагментов.Колонки.Добавить("ЦифровойКодТиповогоНаименования", ОбщегоНазначения.ОписаниеТипаСтрока(10)); //ЦифКЭлПер
	ТаблицаФрагментов.Колонки.Добавить("БуквенныйКодТиповогоНаименования", ОбщегоНазначения.ОписаниеТипаСтрока(255)); //БукКЭлПер
	ТаблицаФрагментов.Колонки.Добавить("Выравнивание", ОбщегоНазначения.ОписаниеТипаСтрока(2)); //МакетВыравн
	ТаблицаФрагментов.Колонки.Добавить("СодержаниеФрагмента", ОбщегоНазначения.ОписаниеТипаСтрока(0)); //СодержФраг
	ТаблицаФрагментов.Колонки.Добавить("ИностранноеСодержаниеФрагмента", ОбщегоНазначения.ОписаниеТипаСтрока(0)); //СодержФрагИн
	ТаблицаФрагментов.Колонки.Добавить("ВизуализацияТекста", Новый ОписаниеТипов(МассивТиповВизуализации)); //МакетФрагТекст
	ТаблицаФрагментов.Колонки.Добавить("ВизуализацияСодержанияТаблиц", Новый ОписаниеТипов(МассивТиповВизуализации)); //МакетФрагТаб
	ТаблицаФрагментов.Колонки.Добавить("СтильФрагмента", Новый ОписаниеТипов(МассивТиповСтиль)); //СтильФрагТекст
	
	ТаблицаФрагментов.Колонки.Добавить("Параметр",        ОбщегоНазначения.ОписаниеТипаСтрока(0));
	ТаблицаФрагментов.Колонки.Добавить("Связан",          ОбщегоНазначения.ОписаниеТипаСтрока(0));
	ТаблицаФрагментов.Колонки.Добавить("Родитель",        ОбщегоНазначения.ОписаниеТипаСтрока(0));
	
	Возврат ТаблицаФрагментов;
	
КонецФункции

#Область ПреобразованиеМакетаВТаблицуФрагментов

// Создает таблицу фрагментов в фоновом задании.
//
// Параметры:
// 	ПараметрыФоновойПечати - Структура:
// 	* ИмяМакета - Строка - имя макета (необязательный).
//  * ОбъектыПечати - Массив Из СправочникСсылка.ДоговорыКонтрагентов - договоры для печати.
//
// Возвращаемое значение:
// 	Структура:
// 	* ТаблицаФрагментов - см. НоваяТаблицаФрагментов.
//  * Ошибки - см. ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.Ошибки.
//  * Предупреждения - см. ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.Ошибки.
//
Функция СоздатьXMLВФоне(ПараметрыФоновойПечати) Экспорт
	
	РезультатФормирования = Новый Структура();
	РезультатФормирования.Вставить("ТаблицаФрагментов", НоваяТаблицаФрагментов());
	РезультатФормирования.Вставить("Ошибки", Неопределено);
	РезультатФормирования.Вставить("Предупреждения", Неопределено);
	
	КодЯзыка = ОбщегоНазначения.КодОсновногоЯзыка();
	ИмяМакета = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(ПараметрыФоновойПечати, "ИмяМакета");
	
	Если ЗначениеЗаполнено(ИмяМакета) Тогда
			
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени("Справочник.МакетыПечатныхФорм");
		Макет = МенеджерОбъекта.НайтиМакет(ИмяМакета, КодЯзыка);
		ОбъектыПечати = ПараметрыФоновойПечати.ОбъектыПечати;
		
		Ошибки = Неопределено;
		Предупреждения = Неопределено;
		
		Если ТипЗнч(Макет) = Тип("ДвоичныеДанные") Тогда
			ТаблицаФрагментов = ЗаполнитьТаблицуФрагментовПоДокументуOfficeOpenXML(Макет, ОбъектыПечати, КодЯзыка, Ошибки, Предупреждения);
		Иначе
			ТаблицаФрагментов = ЗаполнитьТаблицуФрагментов(Макет, ОбъектыПечати, КодЯзыка, Ошибки, Предупреждения);
		КонецЕсли;
		
		РезультатФормирования.Вставить("ТаблицаФрагментов", ТаблицаФрагментов);
		РезультатФормирования.Вставить("Ошибки", Ошибки);
		РезультатФормирования.Вставить("Предупреждения", Предупреждения);
		
	КонецЕсли;
	
	Возврат РезультатФормирования;
	
КонецФункции 

#КонецОбласти

// Формирует XML структуру договора по указанному договору и таблице заполненных фрагментов.
//
// Параметры:
//   Договор - СправочникСсылка.ДоговорыКонтрагентов
//   ТаблицаФрагментов - см. НоваяТаблицаФрагментов
//   ИмяФайлаВыгрузки - Строка - Имя файла для формируемого XML для БЭД.
//   Ошибки - см. ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.Ошибки.
//
// Возвращаемое значение:
//   ОбъектXDTO
//
Функция СформироватьXMLПоДоговору(Договор, ТаблицаФрагментов, ИмяФайлаВыгрузки, Ошибки) Экспорт
	
	РеквизитыДоговора = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Договор, "Номер, Дата, Организация, Контрагент");
	НомерДог = РеквизитыДоговора.Номер;
	ДатаДог = РеквизитыДоговора.Дата;
	ОрганизацияДоговора = РеквизитыДоговора.Организация;
	КонтрагентДоговора = РеквизитыДоговора.Контрагент;
	ОшибкиЭД = Новый Массив();
	
	Если Не ЗначениеЗаполнено(НомерДог) Тогда
		НомерДог = НСтр("ru = 'без номера (б/н)'");	
	КонецЕсли;
	Если Не ЗначениеЗаполнено(ДатаДог) Тогда
		ТекстСообщения = НСтр("ru = 'Не заполнена дата договора.'");
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
		Возврат Неопределено;
	КонецЕсли;
	Если ЗначениеЗаполнено(ОрганизацияДоговора) Тогда
		РеквизитыОрганизации = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(ОрганизацияДоговора, "ИНН, ЮрФизЛицо");
	Иначе
		ТекстСообщения = НСтр("ru = 'Не заполнена организация в договоре.'");
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
		Возврат Неопределено;
	КонецЕсли;
	Если ЗначениеЗаполнено(КонтрагентДоговора) Тогда
		РеквизитыКонтрагента = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(КонтрагентДоговора, "ИНН, ЮрФизЛицо");
	Иначе
		ТекстСообщения = НСтр("ru = 'Не заполнен контрагент в договоре.'");
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
		Возврат Неопределено;
	КонецЕсли;
	
	ПространствоИмен = Обработки.ФорматДоговорныйДокументИнформацияОтправителяЭДО.ПространствоИмен();
	
	ТипФайла = СтрШаблон("{%1}.Файл", ПространствоИмен);
	ТипСодержания = СтрШаблон("{%1}.Файл.Содержание", ПространствоИмен);
	ТипТиповогоФрагмента = СтрШаблон("{%1}.Файл.Содержание.ФрагТиповой", ПространствоИмен);
	ТипСтиляТиповогоФрагмента = СтрШаблон("{%1}.Файл.Содержание.ФрагТиповой.СтильФрагТекст", ПространствоИмен);
	ТипПроизвольногоФрагмента = СтрШаблон("{%1}.Файл.Содержание.ФрагПроизв", ПространствоИмен);
	ТипСтиляПроизвольногоФрагмента = СтрШаблон("{%1}.Файл.Содержание.ФрагПроизв.СтильФрагТекст", ПространствоИмен);
	
	ВерсияПрограммы =ВРЕГ(Лев(СтрШаблон("%1 %2", Метаданные.Имя, СокрЛП(Метаданные.Версия)), 40));
	
	Файл = РаботаСФайламиБЭД.ПолучитьОбъектТипаCML(ТипФайла, ПространствоИмен);
	
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Файл, "ИдФайл", ИмяФайлаВыгрузки, Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Файл, "ВерсФорм", "1.01", Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Файл, "ВерсПрог", ВерсияПрограммы, Ложь, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Файл, "ВерсПеречня", "1.01", Ложь, ОшибкиЭД);

	Содержание = РаботаСФайламиБЭД.ПолучитьОбъектТипаCML(ТипСодержания, ПространствоИмен);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "КНД", "1175016", Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "НаимДок", "Договор", Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "НомДок", НомерДог, Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ДатаДок", Формат(ДатаДог,"ДЛФ=D"), Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ДатаИнфСодСд", Формат(ТекущаяДатаСеанса(),"ДЛФ=D"), Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ВремИнфСодСд", Формат(ТекущаяДатаСеанса(),"ДФ=ЧЧ.мм.сс"), Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ПризнИн", "0", Истина, ОшибкиЭД);
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ПорФормДок", "0", Истина, ОшибкиЭД);
	
	Если ЗначениеЗаполнено(ОрганизацияДоговора) Тогда
		Если ЗначениеЗаполнено(РеквизитыОрганизации.ИНН) Тогда
			Если РеквизитыОрганизации.ЮрФизЛицо = Перечисления.ЮрФизЛицо.ЮрЛицо Тогда
				РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ИННЮЛСт1", РеквизитыОрганизации.ИНН, Истина, ОшибкиЭД);
			Иначе 
				РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ИННФЛСт1", РеквизитыОрганизации.ИНН, Истина, ОшибкиЭД);
			КонецЕсли;
		Иначе
			ТекстСообщения = НСтр("ru = 'Не заполнен ИНН организации.'");
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		ТекстСообщения = НСтр("ru = 'Не заполнена организация.'");
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
		Возврат Неопределено;
	КонецЕсли;

	Если ЗначениеЗаполнено(КонтрагентДоговора) Тогда
		Если ЗначениеЗаполнено(РеквизитыКонтрагента.ИНН) Тогда
			Если РеквизитыКонтрагента.ЮрФизЛицо = Перечисления.ЮрФизЛицо.ЮрЛицо Тогда
				РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ИННЮЛСт2", РеквизитыКонтрагента.ИНН, Истина, ОшибкиЭД);
			Иначе 
				РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Содержание, "ИННФЛСт2", РеквизитыКонтрагента.ИНН, Истина, ОшибкиЭД);
			КонецЕсли;
		Иначе
			ТекстСообщения = НСтр("ru = 'Не заполнен ИНН контрагента.'");
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		ТекстСообщения = НСтр("ru = 'Не заполнен контрагент.'");
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
		Возврат Неопределено;
	КонецЕсли;
	
	// Выгрузка в XML
	Для Каждого СтрокаФрагмента Из ТаблицаФрагментов Цикл
		Если СтрокаФрагмента.ТиповойФрагмент Тогда
			Фрагмент = РаботаСФайламиБЭД.ПолучитьОбъектТипаCML(ТипТиповогоФрагмента, ПространствоИмен); 
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "НомФраг", XMLСтрока(СтрокаФрагмента.ПорядковыйНомер), Истина, ОшибкиЭД);
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "ЦифКЭлПер", СтрокаФрагмента.ЦифровойКодТиповогоНаименования, Истина, ОшибкиЭД);
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "БукКЭлПер", СтрокаФрагмента.БуквенныйКодТиповогоНаименования, Ложь, ОшибкиЭД);
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "СодержФраг", СтрокаФрагмента.СодержаниеФрагмента, Истина, ОшибкиЭД);
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "МакетВыравн", СтрокаФрагмента.Выравнивание, Истина, ОшибкиЭД);
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "СсылБлок", XMLСтрока(СтрокаФрагмента.СсылкаНаНомерФрагмента), Истина, ОшибкиЭД);
			Стиль = РаботаСФайламиБЭД.ПолучитьОбъектТипаCML(ТипСтиляТиповогоФрагмента, ПространствоИмен);
		Иначе
			Фрагмент = РаботаСФайламиБЭД.ПолучитьОбъектТипаCML(ТипПроизвольногоФрагмента, ПространствоИмен);
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "НомФраг", XMLСтрока(СтрокаФрагмента.ПорядковыйНомер), Истина, ОшибкиЭД);
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "МакетВыравн", СтрокаФрагмента.Выравнивание, Истина, ОшибкиЭД);
			РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "СодержФраг", СтрокаФрагмента.СодержаниеФрагмента, Истина, ОшибкиЭД);
			Стиль = РаботаСФайламиБЭД.ПолучитьОбъектТипаCML(ТипСтиляПроизвольногоФрагмента, ПространствоИмен);
		КонецЕсли;
		
		Для Каждого ЭлементВизуализации Из СтрокаФрагмента.ВизуализацияТекста Цикл
			ДобавитьОписаниеФрагмента(Фрагмент.МакетФрагТекст, Строка(ЭлементВизуализации));
		КонецЦикла;
		
		СтильФрагТекст = СтрокаФрагмента.СтильФрагмента;
		РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Стиль, "font_family", Строка(СтильФрагТекст.Получить("font_family")), Истина, ОшибкиЭД);
		РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Стиль, "font_weight", Строка(СтильФрагТекст.Получить("font_weight")), Истина, ОшибкиЭД);
		РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Стиль, "font_style", СтильФрагТекст.Получить("font_style"), Истина, ОшибкиЭД);
		РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Стиль, "сolor", СтильФрагТекст.Получить("сolor"), Истина, ОшибкиЭД);
		РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Стиль, "font_size", СтильФрагТекст.Получить("font_size"), Истина, ОшибкиЭД);
		РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Фрагмент, "СтильФрагТекст", Стиль, Истина, ОшибкиЭД);
		
		Если СтрокаФрагмента.ТиповойФрагмент Тогда
			ДобавитьОписаниеФрагмента(Содержание.ФрагТиповой, Фрагмент);
		Иначе
			ДобавитьОписаниеФрагмента(Содержание.ФрагПроизв, Фрагмент);
		КонецЕсли;
	КонецЦикла;
	
	РаботаСФайламиБЭД.ЗаполнитьСвойствоXDTO(Файл, "Содержание", Содержание, Истина, ОшибкиЭД);
	
	Файл.Проверить();
	
	ДвоичныеДанные = РаботаСФайламиБЭД.XDTOВДвоичныеДанные(Файл,,, "Файл");
	ДвоичныеДанные = УдалитьПространствоИмен(ДвоичныеДанные, ПространствоИмен);
	
	Для Каждого ОшибкаЭД Из ОшибкиЭД Цикл
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ОшибкаЭД.ТекстОшибки, "");
	КонецЦикла;
	
	Возврат ДвоичныеДанные;
	
КонецФункции

// Заполнение "СсылБлок" для типовых фрагментов.
//
// Параметры:
//   ТаблицаФрагментов - см. НоваяТаблицаФрагментов.
//
Процедура ЗаполнитьСсылкуНаНомерФрагмента(ТаблицаФрагментов) Экспорт
	
	Для Каждого СтрокаФрагмента Из ТаблицаФрагментов Цикл
		НайденИсходныйФрагмент = Ложь;
		Если ЗначениеЗаполнено(СтрокаФрагмента.Родитель) Тогда
			ИсходныйФрагмент = ТаблицаФрагментов.Найти(СтрокаФрагмента.Родитель, "Параметр");
			Если ИсходныйФрагмент <> Неопределено Тогда
				НайденИсходныйФрагмент = Истина;
				СтрокаФрагмента.СсылкаНаНомерФрагмента = ИсходныйФрагмент.ПорядковыйНомер;
			КонецЕсли;
		КонецЕсли;
			
		Если Не НайденИсходныйФрагмент И ЗначениеЗаполнено(СтрокаФрагмента.Связан) Тогда
			ИсходныйФрагмент = ТаблицаФрагментов.Найти(СтрокаФрагмента.Связан, "БуквенныйКодТиповогоНаименования");
			Если ИсходныйФрагмент <> Неопределено Тогда
				СтрокаФрагмента.СсылкаНаНомерФрагмента = ИсходныйФрагмент.ПорядковыйНомер;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Формирует таблицу фрагментов из файла XML.
//
// Параметры:
// 	ДанныеФайла - ДвоичныеДанные - данные фала XML.
//
// Возвращаемое значение:
// 	см. НоваяТаблицаФрагментов
//
Функция ЗагрузкаXMLВТаблицуФрагментов(ДанныеФайла) Экспорт
	
	Попытка
		ДанныеФайлаЭД = ПолучитьДанныеФайлаXDTO(ДанныеФайла);
		ТаблицаТиповыхНаименований = ПереченьТиповыхНаименованийЭлементовДоговоров();
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
	Если ДанныеФайлаЭД = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ТаблицаФрагментов = НоваяТаблицаФрагментов();
	
	СодержаниеДокумента = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(ДанныеФайлаЭД, "Содержание");
	
	ТиповыеФрагменты = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(СодержаниеДокумента, "ФрагТиповой", , , Истина);
	
	Если ТиповыеФрагменты <> Неопределено Тогда
		
		Для Каждого Фрагмент Из ТиповыеФрагменты Цикл
			
			НоваяСтрока = ТаблицаФрагментов.Добавить();
			
			НоваяСтрока.ТиповойФрагмент = Истина;
			НоваяСтрока.ПорядковыйНомер = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "НомФраг");
			НоваяСтрока.СсылкаНаНомерФрагмента = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "СсылБлок");
			НоваяСтрока.ЦифровойКодТиповогоНаименования = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "ЦифКЭлПер");
			НоваяСтрока.БуквенныйКодТиповогоНаименования = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "БукКЭлПер");
			НоваяСтрока.Выравнивание = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "МакетВыравн");
			НоваяСтрока.СодержаниеФрагмента = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "СодержФраг");
			НоваяСтрока.ИностранноеСодержаниеФрагмента = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "СодержФрагИн");
			ВизуализацияТекста = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "МакетФрагТекст", , , Истина);
			ЗаполнитьДанныеВизуализацииИзXML(НоваяСтрока.ВизуализацияТекста, ВизуализацияТекста);
			ВизуализацияСодержанияТаблиц = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "МакетФрагТаб", , , Истина);
			ЗаполнитьДанныеВизуализацииИзXML(НоваяСтрока.ВизуализацияСодержанияТаблиц, ВизуализацияСодержанияТаблиц);
			СтильОбъекта = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "СтильФрагТекст");
			ЗаполнитьСтильОбъектаИзXML(НоваяСтрока.СтильФрагмента, СтильОбъекта);
			СтрокаТиповогоЭлемента = ТаблицаТиповыхНаименований.Найти(НоваяСтрока.БуквенныйКодТиповогоНаименования, "Наименование");
			Если СтрокаТиповогоЭлемента <> Неопределено Тогда
				НоваяСтрока.ОписаниеТиповогоЭлемента = СтрШаблон("%1 (%2)", СтрокаТиповогоЭлемента.Описание, СтрокаТиповогоЭлемента.Наименование);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	ПроизвольныеФрагменты = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(СодержаниеДокумента, "ФрагПроизв", , , Истина);
	
	Если ПроизвольныеФрагменты <> Неопределено Тогда
		
		Для Каждого Фрагмент Из ПроизвольныеФрагменты Цикл
			
			НоваяСтрока = ТаблицаФрагментов.Добавить();
			
			НоваяСтрока.ПорядковыйНомер = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "НомФраг");
			НоваяСтрока.СсылкаНаНомерФрагмента = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "СсылБлок");
			НоваяСтрока.Выравнивание = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "МакетВыравн");
			НоваяСтрока.СодержаниеФрагмента = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "СодержФраг");
			НоваяСтрока.ИностранноеСодержаниеФрагмента = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "СодержФрагИн");
			ВизуализацияТекста = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "МакетФрагТекст", , , Истина);
			ЗаполнитьДанныеВизуализацииИзXML(НоваяСтрока.ВизуализацияТекста, ВизуализацияТекста);
			ВизуализацияСодержанияТаблиц = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "МакетФрагТаб", , , Истина);
			ЗаполнитьДанныеВизуализацииИзXML(НоваяСтрока.ВизуализацияСодержанияТаблиц, ВизуализацияСодержанияТаблиц);
			СтильОбъекта = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(Фрагмент, "СтильФрагТекст");
			ЗаполнитьСтильОбъектаИзXML(НоваяСтрока.СтильФрагмента, СтильОбъекта);
		КонецЦикла;
		
	КонецЕсли;
	
	ТаблицаФрагментов.Сортировать("ПорядковыйНомер");
	
	Возврат ТаблицаФрагментов;
	
КонецФункции

// Проверяет таблицу фрагментов.
//
// Параметры:
// 	ТаблицаФрагментов - см. НоваяТаблицаФрагментов.
//
// Возвращаемое значение:
// 	см. ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю.Ошибки.
//
Функция ПроверитьЗаполненностьТиповыхФрагментов(ТаблицаФрагментов) Экспорт
	
	Ошибки = Неопределено;
	
	Если ТаблицаФрагментов = Неопределено Тогда
		ТекстСообщения = НСтр("ru = 'Не удалось прочитать файл.'");
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
		Возврат Ошибки;
	КонецЕсли;
		
	ОтборТиповыхФрагментов = Новый Структура();
	ОтборТиповыхФрагментов.Вставить("ТиповойФрагмент", Истина);
	ТиповыеФрагменты = ТаблицаФрагментов.НайтиСтроки(ОтборТиповыхФрагментов);
	
	Для Каждого ТиповойФрагмент Из ТиповыеФрагменты Цикл
		Если Не ЗначениеЗаполнено(ТиповойФрагмент.СодержаниеФрагмента) Тогда
			ТекстСообщения = СтрШаблон(НСтр("ru = 'Не заполнен типовой фрагмент %1'"), ТиповойФрагмент.БуквенныйКодТиповогоНаименования);
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти("ТаблицаРеквизитов",
															ТиповойФрагмент.ПорядковыйНомер,
															"СодержаниеФрагмента");
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, Поле, ТекстСообщения, "");
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ТиповойФрагмент.ПорядковыйНомер) Тогда
			ТекстСообщения = СтрШаблон(НСтр("ru = 'Не заполнен порядковый номер типового фрагмента %1'"), ТиповойФрагмент.БуквенныйКодТиповогоНаименования);
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти("ТаблицаРеквизитов",
															ТиповойФрагмент.ПорядковыйНомер,
															"ПорядковыйНомер");
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, Поле, ТекстСообщения, "");
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ТиповойФрагмент.ЦифровойКодТиповогоНаименования) Тогда
			ТекстСообщения = СтрШаблон(НСтр("ru = 'Не заполнен цифровой код типового фрагмента %1'"), ТиповойФрагмент.БуквенныйКодТиповогоНаименования);
			Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти("ТаблицаРеквизитов",
															ТиповойФрагмент.ПорядковыйНомер,
															"ЦифровойКодТиповогоНаименования");
			ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, Поле, ТекстСообщения, "");
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Ошибки;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ПреобразованиеMXL

Функция ЗаполнитьТаблицуФрагментов(Макет, МассивОбъектов, КодЯзыка, Ошибки, Предупреждения)
	
	ТаблицаФрагментов = НоваяТаблицаФрагментов();
	ТаблицаСоответствий = ТаблицаСоответствийПараметровИТиповыхНаименований();
	ТаблицаТиповыхНаименований = ПереченьТиповыхНаименованийЭлементовДоговоров();
	
	НомФрагмента = 1;
	
	ПоляМакета = ПоляМакета(Макет);
	
	ДанныеПечати = УправлениеПечатью.ДанныеПечати(МассивОбъектов, ПоляМакета, КодЯзыка);
	ПараметрыИспользования = УправлениеПечатью.ДанныеПечати(МассивОбъектов, ТаблицаСоответствий.ВыгрузитьКолонку("Использование"), КодЯзыка);
	
	НастройкиФорматаПолей = ДанныеПечати["НастройкиФорматаПолей"];
	
	ОбластиМакета = ОбластиМакета(Макет, ДанныеПечати);
	
	Для Каждого Ссылка Из МассивОбъектов Цикл
		
		ПараметрыПолученияДанных = Новый Структура();
		ПараметрыПолученияДанных.Вставить("ТаблицаСоответствий", ТаблицаСоответствий);
		ПараметрыПолученияДанных.Вставить("ТаблицаКодов", ТаблицаТиповыхНаименований);
		ПараметрыПолученияДанных.Вставить("ПараметрыИспользования", ПараметрыИспользования[Ссылка]);
		ПараметрыПолученияДанных.Вставить("КодЯзыка", КодЯзыка);
	
		Для Каждого Элемент Из ОбластиМакета.ВсеОбласти Цикл
			ИмяОбласти = Элемент.Значение;
			УсловиеВывода = Элемент.Представление;
			КоличествоПовторений = 1;
			
			ИмяТаблицы = ОбластиМакета.ОбластиТаблиц[ИмяОбласти];
			Если ЗначениеЗаполнено(ИмяТаблицы) Тогда
				КоличествоПовторений = ДанныеПечати[Ссылка][ИмяТаблицы].Количество();
			КонецЕсли;
			
			Для НомерСтрокиТабличнойЧасти = 1 По КоличествоПовторений Цикл
				ОбластьМакета = Макет.ПолучитьОбласть(ИмяОбласти);
			
				ИсточникДанных = Новый Соответствие;
				ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(ИсточникДанных, ДанныеПечати[Ссылка]);
				Если ЗначениеЗаполнено(ИмяТаблицы) Тогда
					ДанныеСтрокиТабличнойЧасти = ДанныеПечати[Ссылка][ИмяТаблицы][НомерСтрокиТабличнойЧасти];
					Для Каждого КлючИЗначение Из ДанныеСтрокиТабличнойЧасти Цикл
						ИсточникДанных[СтрШаблон("%1.%2", ИмяТаблицы, КлючИЗначение.Ключ)] = КлючИЗначение.Значение;
					КонецЦикла;
				КонецЕсли;
				
				Если ЗначениеЗаполнено(УсловиеВывода) Тогда
					ВыводитьОбласть = ВычислитьВыражение(СтрШаблон("[%1]", УсловиеВывода), ИсточникДанных, НастройкиФорматаПолей, КодЯзыка);
					Если ТипЗнч(ВыводитьОбласть) <> Тип("Булево") Или Не ВыводитьОбласть Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				
				ОбработанныеЯчейки = Новый Соответствие;
				Для НомерСтроки = 1 По ОбластьМакета.ВысотаТаблицы Цикл
					ЕстьТекст = Ложь;
					Для НомерСтолбца = 1 По ОбластьМакета.ШиринаТаблицы Цикл
						ОбластьЯчейки = ОбластьМакета.Область(НомерСтроки, НомерСтолбца, НомерСтроки, НомерСтолбца);
						
						ИдентификаторОбласти = УправлениеПечатью.ИдентификаторОбласти(ОбластьЯчейки);
						Если ОбработанныеЯчейки[ИдентификаторОбласти] <> Неопределено Тогда
							Продолжить;
						КонецЕсли;
						ОбработанныеЯчейки[ИдентификаторОбласти] = Истина;
						
						Если Не ЗначениеЗаполнено(ОбластьЯчейки.Текст) Тогда
							Если ЕстьТекст Или НомерСтолбца < ОбластьМакета.ШиринаТаблицы Тогда
								Продолжить;
							КонецЕсли;
						КонецЕсли;
			
						ЕстьТекст = Истина;
						МакетФрагТекст = "2";
						
						МакетВыравнивание = ПолучитьЗначениеВыравниванияОбласти(ОбластьЯчейки);
						СтильФрагТекст = НовыйЭлементСтиля(ОбластьЯчейки.Шрифт, ОбластьЯчейки.ЦветТекста);
						
						Если Не ЗначениеЗаполнено(ОбластьЯчейки.Текст) Тогда
							
							НовыйФрагмент = ТаблицаФрагментов.Добавить();
							НовыйФрагмент.СодержаниеФрагмента = Символы.НПП;
							НовыйФрагмент.СтильФрагмента = СтильФрагТекст;
							НовыйФрагмент.ТиповойФрагмент = Ложь;
							НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
							НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
							НовыйФрагмент.Выравнивание = МакетВыравнивание;
							НомФрагмента = НомФрагмента + 1;
							
							Продолжить;
							
						КонецЕсли;
						
						Строка = Строка(ОбластьЯчейки.Текст);
						
						ПараметрыТекста = УправлениеПечатью.НайтиПараметрыВТексте(Строка(Строка));
						ЗначенияПараметров = ЗначенияПараметров(ПараметрыТекста, ИсточникДанных, НастройкиФорматаПолей, КодЯзыка);
						НомерПозиции = 1;
						
						Пока НомерПозиции < СтрДлина(Строка) Цикл
							
							ТиповойФрагмент = Ложь;
							
							Если Лев(Строка, НомерПозиции) <> "[" Тогда //Текст - заполняем произвольный блок
								
									НомерПозиции = СтрНайти(Строка, "[");
									Если НомерПозиции = 0 Тогда //В строке нет параметров, записываем всю строку
										СодержаниеФрагмента = Строка;
										НомерПозиции = СтрДлина(Строка);
									Иначе
										СодержаниеФрагмента = Лев(Строка, НомерПозиции-1);
									КонецЕсли;
									
									НовыйФрагмент = ТаблицаФрагментов.Добавить();
									НовыйФрагмент.СодержаниеФрагмента  = СодержаниеФрагмента;
									НовыйФрагмент.СтильФрагмента = СтильФрагТекст;
									НовыйФрагмент.ТиповойФрагмент = ТиповойФрагмент;
									НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
									НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
									НовыйФрагмент.Выравнивание = МакетВыравнивание;
									
									Строка = Прав(Строка, СтрДлина(Строка) - НомерПозиции + 1);
									НоваяДлинаСтроки = СтрДлина(Строка);
									Если НоваяДлинаСтроки > 1 Тогда
										НомерПозиции = 1;
									Иначе
										НомерПозиции = НоваяДлинаСтроки;
									КонецЕсли;
									
									НомФрагмента = НомФрагмента + 1;
									МакетФрагТекст = "0";
									
							Иначе //Начало параметра
								КонецПозицииПараметра = СтрНайти(Строка, "]");
								
								Если КонецПозицииПараметра = 0 Тогда
									КонецПозицииПараметра = СтрДлина(Строка);
									ПараметрСтрокиПоиска = Лев(Строка, КонецПозицииПараметра);
									ТекстСообщения = СтрШаблон(НСтр("ru = 'Для параметра ""%1"" не задана закрывающая скобка ""]"".'"), ПараметрСтрокиПоиска);
									ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
								Иначе
									ПараметрСтроки = Лев(Строка, КонецПозицииПараметра);
									ПараметрСтрокиПоиска = СтрЗаменить(ПараметрСтроки,"[","");
									ПараметрСтрокиПоиска = СтрЗаменить(ПараметрСтрокиПоиска,"]","");
								
									ДанныеПараметра = ПолучитьДанныеПоЭлементу(ПараметрыПолученияДанных,
										ПараметрСтрокиПоиска,
										ЗначенияПараметров[ПараметрСтроки], 
										НомФрагмента,
										Ошибки,
										Предупреждения);
									
									Если ДанныеПараметра <> Неопределено Тогда
										Если ДанныеПараметра.ЭтоТиповойЭлемент Тогда
											ТиповойФрагмент = Истина;
											
											НовыйФрагмент = ТаблицаФрагментов.Добавить();
											НовыйФрагмент.Параметр = ДанныеПараметра.Параметр;
											НовыйФрагмент.СодержаниеФрагмента = ДанныеПараметра.СодержаниеФрагмента;
											НовыйФрагмент.СтильФрагмента = СтильФрагТекст;
											НовыйФрагмент.ТиповойФрагмент = ТиповойФрагмент;
											НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
											НовыйФрагмент.ЦифровойКодТиповогоНаименования = ДанныеПараметра.ЦифровойКодТиповогоНаименования;
											НовыйФрагмент.БуквенныйКодТиповогоНаименования = ДанныеПараметра.БуквенныйКодТиповогоНаименования;
											НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
											НовыйФрагмент.Выравнивание = МакетВыравнивание;
											НовыйФрагмент.Связан = ДанныеПараметра.Связан;
											НовыйФрагмент.Родитель = ДанныеПараметра.Родитель;
											НовыйФрагмент.ОписаниеТиповогоЭлемента = ДанныеПараметра.ОписаниеТиповогоЭлемента;
											
										Иначе //Произвольный элемент
											ТиповойФрагмент = Ложь;
											
											НовыйФрагмент = ТаблицаФрагментов.Добавить();
											НовыйФрагмент.СодержаниеФрагмента = ДанныеПараметра.СодержаниеФрагмента;
											НовыйФрагмент.СтильФрагмента = СтильФрагТекст;
											НовыйФрагмент.ТиповойФрагмент = ТиповойФрагмент;
											НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
											НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
											НовыйФрагмент.Выравнивание = МакетВыравнивание;
											
										КонецЕсли;
										
										НомФрагмента = НомФрагмента + 1;
										
									КонецЕсли;
									
								КонецЕсли;
								
								МакетФрагТекст = "0";
								
								Строка = Прав(Строка, СтрДлина(Строка) - КонецПозицииПараметра);
								НоваяДлинаСтроки = СтрДлина(Строка);
								Если НоваяДлинаСтроки > 1 Тогда
									НомерПозиции = 1;
								Иначе
									НомерПозиции = НоваяДлинаСтроки;
								КонецЕсли;
								
							КонецЕсли;
								
						КонецЦикла;
						
					КонецЦикла;
				КонецЦикла;
				
			КонецЦикла;
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ТаблицаФрагментов;
	
КонецФункции

#КонецОбласти

#Область ПреобразованиеOfficeOpenXML

Функция ЗаполнитьТаблицуФрагментовПоДокументуOfficeOpenXML(ДвоичныеДанныеМакета, ОбъектыПечати, КодЯзыка, Ошибки, Предупреждения);
	
	// сборка дерева документа из DOCX
	ДеревоДокумента = МакетИзДвоичныхДанныхСКД(ДвоичныеДанныеМакета);
	
	// получение параметров и их значений
	ТекстXML = ДеревоДокумента.Строки[0].ПолныйТекст;
	ПараметрыТекста = УправлениеПечатью.НайтиПараметрыВТексте(ТекстXML);
	ПоляМакета = Новый Массив;
	Для Каждого Текст Из ПараметрыТекста Цикл
		Текст = ОчиститьКвадратныеСкобки(Текст);
		ПоляМакета.Добавить(Текст);
	КонецЦикла;
	ДанныеПечати = УправлениеПечатью.ДанныеПечати(ОбъектыПечати, ПоляМакета, КодЯзыка);
	ОбъектПечати = ОбъектыПечати[0];
	ЗначенияПараметров = ПолучитьЗначениеПараметровОбъекта(ДанныеПечати, ОбъектПечати, КодЯзыка, ПараметрыТекста);
	Если Не СтрЧислоВхождений(ТекстXML, "[") = СтрЧислоВхождений(ТекстXML, "]") Тогда
		ТекстСообщения = НСтр("ru = 'В шаблоне не совпадает количество открывающих и закрывающих квадратных скобок.'");
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Ошибки, "", ТекстСообщения, "");
	КонецЕсли;
	
	// инициализация служебных таблиц
	ТаблицаФрагментов = НоваяТаблицаФрагментов();
	ТаблицаСоответствий = ТаблицаСоответствийПараметровИТиповыхНаименований();
	ПараметрыИспользования = УправлениеПечатью.ДанныеПечати(ОбъектыПечати, ТаблицаСоответствий.ВыгрузитьКолонку("Использование"), КодЯзыка);
	
	ПараметрыПолученияДанных = Новый Структура();
	ПараметрыПолученияДанных.Вставить("ТаблицаСоответствий", ТаблицаСоответствий);
	ПараметрыПолученияДанных.Вставить("ТаблицаКодов", ПереченьТиповыхНаименованийЭлементовДоговоров());
	ПараметрыПолученияДанных.Вставить("ПараметрыИспользования", ПараметрыИспользования[ОбъектПечати]);
	ПараметрыПолученияДанных.Вставить("КодЯзыка", КодЯзыка);
	
	// обход узлов с текстом в дереве документа, заполнение таблицы фрагментов
	УзелНачалаТекста = ПолучитьУзел(ДеревоДокумента, "w:document/w:body");
	НомФрагмента = 1;
	ЕстьТаблицы = Ложь;
	
	Для Каждого УзелАбзаца Из УзелНачалаТекста.Строки Цикл
		
		Если УзелАбзаца.ИмяТега = "w:tbl" Тогда
			ЕстьТаблицы = Истина;
			Продолжить;
		КонецЕсли;
		
		МакетФрагТекст = "2";
		УзлыТекстов = ПолучитьУзлыПоИмениТега(УзелАбзаца, "w:t");
		
		Если УзлыТекстов.Количество() = 0 Тогда
			НовыйФрагмент = ТаблицаФрагментов.Добавить();
			НовыйФрагмент.СодержаниеФрагмента = Символы.НПП;
			НовыйФрагмент.СтильФрагмента = НовыйЭлементСтиляXML101();
			НовыйФрагмент.ТиповойФрагмент = Ложь;
			НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
			НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
			НовыйФрагмент.Выравнивание = "0";
			НомФрагмента = НомФрагмента + 1;
		КонецЕсли;
		
		Для Каждого УзелТекста Из УзлыТекстов Цикл
			
			Строка = УзелТекста.Текст;
			СтильФрагмента = НовыйЭлементСтиляXML101(УзелТекста.Стиль);
			Выравнивание = ПолучитьЗначениеВыравниванияОбластиOfficeOpenXML(УзелТекста.Стиль);
			
			Если Не ЗначениеЗаполнено(Строка) Тогда
				
				НовыйФрагмент = ТаблицаФрагментов.Добавить();
				НовыйФрагмент.СодержаниеФрагмента = Символы.НПП;
				НовыйФрагмент.СтильФрагмента = СтильФрагмента;
				НовыйФрагмент.ТиповойФрагмент = Ложь;
				НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
				НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
				НовыйФрагмент.Выравнивание = Выравнивание;
				НомФрагмента = НомФрагмента + 1;
				
				Продолжить;
				
			КонецЕсли;
			
			ПараметрыТекста = УправлениеПечатью.НайтиПараметрыВТексте(Строка(Строка));
			НомерПозиции = 1;
			
			Пока НомерПозиции <= СтрДлина(Строка) И Не СтрДлина(Строка) = 0 Цикл
				
				ТиповойФрагмент = Ложь;
				
				Если Лев(Строка, НомерПозиции) <> "[" Тогда //Текст - заполняем произвольный блок
					
					НомерПозиции = СтрНайти(Строка, "[");
					Если НомерПозиции = 0 Тогда //В строке нет параметров, записываем всю строку
						СодержаниеФрагмента = Строка;
						НомерПозиции = СтрДлина(Строка);
					Иначе
						НомерПозиции = НомерПозиции - 1;
						СодержаниеФрагмента = Лев(Строка, НомерПозиции);
					КонецЕсли;
					
					НовыйФрагмент = ТаблицаФрагментов.Добавить();
					НовыйФрагмент.СодержаниеФрагмента  = СодержаниеФрагмента;
					НовыйФрагмент.СтильФрагмента = СтильФрагмента;
					НовыйФрагмент.ТиповойФрагмент = ТиповойФрагмент;
					НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
					НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
					НовыйФрагмент.Выравнивание = Выравнивание;
					
					Строка = Прав(Строка, СтрДлина(Строка) - НомерПозиции);
					НоваяДлинаСтроки = СтрДлина(Строка);
					Если НоваяДлинаСтроки > 1 Тогда
						НомерПозиции = 1;
					Иначе
						НомерПозиции = НоваяДлинаСтроки;
					КонецЕсли;
					
					НомФрагмента = НомФрагмента + 1;
					МакетФрагТекст = "0";
					
				Иначе //Начало параметра
					КонецПозицииПараметра = СтрНайти(Строка, "]");
					
					ПараметрСтроки = Лев(Строка, КонецПозицииПараметра);
					
					ПараметрСтрокиПоиска = СтрЗаменить(ПараметрСтроки,"[","");
					ПараметрСтрокиПоиска = СтрЗаменить(ПараметрСтрокиПоиска,"]","");
					
					ДанныеПараметра = ПолучитьДанныеПоЭлементу(ПараметрыПолученияДанных,
						ПараметрСтрокиПоиска,
						ЗначенияПараметров[ПараметрСтроки], 
						НомФрагмента,
						Ошибки,
						Предупреждения);
						
					Если ДанныеПараметра <> Неопределено Тогда
						Если ДанныеПараметра.ЭтоТиповойЭлемент Тогда
							ТиповойФрагмент = Истина;
							
							НовыйФрагмент = ТаблицаФрагментов.Добавить();
							НовыйФрагмент.Параметр = ДанныеПараметра.Параметр;
							НовыйФрагмент.СодержаниеФрагмента = ДанныеПараметра.СодержаниеФрагмента;
							НовыйФрагмент.СтильФрагмента = СтильФрагмента;
							НовыйФрагмент.ТиповойФрагмент = ТиповойФрагмент;
							НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
							НовыйФрагмент.ЦифровойКодТиповогоНаименования = ДанныеПараметра.ЦифровойКодТиповогоНаименования;
							НовыйФрагмент.БуквенныйКодТиповогоНаименования = ДанныеПараметра.БуквенныйКодТиповогоНаименования;
							НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
							НовыйФрагмент.Выравнивание = Выравнивание;
							НовыйФрагмент.Связан = ДанныеПараметра.Связан;
							НовыйФрагмент.Родитель = ДанныеПараметра.Родитель;
							НовыйФрагмент.ОписаниеТиповогоЭлемента = ДанныеПараметра.ОписаниеТиповогоЭлемента;
							
						Иначе //Произвольный элемент
							
							НовыйФрагмент = ТаблицаФрагментов.Добавить();
							НовыйФрагмент.СодержаниеФрагмента = ДанныеПараметра.СодержаниеФрагмента;
							НовыйФрагмент.СтильФрагмента = СтильФрагмента;
							НовыйФрагмент.ТиповойФрагмент = ТиповойФрагмент;
							НовыйФрагмент.ПорядковыйНомер = НомФрагмента;
							НовыйФрагмент.ВизуализацияТекста.Добавить(МакетФрагТекст);
							НовыйФрагмент.Выравнивание = Выравнивание;
							
						КонецЕсли;
						
						НомФрагмента = НомФрагмента + 1;
						
					КонецЕсли;
					
					МакетФрагТекст = "0";
					
					Строка = Прав(Строка, СтрДлина(Строка) - КонецПозицииПараметра);
					НоваяДлинаСтроки = СтрДлина(Строка);
					Если НоваяДлинаСтроки > 1 Тогда
						НомерПозиции = 1;
					Иначе
						НомерПозиции = НоваяДлинаСтроки;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЦикла;
	КонецЦикла;
	
	Если ЕстьТаблицы Тогда
		ТекстСообщения = НСтр("ru = 'В шаблоне DOCX присутствуют таблицы. Содержимое таблиц не передается в электронный документ.'");
		ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Предупреждения, "", ТекстСообщения, "");
	КонецЕсли;
	
	Возврат ТаблицаФрагментов
	
КонецФункции

Функция МакетИзДвоичныхДанныхСКД(ДвоичныеДанныеМакета)
	
	// разбор контейнера DOCX
	Если БезопасныйРежим() <> Ложь Тогда
		УстановитьОтключениеБезопасногоРежима(Истина);
	КонецЕсли;
	
	Расширение = ОпределитьРасширениеФайлаДанныхПоСигнатуре(ДвоичныеДанныеМакета);
	Если Расширение <> "docx" Тогда
		ТекстОшибки = НСтр("ru = 'Макет шаблона офисного документа имеет неверный формат.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("docx");
	КаталогСоСтруктуройФайла = ФайловаяСистема.СоздатьВременныйКаталог();
	ДвоичныеДанныеМакета.Записать(ИмяВременногоФайла);
	
	РазобратьКонтейнерДокументDOCX(ИмяВременногоФайла, КаталогСоСтруктуройФайла);
	
	УдалитьФайлы(ИмяВременногоФайла);
	
	Файл = Новый Файл(КаталогСоСтруктуройФайла + "word" + ПолучитьРазделительПути() + "document.xml");
	Если Не Файл.Существует() Тогда
		ТекстОшибки = НСтр("ru = 'Файл не существует.'");
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	// используемые в документе стили
	СтилиДокумента = Новый Соответствие;
	ФайлСтили = Новый Файл(КаталогСоСтруктуройФайла + "word" + ПолучитьРазделительПути() + "styles.xml");
	Если ФайлСтили.Существует() Тогда
		ЧтениеXML = ИнициализироватьЧтениеXML(ФайлСтили.ПолноеИмя, 1);
		ЧтениеXML.ИгнорироватьПробелы = Ложь;
		ПрочитатьСтили(ЧтениеXML, СтилиДокумента, ИнициализироватьСтильOfficeOpenXML());
	КонецЕсли;
	
	// определение стиля по умолчанию
	Если СтилиДокумента.Получить("Default") = Неопределено Тогда
		СтилиДокумента.Вставить("Default", СтильOfficeOpenXMLПоУмолчанию());
	Иначе	
		ЗаполнитьПустыеЗначенияСвойств(СтилиДокумента.Получить("Default"), СтильOfficeOpenXMLПоУмолчанию());
	КонецЕсли;
	
	// чтение XML
	ЧтениеXML = ИнициализироватьЧтениеXML(Файл.ПолноеИмя, 1);
	ЧтениеXML.ИгнорироватьПробелы = Ложь;
	Дерево = ИнициализироватьДеревоДокумента();
	ПрочитатьЗапись(ЧтениеXML, Дерево, ИнициализироватьСтильOfficeOpenXML(), СтилиДокумента);
	
	Возврат Дерево;
	
КонецФункции

Функция ПрочитатьЗапись(ЧтениеXML, СтрокаДерева, Знач Стиль, СтилиДокумента, ЗнакиТабуляции = "")
	
	ПолныйТекст = "";
	АтрибутСвойство = СоответствиеАтрибутовСвойствамСтиля();
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			
			Если ЧтениеXML.Имя = "w:p" Тогда
				Стиль = ИнициализироватьСтильOfficeOpenXML();
			ИначеЕсли ЧтениеXML.Имя = "w:rPr" Тогда
				Стиль.Полужирный = Ложь;
				Стиль.Курсив = Ложь;
			ИначеЕсли ЧтениеXML.Имя = "w:tab" Тогда
				ЗнакиТабуляции = ЗнакиТабуляции + Символы.Таб;
			КонецЕсли;
			
			НоваяСтрока = СтрокаДерева.Строки.Добавить();
			НоваяСтрока.ИмяТега = ЧтениеXML.Имя;
			НоваяСтрока.Атрибуты = ПолучитьАтрибуты(ЧтениеXML, Стиль, АтрибутСвойство);
			НоваяСтрока.Текст = "";
			НоваяСтрока.ПолныйТекст = ПрочитатьЗапись(ЧтениеXML, НоваяСтрока, Стиль, СтилиДокумента, ЗнакиТабуляции);
			ПолныйТекст = ПолныйТекст + НоваяСтрока.ПолныйТекст;
			
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Возврат ПолныйТекст;
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			Если ТипЗнч(СтрокаДерева) <> Тип("СтрокаДереваЗначений") ИЛИ (СтрНачинаетсяС(ЧтениеXML.Значение, Символ(10))) Тогда
				Продолжить;
			КонецЕсли;
			
			СтрокаДерева.Текст = ЗнакиТабуляции + СтрЗаменить(ЧтениеXML.Значение, Символ(160), " ");
			СтрокаДерева.ПолныйТекст = СтрокаДерева.Текст;
			ЗнакиТабуляции = "";
			
			НовыйСтиль = ИнициализироватьСтильOfficeOpenXML();
			ЗаполнитьЗначенияСвойств(НовыйСтиль, Стиль);
			Если ЗначениеЗаполнено(НовыйСтиль.Родитель) Тогда
				ЗаполнитьПустыеЗначенияСвойств(НовыйСтиль, СтилиДокумента[НовыйСтиль.Родитель], "Идентификатор, Тип, Родитель");
				НовыйСтиль.Родитель = "";
			КонецЕсли;
			ЗаполнитьПустыеЗначенияСвойств(НовыйСтиль, СтилиДокумента["Default"], "Идентификатор, Тип, Родитель");
			
			СтрокаДерева.Стиль = НовыйСтиль;
			
			ПолныйТекст = ПолныйТекст + СтрокаДерева.ПолныйТекст;
			ЧтениеXML.Прочитать();
			Возврат ПолныйТекст;
		Иначе
			ВызватьИсключение (НСтр("ru = 'Не известный:'") + " " + ЧтениеXML.ТипУзла);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПолныйТекст;
	
КонецФункции

Процедура ПрочитатьСтили(ЧтениеXML, СтилиДокумента, Стиль)
	
	АтрибутСвойство = СоответствиеАтрибутовСвойствамСтиля();
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			
			ИмяТекущего = ЧтениеXML.Имя;
			
			Если ИмяТекущего = "w:style" Тогда
				Стиль = ИнициализироватьСтильOfficeOpenXML();
			КонецЕсли;
			
			СвойствоСтиля = АтрибутСвойство.Получить(ИмяТекущего);
			Если ЗначениеЗаполнено(СвойствоСтиля) Тогда
				Стиль[СвойствоСтиля] = Истина;
			КонецЕсли;
			
			Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
				СвойствоСтиля = АтрибутСвойство.Получить(ИмяТекущего + "/" + ЧтениеXML.Имя);
				Если Не СвойствоСтиля = Неопределено Тогда
					Стиль[СвойствоСтиля] = ЧтениеXML.Значение;
				КонецЕсли;
			КонецЦикла;
			
			ПрочитатьСтили(ЧтениеXML, СтилиДокумента, Стиль);
			
		ИначеЕсли ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			
			Если ЧтениеXML.Имя = "w:style" Или ЧтениеXML.Имя = "w:docDefaults" Тогда
				
				НовыйСтиль = ИнициализироватьСтильOfficeOpenXML();
				Если ЧтениеXML.Имя = "w:docDefaults" Тогда 
					Стиль.Идентификатор = "Default";
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(НовыйСтиль, Стиль);
				
				// заполнение свойств из родительского стиля
				Если ЧтениеXML.Имя = "w:style" Тогда
					НовыйСтиль.Родитель = ?(ЗначениеЗаполнено(НовыйСтиль.Родитель), НовыйСтиль.Родитель, "Default");
				КонецЕсли;
				Если ЗначениеЗаполнено(НовыйСтиль.Родитель) Тогда
					ЗаполнитьПустыеЗначенияСвойств(НовыйСтиль, СтилиДокумента[НовыйСтиль.Родитель], "Идентификатор, Тип, Родитель");
					НовыйСтиль.Родитель = "";
				КонецЕсли;
				
				СтилиДокумента.Вставить(НовыйСтиль.Идентификатор, НовыйСтиль);
				
			КонецЕсли;
			
			Возврат
			
		Иначе
			ВызватьИсключение (НСтр("ru = 'Не известный:'") + " " + ЧтениеXML.ТипУзла);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьЗначениеПараметровОбъекта(ДанныеПечати, ОбъектПечати, КодЯзыка, ПараметрыПечати)
	
	ДанныеОбъекта = ДанныеПечати[ОбъектПечати];
	НастройкиФорматаПолей = ДанныеПечати["НастройкиФорматаПолей"];
	
	СоответствиеСтроки = Новый Соответствие();
	Для Каждого ПараметрОбласти Из ПараметрыПечати Цикл
		
		ПараметрыТекста = УправлениеПечатью.НайтиПараметрыВТексте(Строка(ПараметрОбласти));
		ЗначенияПараметров = ЗначенияПараметров(ПараметрыТекста, ДанныеОбъекта, НастройкиФорматаПолей, КодЯзыка);
		Представление = ЗаменитьВСтроке(ПараметрОбласти, ЗначенияПараметров);
		
		СоответствиеСтроки.Вставить(ПараметрОбласти, Представление);
		
	КонецЦикла;
	
	Возврат СоответствиеСтроки;
		
КонецФункции

Функция ОпределитьРасширениеФайлаДанныхПоСигнатуре(ДанныеИлиСтруктура)
	
	Если ТипЗнч(ДанныеИлиСтруктура) = Тип("Структура") Тогда
		Попытка
			МакетИДанныеОбъекта = УправлениеПечатью.МакетыИДанныеОбъектовДляПечати(ДанныеИлиСтруктура.МенеджерПечати,
				ДанныеИлиСтруктура.Идентификатор, Новый Массив);
			ДвоичныеДанныеМакета = МакетИДанныеОбъекта.Макеты.ДвоичныеДанныеМакетов.Получить(ДанныеИлиСтруктура.Идентификатор);
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	Иначе
		ДвоичныеДанныеМакета = ДанныеИлиСтруктура;
	КонецЕсли;
	
	Если ДвоичныеДанныеМакета = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПотокДанных = ДвоичныеДанныеМакета.ОткрытьПотокДляЧтения();
	ЧтениеДанных = Новый ЧтениеДанных(ПотокДанных);
	
	Символ1 = ЧтениеДанных.ПрочитатьБайт();
	Символ2 = ЧтениеДанных.ПрочитатьБайт();
	Символ3 = ЧтениеДанных.ПрочитатьБайт();
	Символ4 = ЧтениеДанных.ПрочитатьБайт();
	Символ5 = ЧтениеДанных.ПрочитатьБайт();
	Символ6 = ЧтениеДанных.ПрочитатьБайт();
	Символ7 = ЧтениеДанных.ПрочитатьБайт();
	Символ8 = ЧтениеДанных.ПрочитатьБайт();
	
	ПотокДанных.Закрыть();
	
	Если Символ1 = 208 И Символ2 = 207 И Символ3 = 17 И Символ4 = 224 И Символ5 = 161 И Символ6 = 177 И Символ7 = 26 И Символ8 = 225 Тогда
		Возврат "doc";
	ИначеЕсли Символ1 = 80 И Символ2 = 75 И Символ3 = 3 И Символ4 = 4 И Символ5 = 20
			  ИЛИ Символ1 = 80 И Символ2 = 75 И Символ3 = 3 И Символ4 = 4 И Символ5 = 10 Тогда
			  	
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла("docx");
	
		ДвоичныеДанныеМакета.Записать(ИмяВременногоФайла);
		Попытка
			Архиватор = Новый ЧтениеZipФайла(ИмяВременногоФайла);
		Исключение
			УдалитьФайлы(ИмяВременногоФайла);
			ВызватьИсключение(НСтр("ru = 'Не удалось открыть файл шаблона по причине:'") + Символы.ПС 
				+ ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		Если Архиватор.Элементы.Найти("document.xml") = Неопределено Тогда
			Расширение = "odt";
		Иначе
			Расширение = "docx";
		КонецЕсли;
		Архиватор.Закрыть();
		УдалитьФайлы(ИмяВременногоФайла);
		
		Возврат Расширение;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

Процедура РазобратьКонтейнерДокументDOCX(Знач ПолноеИмяФайла, Знач ПутьКСтруктуреФайла)
	
	Попытка
		Архиватор = Новый ЧтениеZipФайла(ПолноеИмяФайла);
	Исключение
		УдалитьФайлы(ПолноеИмяФайла);
		ВызватьИсключение(НСтр("ru = 'Не удалось открыть файл шаблона по причине:'") + Символы.ПС 
			+ ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Попытка
		Архиватор.ИзвлечьВсе(ПутьКСтруктуреФайла, РежимВосстановленияПутейФайловZIP.Восстанавливать);
	Исключение
		Архиватор.Закрыть();
		УдалитьФайлы(ПолноеИмяФайла);
		ВызватьИсключение(НСтр("ru = 'Не удалось выполнить разбор файла шаблона по причине:'") + Символы.ПС 
			+ ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Архиватор.Закрыть();
	
КонецПроцедуры

Функция ИнициализироватьДеревоДокумента()
	
	Дерево = Новый ДеревоЗначений;
	Дерево.Колонки.Добавить("ИмяТега", Новый ОписаниеТипов("Строка"));
	Дерево.Колонки.Добавить("Текст", Новый ОписаниеТипов("Строка"));
	Дерево.Колонки.Добавить("ПолныйТекст", Новый ОписаниеТипов("Строка"));
	Дерево.Колонки.Добавить("Атрибуты", Новый ОписаниеТипов("Соответствие"));
	Дерево.Колонки.Добавить("Индекс", Новый ОписаниеТипов("Число"));
	Дерево.Колонки.Добавить("Стиль", Новый ОписаниеТипов("Структура"));
	
	Возврат Дерево
	
КонецФункции

Функция ИнициализироватьСтильOfficeOpenXML()
	
	Стиль = Новый Структура;
	
	Стиль.Вставить("Идентификатор", "");
	Стиль.Вставить("Тип", "");
	Стиль.Вставить("Родитель", "");
	Стиль.Вставить("Выравнивание", "");
	Стиль.Вставить("СемействоШрифта", "");
	Стиль.Вставить("Полужирный", Ложь);
	Стиль.Вставить("Курсив", Ложь);
	Стиль.Вставить("Цвет", ""); // шестнадцатеричное значение в формате RRGGBB
	Стиль.Вставить("РазмерШрифта", ""); // размер шрифта в полу-пунктах(1/144 дюйма)
	
	Возврат Стиль
	
КонецФункции

Функция ИнициализироватьЧтениеXML(ДанныеЧтения, ТипДанных = 0)
	
	ЧтениеXML = Новый ЧтениеXML;
	Если ТипДанных = 0 Тогда
		ЧтениеXML.УстановитьСтроку(ДанныеЧтения);
	Иначе
		ЧтениеXML.ОткрытьФайл(ДанныеЧтения);
	КонецЕсли;
	
	ЧтениеXML.ИгнорироватьПробелы = ЛОЖЬ;
	
	Возврат ЧтениеXML;
	
КонецФункции

Функция НовыйЭлементСтиляXML101(Стиль = Неопределено)
	
	Стиль = ?(ЗначениеЗаполнено(Стиль), Стиль, СтильOfficeOpenXMLПоУмолчанию());
	
	СтильФрагТекст = Новый Соответствие();
	СтильФрагТекст.Вставить("name", "");
	СтильФрагТекст.Вставить("font_family", Стиль.СемействоШрифта);
	СтильФрагТекст.Вставить("font_weight", ?(Стиль.Полужирный, "bold","normal"));
	СтильФрагТекст.Вставить("font_style", ?(Стиль.Курсив, "italic", "normal"));
	СтильФрагТекст.Вставить("сolor", "#" + Стиль.Цвет);
	СтильФрагТекст.Вставить("font_size", Строка(Число(Стиль.РазмерШрифта)/2));
	
	Возврат СтильФрагТекст;
	
КонецФункции

Функция СтильOfficeOpenXMLПоУмолчанию()
	
	Стиль = Новый Структура;
	
	Стиль.Вставить("Родитель", "");
	Стиль.Вставить("Выравнивание", "start");
	Стиль.Вставить("СемействоШрифта", "Arial");
	Стиль.Вставить("Полужирный", Ложь);
	Стиль.Вставить("Курсив", Ложь);
	Стиль.Вставить("Цвет", "000000"); // шестнадцатеричное значение в формате RRGGBB
	Стиль.Вставить("РазмерШрифта", "26"); // размер шрифта в полу-пунктах(1/144 дюйма)
	
	Возврат Стиль
	
КонецФункции

Функция СоответствиеАтрибутовСвойствамСтиля()
	
	АтрибутСвойство = Новый Соответствие();
	
	АтрибутСвойство.Вставить("w:style/w:styleId", "Идентификатор");
	АтрибутСвойство.Вставить("w:style/w:type", "Тип");
	АтрибутСвойство.Вставить("w:basedOn/w:val", "Родитель");
	АтрибутСвойство.Вставить("w:pStyle/w:val", "Родитель");
	АтрибутСвойство.Вставить("w:jc/w:val", "Выравнивание");
	АтрибутСвойство.Вставить("w:sz/w:val", "РазмерШрифта");
	АтрибутСвойство.Вставить("w:szCs/w:val", "РазмерШрифта");
	АтрибутСвойство.Вставить("w:rFonts/w:ascii", "СемействоШрифта");
	АтрибутСвойство.Вставить("w:b", "Полужирный");
	АтрибутСвойство.Вставить("w:i", "Курсив");
	АтрибутСвойство.Вставить("w:color/w:val", "Цвет");
	
	Возврат АтрибутСвойство
	
КонецФункции

Функция ПолучитьЗначениеВыравниванияОбластиOfficeOpenXML(Стиль)
	
	МакетВыравн = 0;
	
	Если Стиль.Выравнивание = "start" Или Стиль.Выравнивание = "left" Тогда
		МакетВыравн = 0;
	ИначеЕсли Стиль.Выравнивание = "end" Или Стиль.Выравнивание = "right" Тогда
		МакетВыравн = 1;
	ИначеЕсли Стиль.Выравнивание = "center" Тогда
		МакетВыравн = 2;
	ИначеЕсли Стиль.Выравнивание = "both" Или Стиль.Выравнивание = "distribute" Тогда
		МакетВыравн = 3;
	КонецЕсли;
	
	Возврат МакетВыравн;
	
КонецФункции

Функция ПолучитьАтрибуты(ЧтениеXML, Стиль, АтрибутСвойство)
	
	ИмяТекущего = ЧтениеXML.Имя;
	СвойствоСтиля = АтрибутСвойство.Получить(ИмяТекущего);
	Если ЗначениеЗаполнено(СвойствоСтиля) Тогда
		Стиль[СвойствоСтиля] = Истина;
	КонецЕсли;
	
	СоответствиеАтрибутов = Новый Соответствие;
	Пока ЧтениеXML.ПрочитатьАтрибут() Цикл
		СоответствиеАтрибутов.Вставить(ЧтениеXML.Имя, ЧтениеXML.Значение);
		
		СвойствоСтиля = АтрибутСвойство.Получить(ИмяТекущего + "/" + ЧтениеXML.Имя);
		Если Не СвойствоСтиля = Неопределено Тогда
			Стиль[СвойствоСтиля] = ЧтениеXML.Значение;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат СоответствиеАтрибутов;
	
КонецФункции

Функция ПолучитьУзел(Дерево, Знач Путь)
	МассивПути = СтрРазделить(Путь, "/", Ложь);
	МассивНайденныхСтрок = Дерево.Строки.НайтиСтроки(Новый Структура("ИмяТега", МассивПути[0]), Ложь);
	Если МассивНайденныхСтрок.Количество() Тогда
		Если МассивПути.Количество() = 1 Тогда
			Возврат МассивНайденныхСтрок[0];
		ИначеЕсли МассивПути.Количество() Тогда
			МассивПути.Удалить(0);
			Возврат ПолучитьУзел(МассивНайденныхСтрок[0], СтрСоединить(МассивПути, "/"));
		КонецЕсли;
	КонецЕсли;
	Возврат Неопределено;
КонецФункции

Функция ПолучитьУзлыПоИмениТега(УзелДокумента, ИмяТэга, Узлы = Неопределено)
	
	Если Узлы = Неопределено Тогда
		Узлы = Новый Массив;
	КонецЕсли;
	
	Если УзелДокумента.ИмяТега = ИмяТэга Тогда
		Узлы.Добавить(УзелДокумента);
	КонецЕсли;
	
	Для Каждого ДочернийУзел Из УзелДокумента.Строки Цикл
		ПолучитьУзлыПоИмениТега(ДочернийУзел, ИмяТэга, Узлы);
	КонецЦикла;
	
	Возврат Узлы;
	
КонецФункции

Процедура ЗаполнитьПустыеЗначенияСвойств(Приемник, Источник, ИсключаяСвойства = "")
	
	ПропуститьСвойства = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаяСвойства, ",",, Истина);
	
	Для Каждого Элемент Из Источник Цикл
		
		Если Не ПропуститьСвойства.Найти(Элемент.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначениеПриемника = ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Приемник, Элемент.Ключ);
		
		Если ЗначениеЗаполнено(Элемент.Значение) И ЗначениеПриемника <> Неопределено И
			(Не ЗначениеЗаполнено(ЗначениеПриемника) Или ЗначениеПриемника = Ложь) Тогда
			
			Приемник[Элемент.Ключ] = Элемент.Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область БлокОбщихПроцедурИФункций

// Добавляет значение в списокXDTO.
//
// Параметры:
//	ЭлементДерева - СписокXDTO - список значений.
//	Данные - ОбъектXDTO, Строка - добавляемые данные.
//
Процедура ДобавитьОписаниеФрагмента(ЭлементДерева, Данные)
	ЭлементДерева.Добавить(Данные);
КонецПроцедуры

Функция ПереченьТиповыхНаименованийЭлементовДоговоров()
	
	Макет = ПолучитьМакет("ПереченьТиповыхНаименованийЭлементовДоговоров");
	
	ТаблицаПеречня = Новый ТаблицаЗначений;
	ТаблицаПеречня.Колонки.Добавить("Код",           ОбщегоНазначения.ОписаниеТипаСтрока(10)); 
	ТаблицаПеречня.Колонки.Добавить("Описание",      ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаПеречня.Колонки.Добавить("Наименование",  ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаПеречня.Колонки.Добавить("МеткаДоговора", ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаПеречня.Колонки.Добавить("Формат",        ОбщегоНазначения.ОписаниеТипаСтрока(255));
	
	КоличествоСтрок = Макет.ВысотаТаблицы;
	
	Для НомерСтроки = 2 По КоличествоСтрок Цикл
		
		НоваяСтрока = ТаблицаПеречня.Добавить();
		НомерСтрокиСтрока = Формат(НомерСтроки,"ЧГ=");
		
		НоваяСтрока.Код           = СокрЛП(Макет.Область(СтрШаблон("R%1C1", НомерСтрокиСтрока)).Текст);
		НоваяСтрока.Описание      = СокрЛП(Макет.Область(СтрШаблон("R%1C2", НомерСтрокиСтрока)).Текст);
		НоваяСтрока.Наименование  = СокрЛП(Макет.Область(СтрШаблон("R%1C3", НомерСтрокиСтрока)).Текст);
		НоваяСтрока.МеткаДоговора = НРег(СокрЛП(Макет.Область(СтрШаблон("R%1C4", НомерСтрокиСтрока)).Текст));
		НоваяСтрока.Формат        = СокрЛП(Макет.Область(СтрШаблон("R%1C5", НомерСтрокиСтрока)).Текст);
		
	КонецЦикла;
	
	Возврат ТаблицаПеречня;
	
КонецФункции

Функция ТаблицаСоответствийПараметровИТиповыхНаименований()
	
	Макет = ПолучитьМакет("СоответствияПараметровИМеток");
	
	ТаблицаСоответствий = Новый ТаблицаЗначений;
	ТаблицаСоответствий.Колонки.Добавить("ТиповойЭлемент", ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаСоответствий.Колонки.Добавить("Параметр", ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаСоответствий.Колонки.Добавить("Родитель", ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаСоответствий.Колонки.Добавить("СвязанС", ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаСоответствий.Колонки.Добавить("Форматирование", ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаСоответствий.Колонки.Добавить("Использование", ОбщегоНазначения.ОписаниеТипаСтрока(255));
	ТаблицаСоответствий.Колонки.Добавить("ПроверкаЗаполнения", Новый ОписаниеТипов("Булево"));
	
	КоличествоСтрок = Макет.ВысотаТаблицы;
	
	Для НомерСтроки = 2 По КоличествоСтрок Цикл
		
		НоваяСтрока = ТаблицаСоответствий.Добавить();
		
		НомерСтрокиСтрока = Формат(НомерСтроки,"ЧГ=");
		
		НоваяСтрока.Параметр          = НРег(СокрЛП(Макет.Область(СтрШаблон("R%1C1", НомерСтрокиСтрока)).Текст));
		НоваяСтрока.ТиповойЭлемент = СокрЛП(Макет.Область(СтрШаблон("R%1C2", НомерСтрокиСтрока)).Текст);
		СвязанС = СокрЛП(Макет.Область(СтрШаблон("R%1C3", НомерСтрокиСтрока)).Текст);
		Если ЗначениеЗаполнено(СвязанС) Тогда  
			НоваяСтрока.СвязанС = СвязанС;
		КонецЕсли;
		Родитель = СокрЛП(Макет.Область(СтрШаблон("R%1C4", НомерСтрокиСтрока)).Текст);
		Если ЗначениеЗаполнено(Родитель) Тогда
			НоваяСтрока.Родитель = НРег(Родитель);
		КонецЕсли;
		НоваяСтрока.Форматирование = СокрЛП(Макет.Область(СтрШаблон("R%1C5", НомерСтрокиСтрока)).Текст);
		НоваяСтрока.Использование = СокрЛП(Макет.Область(СтрШаблон("R%1C6", НомерСтрокиСтрока)).Текст);
		ПроверкаЗаполненияРеквизита = НРег(СокрЛП(Макет.Область(СтрШаблон("R%1C7", НомерСтрокиСтрока)).Текст));
		Если ПроверкаЗаполненияРеквизита = "да" Тогда
			НоваяСтрока.ПроверкаЗаполнения = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТаблицаСоответствий;
	
КонецФункции

Функция ПолучитьДанныеПоЭлементу(ПараметрыПолученияДанных, Параметр, ЗначениеПараметра, НомерСтроки, Ошибки, Предупреждения)
	
	ТаблицаСоответствий = ПараметрыПолученияДанных.ТаблицаСоответствий;
	ТаблицаКодов = ПараметрыПолученияДанных.ТаблицаКодов;
	ПараметрыИспользования = ПараметрыПолученияДанных.ПараметрыИспользования;
	КодЯзыка = ПараметрыПолученияДанных.КодЯзыка;
	
	ПараметрПоиска = НРег(Параметр);
	
	ДанныеЭлемента = Новый Структура();
	ДанныеЭлемента.Вставить("Параметр", ПараметрПоиска);
	ДанныеЭлемента.Вставить("ЦифровойКодТиповогоНаименования","");
	ДанныеЭлемента.Вставить("ПорядковыйНомер","");
	ДанныеЭлемента.Вставить("ЭтоТиповойЭлемент", Ложь);
	ДанныеЭлемента.Вставить("Связан","");
	ДанныеЭлемента.Вставить("Родитель","");
	ДанныеЭлемента.Вставить("БуквенныйКодТиповогоНаименования","");
	ДанныеЭлемента.Вставить("СодержаниеФрагмента", ?(Строка(ЗначениеПараметра) = "", Символы.НПП, Строка(ЗначениеПараметра)));
	ДанныеЭлемента.Вставить("ОписаниеТиповогоЭлемента");
	
	ПараметрыПоиска = Новый Структура();
	ПараметрыПоиска.Вставить("Параметр", ПараметрПоиска);
	СтрокиПараметра = ТаблицаСоответствий.НайтиСтроки(ПараметрыПоиска);
	КоличествоНайденныхПараметров = СтрокиПараметра.Количество();
	Если КоличествоНайденныхПараметров > 0 Тогда
		
		Если КоличествоНайденныхПараметров > 1 Тогда
			ЗначениеИспользования = Ложь;
			Для Каждого СтрокаПараметра Из СтрокиПараметра Цикл
				Если ЗначениеЗаполнено(СтрокаПараметра.Использование) Тогда
					ИспользоватьТиповойРеквизит = ВычислитьВыражение("["+ СтрокаПараметра.Использование +"]", ПараметрыИспользования, Новый Соответствие(), КодЯзыка);
					Если ТипЗнч(ИспользоватьТиповойРеквизит) = Тип("Булево")
						И ИспользоватьТиповойРеквизит = Истина Тогда
						ЗначениеИспользования = Истина;
						Прервать;
					КонецЕсли;
				Иначе
					ЗначениеИспользования = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не ЗначениеИспользования Тогда
				ТекстСообщения = СтрШаблон(НСтр("ru = 'Для параметра ""%1"" не найден типовой элемент по условию использования. Параметр выгружен не будет.'"), Параметр);
				ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Предупреждения, "", ТекстСообщения, "");
				Возврат Неопределено;
			КонецЕсли;
		Иначе
			СтрокаПараметра = СтрокиПараметра[0];
			Если ЗначениеЗаполнено(СтрокаПараметра.Использование) Тогда
				ИспользоватьТиповойРеквизит = ВычислитьВыражение("["+ СтрокаПараметра.Использование +"]", ПараметрыИспользования, Новый Соответствие(), КодЯзыка);
				Если ТипЗнч(ИспользоватьТиповойРеквизит) = Тип("Булево")
					И ИспользоватьТиповойРеквизит Тогда
					СтрокаПараметра = СтрокиПараметра[0];
				Иначе
					ТекстСообщения = СтрШаблон(НСтр("ru = 'Для параметра ""%1"" не подходит типовой элемент ""%2"" по условию использования. Параметр выгружен не будет.'"), Параметр, СтрокаПараметра.ТиповойЭлемент);
					ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Предупреждения, "", ТекстСообщения, "");
					Возврат Неопределено;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
			
		СтрокаКодов = ТаблицаКодов.Найти(НРег(СтрокаПараметра.ТиповойЭлемент), "МеткаДоговора");
		Если СтрокаКодов <> Неопределено Тогда
			ДанныеЭлемента.ЭтоТиповойЭлемент = Истина;
			ДанныеЭлемента.ЦифровойКодТиповогоНаименования = СтрокаКодов.Код;
			ДанныеЭлемента.БуквенныйКодТиповогоНаименования = СтрокаПараметра.ТиповойЭлемент;
			ДанныеЭлемента.ОписаниеТиповогоЭлемента = СтрокаКодов.Описание+" ("+ДанныеЭлемента.БуквенныйКодТиповогоНаименования+")";
			Если ЗначениеЗаполнено(СтрокаКодов.Формат) Тогда
				ДанныеЭлемента.СодержаниеФрагмента = Формат(ЗначениеПараметра, СтрокаКодов.Формат);
			КонецЕсли;
			Если Не ЗначениеЗаполнено(ДанныеЭлемента.СодержаниеФрагмента) Тогда
				ДанныеЭлемента.СодержаниеФрагмента = " ";
				ТекстСообщения = НСтр("ru = 'Не заполнен типовой элемент'");
				ТекстСообщения = ТекстСообщения + " " + ДанныеЭлемента.БуквенныйКодТиповогоНаименования +" ("+ Параметр+")";
					Поле = ОбщегоНазначенияКлиентСервер.ПутьКТабличнойЧасти("ТаблицаРеквизитов",
															НомерСтроки,
															"СодержаниеФрагмента");
					ОбщегоНазначенияКлиентСервер.ДобавитьОшибкуПользователю(Предупреждения, Поле, ТекстСообщения, "");
			КонецЕсли;
		КонецЕсли;
		Если ЗначениеЗаполнено(СтрокаПараметра.Родитель) Тогда
			ДанныеЭлемента.Родитель = НРег(СтрокаПараметра.Родитель);
		ИначеЕсли ЗначениеЗаполнено(СтрокаПараметра.СвязанС) Тогда
			ДанныеЭлемента.Связан = СтрокаПараметра.СвязанС;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ДанныеЭлемента;
	
КонецФункции

// Новый элемент стиля фрагмента для заполнения в XML.
//
// Параметры:
//   Шрифт - Шрифт - данные шрифта.
//   ЦветТекста - Цвет - данные цвета текста.
//
// Возвращаемое значение:
//   Соответствие из КлючИЗначение - описание стиля фрагмента:
//   * Ключ - Строка - имя атрибута стиля:
//        # name - имя стиля.
//        # font_family - имя шрифта.
//        # font_weight - жирность шрифта.
//        # font_style - стиль шрифта.
//        # сolor - цвет шрифта.
//        # font_size - размер шрифта.
//   * Значение - Строка - значение атрибута стиля.
//
Функция НовыйЭлементСтиля(Шрифт, ЦветТекста)
	
	СтильФрагТекст = Новый Соответствие();
	СтильФрагТекст.Вставить("name", "");
	
	Если Шрифт.Вид = ВидШрифта.АвтоШрифт Тогда
		СтильФрагТекст.Вставить("font_family", "Arial");
		СтильФрагТекст.Вставить("font_size", "13");
	Иначе
		СтильФрагТекст.Вставить("font_family", Шрифт.Имя);
		СтильФрагТекст.Вставить("font_size", Строка(Шрифт.Размер));
	КонецЕсли;
	
	СтильФрагТекст.Вставить("font_weight", ?(Шрифт.Полужирный, "bold","normal"));
	СтильФрагТекст.Вставить("font_style", ?(Шрифт.Наклонный, "italic", "normal"));
	
	ЦветТекстаФрагмента = "#000000";
	Если ЦветТекста.Вид <> ВидЦвета.АвтоЦвет Тогда
		ЦветТекстаФрагмента = ШестнадцатеричныйЦвет(ЦветТекста.Красный, ЦветТекста.Зеленый, ЦветТекста.Синий);
	КонецЕсли;
	СтильФрагТекст.Вставить("сolor", ЦветТекстаФрагмента);
	
	Возврат СтильФрагТекст;
	
КонецФункции

Функция ШестнадцатеричныйЦвет(Знач Красный, Знач Зеленый, Знач Синий)
	
		ЦветЧислом = Красный + Зеленый*256 + Синий*65536;
		Буфер = Новый БуферДвоичныхДанных(4, ПорядокБайтов.LittleEndian);
		Буфер.ЗаписатьЦелое32(0, ЦветЧислом);
		ЦветСтрокой = СтрШаблон("#%1", Лев(ПолучитьHexСтрокуИзБуфераДвоичныхДанных(Буфер), 6));
		
		Возврат ЦветСтрокой;
		
КонецФункции

Функция ПолучитьЗначениеВыравниванияОбласти(ОбластьЯчейки)
	
	МакетВыравнивание = 0;
	
	Если ОбластьЯчейки.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Лево Тогда
		МакетВыравнивание = 0;
	ИначеЕсли ОбластьЯчейки.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право Тогда
		МакетВыравнивание = 1;
	ИначеЕсли ОбластьЯчейки.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Центр Тогда
		МакетВыравнивание = 2;
	ИначеЕсли ОбластьЯчейки.ГоризонтальноеПоложение = ГоризонтальноеПоложение.ПоШирине Тогда
		МакетВыравнивание = 3;
	КонецЕсли;
	
	Возврат МакетВыравнивание;
	
КонецФункции

Функция ПолучитьДанныеФайлаXDTO(Знач ДвоичныеДанные)
	
	ОписаниеФайла = РаботаСФайламиБЭДКлиентСервер.НовоеОписаниеФайла();
	ПространствоИмен = Обработки.ФорматДоговорныйДокументИнформацияОтправителяЭДО.ПространствоИмен();
	
	ОписаниеФайла.ДвоичныеДанные = ДвоичныеДанные;
	ОписаниеФайла.ИмяФайла = СтрШаблон("%1.xml", ПространствоИмен);
	ОписаниеОшибки = "";
	
	ДанныеФайлаЭД = ФорматыЭДО.ДанныеФайлаЭД(ОписаниеФайла, ОписаниеОшибки, Обработки.ФорматДоговорныйДокументИнформацияОтправителяЭДО.ПространствоИмен());
	
	Если НЕ ПустаяСтрока(ОписаниеОшибки) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ДанныеФайлаЭД;
	
КонецФункции

Процедура ЗаполнитьДанныеВизуализацииИЗXML(Визуализация, СписокДанных)
	
	Для Каждого ЗначениеВизуализацияТекста Из СписокДанных Цикл
		Визуализация.Добавить(ЗначениеВизуализацияТекста);
	КонецЦикла;
	
КонецПроцедуры

// Процедура - Заполнить стиль объекта из XML
//
// Параметры:
//  СтильФрагмента	 - Соответствие из КлючИЗначение - результат подключения компоненты:
//   * Ключ - Строка - имя атрибута стиля:
//        # name - имя стиля.
//        # font_family - имя шрифта.
//        # font_weight - жирность шрифта.
//        # font_style - стиль шрифта.
//        # сolor - цвет шрифта.
//        # font_size - размер шрифта.
//   * Значение - Строка - значение атрибута стиля.
//  СтильОбъекта	 - ОбъектXDTO - данные элемента стиля. 
//
Процедура ЗаполнитьСтильОбъектаИзXML(СтильФрагмента, СтильОбъекта)
	
	Для Каждого СвойствоОбъекта Из СтильОбъекта.Свойства() Цикл
		ЗначениеСвойстваОбъекта = РаботаСФайламиБЭД.ЗначениеСвойстваXDTO(СтильОбъекта, СвойствоОбъекта.Имя);
		СтильФрагмента.Вставить(СвойствоОбъекта.Имя, ЗначениеСвойстваОбъекта);
	КонецЦикла;
	
КонецПроцедуры

// Удаляет из XML пространство имен.
//
// Параметры:
//  ДанныеXML - ДвоичныеДанные - Данные XML.
//  ПространствоИмен - Строка - Пространство имен, которое необходимо удалить.
//  Кодировка - Строка - Кодировка данных XML.
//
// Возвращаемое значение:
//  ДвоичныеДанные - Двоичные данные XML без удаленного пространства имен.
//
Функция УдалитьПространствоИмен(Знач ДанныеXML, Знач ПространствоИмен, Знач Кодировка = "windows-1251")
	
	ПотокЧтения = ДанныеXML.ОткрытьПотокДляЧтения();
	
	Чтение = Новый ЧтениеТекста(ПотокЧтения, Кодировка);
	ТекстXML = Чтение.Прочитать();
	Чтение.Закрыть();
	
	Текст = Новый ТекстовыйДокумент;
	Текст.УстановитьТекст(ТекстXML);
	СтрокаФайл = Текст.ПолучитьСтроку(2);
	СтрокаФайл = СтрЗаменить(СтрокаФайл, "xmlns=""" + ПространствоИмен + """", "");
	Текст.ЗаменитьСтроку(2, СтрокаФайл);
	ТекстXML = Текст.ПолучитьТекст();
	
	ПотокЗаписи = Новый ПотокВПамяти();
	
	Запись = Новый ЗаписьТекста(ПотокЗаписи, Кодировка);
	Запись.Записать(ТекстXML);
	Запись.Закрыть();
	
	ДвоичныеДанные = ПотокЗаписи.ЗакрытьИПолучитьДвоичныеДанные();
	
	Возврат ДвоичныеДанные;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииМодуляУправленияПечатью

Функция ОбластиМакета(Макет, ДанныеПечати)
	
	Таблицы = ДанныеПечати["ИменаТабличныхЧастейОбъекта"];
	ВсеОбласти = Новый СписокЗначений;
	ОбластиТаблиц = Новый Соответствие;
	
	ОбластиСУсловиями = Новый Соответствие;
	Для Каждого Область Из Макет.Области Цикл
		Если ТипЗнч(Область) = Тип("ОбластьЯчеекТабличногоДокумента") И Область.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Строки Тогда
			ОбластиСУсловиями.Вставить(Область.Верх, Область);
		КонецЕсли;
	КонецЦикла;	
	
	ОбластиДляОбработки = Новый Массив;
	
	НачалоОбласти = 1;
	Для НомерСтроки = 1 По Макет.ВысотаТаблицы Цикл
		Если ОбластиСУсловиями[НомерСтроки] <> Неопределено Тогда
			Если НачалоОбласти < НомерСтроки Тогда
				Область = Макет.Область(НачалоОбласти, , НомерСтроки-1);
				ОбластиДляОбработки.Добавить(Область);
			КонецЕсли;
			ОбластиДляОбработки.Добавить(ОбластиСУсловиями[НомерСтроки]);
			НомерСтроки = ОбластиСУсловиями[НомерСтроки].Низ;
			НачалоОбласти = НомерСтроки + 1;
		КонецЕсли;
	КонецЦикла;
	
	Если Макет.ВысотаТаблицы >= НачалоОбласти Тогда
		Область = Макет.Область(НачалоОбласти, , Макет.ВысотаТаблицы);
		ОбластиДляОбработки.Добавить(Область);
	КонецЕсли;
	
	Для Каждого Область Из ОбластиДляОбработки Цикл // ОбластьЯчеекТабличногоДокумента
		ОписаниеОбластей = РазделитьНаОбласти(Макет, Область, Таблицы);
		ОбщегоНазначенияКлиентСервер.ДополнитьСоответствие(ОбластиТаблиц, ОписаниеОбластей.ОбластиТаблиц);
		УсловиеВывода = "";
		Если Макет.Области.Найти(Область.Имя) <> Неопределено Тогда
			УсловиеВывода = Область.ПараметрРасшифровки;
		КонецЕсли;
		Для Каждого ИдентификаторОбласти Из ОписаниеОбластей.ВсеОбласти Цикл
			ВсеОбласти.Добавить(ИдентификаторОбласти, УсловиеВывода);
		КонецЦикла;
	КонецЦикла;

	Результат = Новый Структура;
	Результат.Вставить("ВсеОбласти", ВсеОбласти);
	Результат.Вставить("ОбластиТаблиц", ОбластиТаблиц);
	
	Возврат Результат;
	
КонецФункции

Функция РазделитьНаОбласти(Макет, Область, Таблицы)
	
	ВсеОбласти = Новый Массив;
	ОбластиТаблиц = Новый Соответствие;
	
	НачалоОбласти = Область.Верх;
	ТекущаяТаблица = "";
	ПредыдущаяТаблица = "";
	
	Для НомерСтроки = Область.Верх По Область.Низ Цикл
		ОбластьСтроки = Макет.Область(НомерСтроки, , НомерСтроки);
		ТекущаяТаблица = ИмяТаблицыВОбластиМакета(Макет, ОбластьСтроки, Таблицы);
	
		Если ПредыдущаяТаблица <> ТекущаяТаблица И НомерСтроки > НачалоОбласти Тогда
			ИдентификаторОбласти = СтрШаблон("R%1:R%2", XMLСтрока(НачалоОбласти), XMLСтрока(НомерСтроки - 1));
			ВсеОбласти.Добавить(ИдентификаторОбласти);
			
			Если ЗначениеЗаполнено(ПредыдущаяТаблица) Тогда
				ОбластиТаблиц.Вставить(ИдентификаторОбласти, ПредыдущаяТаблица);
			КонецЕсли;
			
			НачалоОбласти = НомерСтроки;
		КонецЕсли;

		ПредыдущаяТаблица = ТекущаяТаблица;
	КонецЦикла;
	
	ИдентификаторОбласти = СтрШаблон("R%1:R%2", XMLСтрока(НачалоОбласти), XMLСтрока(Область.Низ));

	Если ЗначениеЗаполнено(ТекущаяТаблица) Тогда
		ОбластиТаблиц.Вставить(ИдентификаторОбласти, ПредыдущаяТаблица);
	КонецЕсли;
	ВсеОбласти.Добавить(ИдентификаторОбласти);
	
	Результат = Новый Структура;
	Результат.Вставить("ВсеОбласти", ВсеОбласти);
	Результат.Вставить("ОбластиТаблиц", ОбластиТаблиц);
	
	Возврат Результат;
	
КонецФункции

Функция ИмяТаблицыВОбластиМакета(Макет, Область, Таблицы)

	ИмяТаблицы = "";
	Для НомерСтроки = Область.Верх По Область.Низ Цикл
		Для НомерСтолбца = 1 По Макет.ШиринаТаблицы Цикл
			Область = Макет.Область(НомерСтроки, НомерСтолбца, НомерСтроки, НомерСтолбца);

			Для Каждого Таблица Из Таблицы Цикл
				СтрокаПоиска = "[" + Таблица + ".";
				Если СтрНайти(Область.Текст, СтрокаПоиска) Тогда
					ИмяТаблицы = Таблица;
					Прервать;
				КонецЕсли;
			КонецЦикла;

			Если ЗначениеЗаполнено(ИмяТаблицы) Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если ЗначениеЗаполнено(ИмяТаблицы) Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИмяТаблицы;
	
КонецФункции

Функция ВычислитьВыражение(Знач ИсходноеВыражение, ДанныеПечати, НастройкиФорматаПолей, КодЯзыка, ПрименятьФорматирование = Неопределено)
	
	Выражение = ИсходноеВыражение;
	Выражение = Сред(Выражение, 2, СтрДлина(Выражение) - 2);
	
	ЭлементыФормулы = КонструкторФормулСлужебный.ЭлементыФормулы(Выражение);
	ВыделитьИмяКолонкиТабличнойЧасти(Выражение, ЭлементыФормулы);
	
	ПараметрыПечати = Новый Массив;
	
	Если ПрименятьФорматирование = Неопределено Тогда
		ПрименятьФорматирование = Ложь;
		
		Если ЭлементыФормулы.ОперандыИФункции.Количество() = 1 Тогда
			Для Каждого ОписаниеЭлемента Из ЭлементыФормулы.ОперандыИФункции Цикл
				ЭтоФункция = ОписаниеЭлемента.Значение;
				Если ЭтоФункция Тогда
					Прервать;
				КонецЕсли;
				Операнд = ЭлементыФормулы.ВсеЭлементы[ОписаниеЭлемента.Ключ];
				ПрименятьФорматирование = Операнд = Выражение;
				Прервать;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого ОписаниеЭлемента Из ЭлементыФормулы.ОперандыИФункции Цикл
		Операнд = ЭлементыФормулы.ВсеЭлементы[ОписаниеЭлемента.Ключ];
		ЭтоФункция = ОписаниеЭлемента.Значение;
		КоллекцияДанных = ДанныеПечати;
		
		Если Не ЭтоФункция Тогда
			Если СтрНайти("И,ИЛИ,НЕ,ИСТИНА,ЛОЖЬ", ВРег(Операнд)) Тогда
				Продолжить;
			КонецЕсли;
			
			Значение = КоллекцияДанных[ОчиститьКвадратныеСкобки(Операнд) + "." + СтрРазделить(КодЯзыка, "_")[0]];
			Если Не ЗначениеЗаполнено(Значение) Тогда
				Значение = КоллекцияДанных[ОчиститьКвадратныеСкобки(Операнд)];
			КонецЕсли;
			
			// Ищем значение с перечислением
			Если Не ЗначениеЗаполнено(Значение) И СтрНайти(ВРег(Операнд), "ПЕРЕЧИСЛЕНИЯ") Тогда
				ИмяПеречисления = СтрРазделить(Операнд, ".")[1];
				ЗначениеПеречисления = СтрРазделить(Операнд, ".")[2];
				Значение = Перечисления[ИмяПеречисления][ЗначениеПеречисления];
			КонецЕсли;
			
			// Ищем значение через точку
			Если Значение = Неопределено Тогда
				МассивСтроки = СтрРазделить(Операнд, ".");
				Если МассивСтроки.Количество() > 1 Тогда
					Элемент = МассивСтроки[0];
					РеквизитЭлемента = МассивСтроки[1];
					НайденныйЭлемент = КоллекцияДанных[Элемент]; 
					Если ЗначениеЗаполнено(НайденныйЭлемент) 
						И ОбщегоНазначенияУТКлиентСервер.ЕстьРеквизитОбъекта(НайденныйЭлемент, РеквизитЭлемента) Тогда 
						Значение = НайденныйЭлемент[РеквизитЭлемента];
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			Формат = "";
			Если ПрименятьФорматирование Тогда
				Формат = НастройкиФорматаПолей[Операнд];
			КонецЕсли;

			Если ЗначениеЗаполнено(Формат) И ЭлементыФормулы.ОперандыИФункции.Количество() = 1 Тогда
				Если ЗначениеЗаполнено(КодЯзыка) Тогда
					Формат = СтрШаблон("Л=%1;", КодЯзыка) + Формат;
				КонецЕсли;
				Значение = Формат(Значение, Формат);
			КонецЕсли;
			
			ПараметрыПечати.Добавить(Значение);
			ЭлементыФормулы.ВсеЭлементы[ОписаниеЭлемента.Ключ] = "Параметры[" + ПараметрыПечати.ВГраница() + "]";
		КонецЕсли;
	КонецЦикла;
	
	Выражение = СтрСоединить(ЭлементыФормулы.ВсеЭлементы);
	Выражение = СтрЗаменить(Выражение, "УправлениеПечатью_", "УправлениеПечатью.");
	
	Попытка
		Результат = ОбщегоНазначения.ВычислитьВБезопасномРежиме(Выражение, ПараметрыПечати);
	Исключение
		ТекстОшибки = ОбработкаОшибок.КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		ОбщегоНазначения.СообщитьПользователю(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Выражение ""%1"" содержит ошибки:
			|%2'"), ИсходноеВыражение, ТекстОшибки));
		Результат = "";
	КонецПопытки;
	
	Возврат Результат;
	
КонецФункции

Процедура ВыделитьИмяКолонкиТабличнойЧасти(Выражение, ЭлементыФормулы)
	ФункцииСРазделениемПараметров = СтрРазделить("УправлениеПечатью_СуммаПоКолонке,УправлениеПечатью_КоличествоСтрок,УправлениеПечатью_Максимум,УправлениеПечатью_Минимум,УправлениеПечатью_Среднее",",", Ложь);
	ФункцияНайдена = Ложь;
	Для Каждого ИмяФункции Из ФункцииСРазделениемПараметров Цикл
		Если СтрНайти(Выражение, ИмяФункции) Тогда
			ФункцияНайдена = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ФункцияНайдена Тогда
		Результат = Новый Массив;
		ВсеЭлементыВыражения = ЭлементыФормулы.ВсеЭлементы;
		Для Индекс = 0 По ВсеЭлементыВыражения.ВГраница() Цикл
			Элемент = ВсеЭлементыВыражения[Индекс];
			Результат.Добавить(Элемент);
			Если СтрНачинаетсяС(Элемент, "УправлениеПечатью_") Тогда
				Результат.Добавить(ВсеЭлементыВыражения[Индекс+1]); 
				МассивИменПараметра = СтрРазделить(ВсеЭлементыВыражения[Индекс+2], ".", Ложь);
				Результат.Добавить(МассивИменПараметра[0]);
				Результат.Добавить(",");
				Если МассивИменПараметра.Количество() = 2 Тогда
					Результат.Добавить("""");
					ИмяКолонки = МассивИменПараметра[1];
					Для Позиция = 1 По СтрДлина(ИмяКолонки) Цикл
						Результат.Добавить(Сред(ИмяКолонки, Позиция, 1));
					КонецЦикла;
					Результат.Добавить("""");
				КонецЕсли;
				Результат.Добавить(ВсеЭлементыВыражения[Индекс+3]);
				Индекс = Индекс + 3;
			КонецЕсли;
		КонецЦикла;
		ЭлементыФормулы.ВсеЭлементы = Результат;
	КонецЕсли;
	
КонецПроцедуры

Функция ПоляМакета(Макет)

	Тексты = Новый Соответствие;
	
	ОбработанныеЯчейки = Новый Соответствие;
	Для НомерСтроки = 1 По Макет.ВысотаТаблицы Цикл
		Для НомерСтолбца = 1 По Макет.ШиринаТаблицы Цикл
			ОбластьЯчейки = Макет.Область(НомерСтроки, НомерСтолбца, НомерСтроки, НомерСтолбца);
			
			ИдентификаторОбласти = УправлениеПечатью.ИдентификаторОбласти(ОбластьЯчейки);
			Если ОбработанныеЯчейки[ИдентификаторОбласти] <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ОбработанныеЯчейки[ИдентификаторОбласти] = Истина;
			
			Если Не ЗначениеЗаполнено(ОбластьЯчейки.Текст) Тогда
				Продолжить;
			КонецЕсли;
			
			Тексты.Вставить(ОбластьЯчейки.Текст, Истина);
		КонецЦикла;
	КонецЦикла;
	
	Тексты.Вставить(Строка(Макет.ВерхнийКолонтитул.ТекстСлева), Истина);
	Тексты.Вставить(Строка(Макет.ВерхнийКолонтитул.ТекстВЦентре), Истина);
	Тексты.Вставить(Строка(Макет.ВерхнийКолонтитул.ТекстСправа), Истина);

	Тексты.Вставить(Строка(Макет.НижнийКолонтитул.ТекстСлева), Истина);
	Тексты.Вставить(Строка(Макет.НижнийКолонтитул.ТекстВЦентре), Истина);
	Тексты.Вставить(Строка(Макет.НижнийКолонтитул.ТекстСправа), Истина);
	
	Для Каждого Область Из Макет.Области Цикл
		Если ТипЗнч(Область) = Тип("ОбластьЯчеекТабличногоДокумента")
			И Область.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Строки Тогда
			УсловиеВывода = Область.ПараметрРасшифровки;
			Если ЗначениеЗаполнено(УсловиеВывода) Тогда
				Тексты.Вставить(Область.ПараметрРасшифровки);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Результат = Новый Массив;

	Для Каждого Элемент Из Тексты Цикл
		Текст = Элемент.Ключ;
		ПараметрыТекста = УправлениеПечатью.НайтиПараметрыВТексте(Текст);
		Для Каждого Выражение Из ПараметрыТекста Цикл
			Выражение = Сред(Выражение, 2, СтрДлина(Выражение) - 2);
			ЭлементыФормулы = КонструкторФормулСлужебный.ЭлементыФормулы(Выражение);
			Для Каждого ОписаниеЭлемента Из ЭлементыФормулы.ОперандыИФункции Цикл
				ЭтоФункция = ОписаниеЭлемента.Значение;
				Если ЭтоФункция Тогда
					Продолжить;
				КонецЕсли;
				
				Операнд = ЭлементыФормулы.ВсеЭлементы[ОписаниеЭлемента.Ключ];
				Операнд = ОчиститьКвадратныеСкобки(Операнд);
				Если ЗначениеЗаполнено(Операнд) Тогда
					Результат.Добавить(Операнд);
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ОчиститьКвадратныеСкобки(Строка)
	
	Если СтрНачинаетсяС(Строка, "[") И СтрЗаканчиваетсяНа(Строка, "]") Тогда
		Возврат Сред(Строка, 2, СтрДлина(Строка) - 2);
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции

Функция ЗначенияПараметров(Параметры, ДанныеПечати, НастройкиФорматаПолей, КодЯзыка)
	
	Результат = Новый Соответствие;

	Для Каждого Параметр Из Параметры Цикл
		Значение = ВычислитьВыражение(Параметр, ДанныеПечати, НастройкиФорматаПолей, КодЯзыка);
		Результат.Вставить(Параметр, Значение);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЗаменитьВСтроке(Знач Строка, ПараметрыЗамены)
	
	Для Каждого Элемент Из ПараметрыЗамены Цикл
		ПодстрокаПоиска = Элемент.Ключ;
		ПодстрокаЗамены = Элемент.Значение;
		Строка = СтрЗаменить(Строка, ПодстрокаПоиска, ПодстрокаЗамены);
	КонецЦикла;
	
	Возврат Строка;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#КонецЕсли